{"version":3,"file":"openApi-CcUF29dR.cjs","names":["__filename","__dirname","path","fs","ts","fs","path","path","colors","registryRegExp","getRegistryUrl","parseShorthand","queryParams: string | undefined","registryRegExp","getRegistryUrl","namespace","parseShorthand","defaultWatch: Watch","inputs: Array<Input>","input: Input","logs: Config['logs']","a: Partial<UserConfig>","b: Partial<UserConfig>","merged: UserConfig","valueToObject: ValueToObject","mappers","ts","path","fs","fields","defaultValue","defaultConfig","resolvePath","resolvePath","uniqueItems: Array<IR.SchemaObject>","typeIds: Array<string>","path","result: OperationResponsesMap","errors: Omit<IR.SchemaObject, 'properties'> &\n    Pick<Required<IR.SchemaObject>, 'properties'>","responses: Omit<IR.SchemaObject, 'properties'> &\n    Pick<Required<IR.SchemaObject>, 'properties'>","defaultResponse: IR.ResponseObject | undefined","nodeBrand","result: R | void | undefined","ts","Mixed","ts","Mixed","ts","impl: T | undefined","Mixed","ts","index: number","reserved","Mixed","ts","result!: AccessResult","node","accessChain: Array<TsDsl>","nodes: Array<TsDsl>","lines","ts","ts","Mixed","Mixed","ts","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","entries: Record<string, string>","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","f","ts","Mixed","ts","Mixed","ts","Mixed","node","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","lines","ts","Mixed","ts","result","missing: Array<string>","Mixed","ts","fromValue","Mixed","ts","Mixed","ts","Mixed","normalized: Array<string | ts.Expression>","ts","spans: Array<ts.TemplateSpan>","Mixed","ts","Mixed","ts","lines","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","flat: Array<ts.TypeNode>","ts","Mixed","ts","Mixed","ts","missing: Array<string>","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","Mixed","ts","missing: Array<string>","Mixed","ts","missing: Array<string>","Mixed","flat: Array<ts.TypeNode>","ts","Mixed","ts","normalized: Array<string | ts.TypeNode>","ts","spans: Array<ts.TemplateLiteralTypeSpan>","ts","path","parentCount: number","lines: Array<string>","exports","ts","exprValue","typeValue","f","p","auth: Array<Auth>","path","nameToLocations: Record<string, Set<Location>>","signatureParameters: SignatureParameters","fields: Array<Field>","signatureParameter: SignatureParameter","result: OperationParameters","query: SymbolMeta","ref","responseTypeValue: ReturnType<typeof getResponseType> | undefined","statements: Array<ReturnType<typeof $.return | typeof $.const>>","args: Array<ReturnType<typeof $.expr>>","config: Array<ReturnType<typeof $.object>>","clientExpression: ReturnType<typeof $.attr | typeof $.binary>","f","source","attachComment","f","c","dependencies: Array<ReturnType<typeof $.class>>","node","p","t","nodes: Array<ReturnType<typeof $.var>>","nodes: Array<ReturnType<typeof $.class | typeof $.var>>","EOL","comments: Array<string>","f","node","nodes: Array<ReturnType<typeof $.var>>","nodes: Array<ReturnType<typeof $.class>>","handler: AngularCommonPlugin['Handler']","StructureModel","allDependencies: Array<ReturnType<typeof $.class | typeof $.var>>","allNodes: Array<ReturnType<typeof $.class | typeof $.var>>","defaultConfig: AngularCommonPlugin['Config']","defineConfig","defaultConfig","__filename","__dirname","path","renamed: Map<string, string> | undefined","fs","dirPath","errorResponse: Url","path","createClient: PluginHandler","defaultConfig: HeyApiClientAngularPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientAxiosPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientFetchPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientKyPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientNextPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientNuxtPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientOfetchPlugin['Config']","defineConfig","defaultConfig","satisfies: typeof semver.satisfies","handler: HeyApiSchemasPlugin['Handler']","defaultConfig: HeyApiSchemasPlugin['Config']","defineConfig","defaultConfig","methods: OperationsConfig['methods']","strategy: OperationsConfig['strategy'] | undefined","containerName: OperationsConfig['containerName'] | undefined","segmentName: OperationsConfig['segmentName'] | undefined","methods: OperationsConfig['methods'] | undefined","nesting: OperationsConfig['nesting'] | undefined","methodName: OperationsConfig['methodName'] | undefined","handlerV1: HeyApiSdkPlugin['Handler']","StructureModel","allDependencies: Array<ReturnType<typeof $.class | typeof $.var>>","allNodes: Array<ReturnType<typeof $.class | typeof $.var>>","handler: HeyApiSdkPlugin['Handler']","handlerV1","defaultConfig: HeyApiSdkPlugin['Config']","defineConfig","defaultConfig","bigIntExpressions: ExpressionTransformer","dateExpressions: ExpressionTransformer","query: SymbolMeta","mapCallbackStatements: Array<Expr>","nodes: Array<Expr>","arrayNodes: Array<Expr>","handler: HeyApiTransformersPlugin['Handler']","defaultConfig: HeyApiTransformersPlugin['Config']","defineConfig","defaultConfig","types: Array<TypeTsDsl>","comments: Array<string>","typeofItems: Array<\n    | 'bigint'\n    | 'boolean'\n    | 'function'\n    | 'number'\n    | 'object'\n    | 'string'\n    | 'symbol'\n    | 'undefined'\n  >","key: string | undefined","symbol","node","type","irSchema: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","operationToDataType","data: IR.SchemaObject","dataRequired: Array<string>","irSchemaToAst","node","data: IR.SchemaObject","dataRequired: Array<string>","node","irSchemaToAst","arrayToAst","itemTypes: Array<MaybeTsDsl<TypeTsDsl>>","irSchemaToAst","booleanToAst","enumToAst","irSchemaToAst","neverToAst","nullToAst","objectToAst","indexSchemas: Array<IR.SchemaObject>","irSchemaToAst","p","stringToAst","query: SymbolMeta","queryTypeId: SymbolMeta","symbolTypeId","tupleToAst","itemTypes: Array<MaybeTsDsl<TypeTsDsl>>","irSchemaToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","neverToAst","nullToAst","objectToAst","stringToAst","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","irSchemaWithTypeToAst","handleComponent","handlerV1: HeyApiTypeScriptPlugin['Handler']","servers: Array<IR.ServerObject>","webhooks: Array<Symbol>","Api","irSchemaToAstV1","handler: HeyApiTypeScriptPlugin['Handler']","handlerV1","defaultConfig: HeyApiTypeScriptPlugin['Config']","Api","defineConfig","defaultConfig","handleMeta","useTypeData","useTypeError","useTypeResponse","useTypeData","createMutationOptions","fnOptions","statements: Array<ReturnType<typeof $.var | typeof $.return>>","f","handleMeta","useTypeResponse","useTypeError","TOptionsType","createQueryKeyFunction","createQueryKeyLiteral","tagsExpression: ReturnType<typeof $.array> | undefined","createQueryKeyType","queryKeyStatement","optionsParamName","createQueryOptions","keyExpression: ReturnType<typeof $.call>","queryKeyStatement","tagsExpr: ReturnType<typeof $.array> | undefined","statements: Array<ReturnType<typeof $.return | typeof $.const>>","handleMeta","handlerV0: PiniaColadaPlugin['Handler']","handler: PiniaColadaPlugin['Handler']","defaultConfig: PiniaColadaPlugin['Config']","handler","defineConfig","defaultConfig","tagsArray: TsDsl<ts.ArrayLiteralExpression> | undefined","f","statements: Array<TsDsl<any>>","fnOptions","statements: Array<TsDsl<any>>","optionsParamName","statements: Array<TsDsl<any>>","handlerV5: PluginHandler","handler: PluginHandler","defaultConfig: TanStackAngularQueryPlugin['Config']","handler","defineConfig","defaultConfig","defaultConfig: TanStackReactQueryPlugin['Config']","handler","defineConfig","defaultConfig","defaultConfig: TanStackSolidQueryPlugin['Config']","handler","defineConfig","defaultConfig","defaultConfig: TanStackSvelteQueryPlugin['Config']","handler","defineConfig","defaultConfig","defaultConfig: TanStackVueQueryPlugin['Config']","handler","defineConfig","defaultConfig","Api","identifiers","exportAst","identifiers","nullToAst","result: Partial<Omit<Ast, 'typeName'>>","identifiers","objectToAst","result: Partial<Omit<Ast, 'typeName'>>","irSchemaToAst","result: Partial<Omit<Ast, 'typeName'>>","identifiers","irSchemaWithTypeToAst","nullToAst","objectToAst","irSchemaToAst","ast: Partial<Ast>","query: SymbolMeta","ref","irSchemaWithTypeToAst","handleComponent","handlerV2: ArktypePlugin['Handler']","handler: ArktypePlugin['Handler']","handlerV2","defaultConfig: ArktypePlugin['Config']","Api","fields","defaultValue","defineConfig","defaultConfig","errorsTypeReference: ReturnType<typeof $.type> | undefined","responsesTypeReference: ReturnType<typeof $.type> | undefined","handler: FastifyPlugin['Handler']","defaultConfig: FastifyPlugin['Config']","defineConfig","defaultConfig","statements: Array<TsDsl<any>>","handlerV2: SwrPlugin['Handler']","handler: SwrPlugin['Handler']","defaultConfig: SwrPlugin['Config']","handler","defineConfig","defaultConfig","identifiers","pipesToNode: PipesToNode","pipes","identifiers","pushPipes: PushPipes","pipes: PipesUtils","validatorResolver","identifiers","ctx: ValidatorResolverContext","Api","shouldCoerceToBigInt: ShouldCoerceToBigInt","maybeBigInt: MaybeBigInt","exportAst","v","identifiers","irOperationToAst","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","path","irWebhookToAst","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","unknownToAst","identifiers","arrayToAst","result: Omit<Ast, 'typeName'>","identifiers","unknownToAst","irSchemaToAst","booleanToAst","pipes: Array<ReturnType<typeof $.call>>","identifiers","pipes","enumToAst","enumMembers: Array<ReturnType<typeof $.literal>>","unknownToAst","identifiers","neverToAst","identifiers","nullToAst","identifiers","integerRange: Record<string, [Range, Range]>","getIntegerLimit: GetIntegerLimit","baseNode","identifiers","pipes: Pipes","pipes","constNode","maxNode","minNode","numberResolver","numberToNode","ctx: NumberResolverContext","additionalPropertiesNode","irSchemaToAst","baseNode","identifiers","objectResolver","shapeNode","objectToAst","ctx: ObjectResolverContext","baseNode","identifiers","constNode","formatNode","lengthNode","maxLengthNode","minLengthNode","patternNode","stringResolver","stringToNode","ctx: StringResolverContext","tupleToAst","result: Partial<Omit<Ast, 'typeName'>>","identifiers","irSchemaToAst","unknownToAst","undefinedToAst","identifiers","voidToAst","identifiers","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToNode","neverToAst","nullToAst","objectToAst","stringToNode","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","ast: Ast","query: SymbolMeta","ref","identifiers","irSchemaWithTypeToAst","handleComponent","handlerV1: ValibotPlugin['Handler']","handler: ValibotPlugin['Handler']","defaultConfig: ValibotPlugin['Config']","Api","defineConfig","defaultConfig","validatorResolver","ctx: ValidatorResolverContext","validatorResolver","ctx: ValidatorResolverContext","ctx: ValidatorResolverContext","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","path","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","unknownToAst","result: Partial<Omit<Ast, 'typeName'>>","arrayToAst","result: Partial<Omit<Ast, 'typeName'>>","unknownToAst","irSchemaToAst","intersectionExpression: ReturnType<typeof $.expr | typeof $.call>","checks: Array<ReturnType<typeof $.call>>","booleanToAst","result: Partial<Omit<Ast, 'typeName'>>","chain: ReturnType<typeof $.call>","enumToAst","result: Partial<Omit<Ast, 'typeName'>>","enumMembers: Array<ReturnType<typeof $.literal>>","literalMembers: Array<ReturnType<typeof $.call>>","unknownToAst","neverToAst","result: Partial<Omit<Ast, 'typeName'>>","nullToAst","result: Partial<Omit<Ast, 'typeName'>>","baseNode","constNode","maxNode","minNode","numberResolver","checks: Array<Chain>","numberToNode","ast: Partial<Omit<Ast, 'typeName'>>","ctx: NumberResolverContext","additionalPropertiesNode","irSchemaToAst","baseNode","objectResolver","shapeNode","objectToAst","ast: Partial<Omit<Ast, 'typeName'>>","ctx: ObjectResolverContext","baseNode","constNode","formatNode","lengthNode","maxLengthNode","minLengthNode","patternNode","stringResolver","checks: Array<Chain>","stringToNode","ctx: StringResolverContext","tupleToAst","result: Partial<Omit<Ast, 'typeName'>>","tupleElements","tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>>","irSchemaToAst","undefinedToAst","result: Partial<Omit<Ast, 'typeName'>>","voidToAst","result: Partial<Omit<Ast, 'typeName'>>","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToNode","neverToAst","nullToAst","objectToAst","stringToNode","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","ast: Partial<Ast>","query: SymbolMeta","irSchemaWithTypeToAst","schema","handleComponent","handlerMini: ZodPlugin['Handler']","unknownToAst","arrayToAst","arrayExpression: ReturnType<typeof $.call> | undefined","unknownToAst","irSchemaToAst","intersectionExpression: ReturnType<typeof $.call | typeof $.expr>","booleanToAst","chain: ReturnType<typeof $.call>","enumToAst","enumMembers: Array<ReturnType<typeof $.literal>>","literalMembers: Array<ReturnType<typeof $.call>>","unknownToAst","enumExpression: ReturnType<typeof $.call>","neverToAst","nullToAst","baseNode","constNode","maxNode","minNode","numberResolver","numberToNode","ast: Partial<Omit<Ast, 'typeName'>>","ctx: NumberResolverContext","additionalPropertiesNode","irSchemaToAst","baseNode","objectResolver","shapeNode","objectToAst","ast: Partial<Omit<Ast, 'typeName'>>","ctx: ObjectResolverContext","baseNode","constNode","formatNode","lengthNode","maxLengthNode","minLengthNode","patternNode","stringResolver","stringToNode","ctx: StringResolverContext","tupleToAst","tupleElements","tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>>","irSchemaToAst","undefinedToAst","voidToAst","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToNode","neverToAst","nullToAst","objectToAst","stringToNode","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","ast: Partial<Ast>","query: SymbolMeta","irSchemaWithTypeToAst","handleComponent","handlerV3: ZodPlugin['Handler']","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","intersectionExpression: ReturnType<typeof $.call | typeof $.expr>","result: Partial<Omit<Ast, 'typeName'>>","chain: ReturnType<typeof $.call>","result: Partial<Omit<Ast, 'typeName'>>","enumMembers: Array<ReturnType<typeof $.literal>>","literalMembers: Array<ReturnType<typeof $.call>>","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","baseNode","constNode","minNode","maxNode","ast: Partial<Omit<Ast, 'typeName'>>","ctx: NumberResolverContext","baseNode","ast: Partial<Omit<Ast, 'typeName'>>","ctx: ObjectResolverContext","constNode","baseNode","formatNode","lengthNode","minLengthNode","maxLengthNode","patternNode","ctx: StringResolverContext","result: Partial<Omit<Ast, 'typeName'>>","tupleElements","tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>>","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","ast: Partial<Ast>","query: SymbolMeta","schema","handlerV4: ZodPlugin['Handler']","handler: ZodPlugin['Handler']","defaultConfig: ZodPlugin['Config']","colors","fields","defaultValue","defaultPluginConfigs: {\n  [K in PluginNames]: Plugin.Config<PluginConfigMap[K]>;\n}","angularCommon","heyApiClientAngular","heyApiClientAxios","heyApiClientFetch","heyApiClientKy","heyApiClientNext","heyApiClientNuxt","heyApiClientOfetch","heyApiSchemas","heyApiSdk","heyApiTransformers","heyApiTypeScript","piniaColada","tanStackAngularQuery","tanStackReactQuery","tanStackSolidQuery","tanStackSvelteQuery","tanStackVueQuery","plugins: Config['plugins']","context: PluginContext","userPlugin","defaultConfig","defaultPlugin","userPluginsConfig: Config['plugins']","definedPlugins: UserConfig['plugins']","configs: Array<UserConfig>","dependencies: Record<string, string>","configurationFile: string | undefined","colors","results: Array<ArrayOnly<ConfigResult>>","errors: Array<Error>","path","plugins: Pick<Config, 'plugins' | 'pluginOrder'>","config: Config","joinedValues","values: string[]","search: string[]","entries: Array<[string, string]>","arrayBuffer: ArrayBuffer | undefined","hasChanged: boolean | undefined","response: Response | undefined","declIndex: Map<string, number>","walkDeclarations: WalkFn","walkTopological: WalkFn","order: Array<string>","getGroup: GetPointerPriorityFn","walk: WalkFn","matchIrPointerToGroup: MatchPointerToGroupFn<IrTopLevelKind>","patterns: Record<IrTopLevelKind, RegExp>","kind","kindPriority: KindPriority","partial: Partial<KindPriority>","getIrPointerPriority: GetPointerPriorityFn","defaultGetKind: Required<Required<Hooks>['operations']>['getKind']","callback: (event: WalkEvent<TKind>) => void","events: ReadonlyArray<TKind>","options: WalkOptions<TKind>","event: WalkEvent | undefined","baseEvent: BaseEvent","symbolIn: SymbolIn","path","result: EventHooks","Project","result: string","path","namespace","keys: Array<string>","regexps: Array<RegExp>","path","regexp","filters: Filters","dependencies: Set<string> | undefined","resourceMetadata: ResourceMetadata","path","namespace","path","walkSchemas","path","rootEnums: Record<string, unknown>","rootEnumSignatures: Record<string, string>","inlineEnums: Array<{\n    key: string | number | null;\n    node: unknown;\n    parent: unknown;\n    path: ReadonlyArray<string | number>;\n    signature: string;\n  }>","signatureToName: Record<string, string | undefined>","signatureToSchema: Record<string, unknown>","path","childResult: Partial<PointerDependenciesResult>","worklist: Set<string>","graph: Graph","walk","path","deprecated: boolean | undefined","tags: Set<string> | undefined","cache: Cache","path","originals: OriginalSchemas","split: SplitSchemas","deepEqual","walk","source","path","colors","filterSpec","filtered: typeof spec.definitions","source","path","contentToSchema","mediaTypeObjects","objects: Array<Content>","values: Array<string>","getSchemaType","parseSchemaJsDoc","parseSchemaMeta","parseArray","schemaItems: Array<IR.SchemaObject>","schemaToIrSchema","parseBoolean","parseNumber","parseObject","schemaProperties: Record<string, IR.SchemaObject>","parseString","parseExtensions","source","initIrSchema","irSchema: IR.SchemaObject","parseAllOf","ref","valueSchemas: ReadonlyArray<IR.SchemaObject>","irDiscriminatorSchema: IR.SchemaObject","parseOneType","nestedItems: Array<IR.SchemaObject>","parseEnum","enumType: SchemaType<SchemaObject> | 'null' | undefined","parseRef","irSchema","parseNullableType","typeIrSchema: IR.SchemaObject","parseType","parseUnknown","parseSchema","isPaginationType","paginationField","ref","name","getSchemaType","parseOperationJsDoc","initIrOperation","irOperation: IR.OperationObject","operationToIrOperation","requestBodyObject: IRBodyObject","requestBodyObjectRequired: Array<string>","schema: SchemaObject","mediaTypeObjects","content","paginationField","schemaToIrSchema","contentToSchema","securitySchemeObjects: Map<string, IR.SecurityObject>","irSecuritySchemeObject: IR.SecurityObject | undefined","parsePathOperation","path","defaultExplode","defaultStyle","parametersArrayToObject","parametersObject: IR.ParametersObject","parameterToIrParameter","finalSchema: SchemaObject","paginationField","irParameter: IR.ParameterObject","schemaToIrSchema","parseServers","schemes: ReadonlyArray<string>","path","validateOpenApiSpec","issues: Array<ValidatorIssue>","path","validateOpenApiSpec","state: State","path","commonOperation: OperationObject","operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method'\n    >","parametersArrayToObject","filterSpec","filtered: typeof spec.components.parameters","source","filtered: typeof spec.components.requestBodies","filtered: typeof spec.components.responses","filtered: typeof spec.components.schemas","path","contentToSchema","mediaTypeObjects","objects: Array<Content>","findDiscriminatorsInSchema","resolvedSchema: SchemaObject","getAllDiscriminatorValues","values: Array<string>","parseSchemaJsDoc","parseSchemaMeta","parseArray","schemaItems: Array<IR.SchemaObject>","schemaToIrSchema","parseBoolean","parseNumber","parseObject","schemaProperties: Record<string, IR.SchemaObject>","parseString","parseExtensions","source","initIrSchema","irSchema: IR.SchemaObject","parseAllOf","discriminatorsToAdd: Array<DiscriminatorInfo>","ref","valueSchemas: ReadonlyArray<IR.SchemaObject>","discriminatorProperty: IR.SchemaObject","inlineSchema: IR.SchemaObject | undefined","irDiscriminatorSchema: IR.SchemaObject","parseOneType","nestedItems: Array<IR.SchemaObject>","parseAnyOf","parseEnum","enumType: SchemaType<SchemaObject> | 'null' | undefined","parseOneOf","parseRef","irSchema","typeIrSchema: IR.SchemaObject","parseType","parseUnknown","parseSchema","isPaginationType","paginationField","ref","refSchema: SchemaObject | ReferenceObject | undefined","mediaTypeObjects","content","name","parseOperationJsDoc","initIrOperation","irOperation: IR.OperationObject","operationToIrOperation","mediaTypeObjects","content","paginationField","schemaToIrSchema","contentToSchema","securitySchemeObjects: Map<string, IR.SecurityObject>","parsePathOperation","path","defaultAllowReserved","defaultExplode","defaultStyle","parametersArrayToObject","parametersObject: IR.ParametersObject","parameterToIrParameter","mediaTypeObjects","content","finalSchema: SchemaObject","paginationField","irParameter: IR.ParameterObject","schemaToIrSchema","parseParameter","requestBodyToIrRequestBody","mediaTypeObjects","content","irRequestBody: IR.RequestBodyObject","schemaToIrSchema","parseRequestBody","parseServers","validateOpenApiSpec","issues: Array<ValidatorIssue>","path","validateOpenApiSpec","state: State","path","operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method' | 'operation'\n    > & {\n      operation: Omit<\n        Parameters<typeof parsePathOperation>[0]['operation'],\n        'responses'\n      >;\n    }","parametersArrayToObject","filtered: typeof spec.components.parameters","source","filtered: typeof spec.components.requestBodies","filtered: typeof spec.components.responses","filtered: typeof spec.components.schemas","path","objects: Array<Content>","resolvedSchema: SchemaObject","values: Array<string>","schemaItems: Array<IR.SchemaObject>","schemaProperties: Record<string, IR.SchemaObject>","patternProperties: Record<string, IR.SchemaObject>","source","irSchema: IR.SchemaObject","discriminatorsToAdd: Array<DiscriminatorInfo>","ref","valueSchemas: ReadonlyArray<IR.SchemaObject>","discriminatorProperty: IR.SchemaObject","inlineSchema: IR.SchemaObject | undefined","irDiscriminatorSchema: IR.SchemaObject","nestedItems: Array<IR.SchemaObject>","enumType: SchemaType<SchemaObject> | undefined","irSchema","irRefSchema: IR.SchemaObject","typeIrSchema: IR.SchemaObject","ref","refSchema: SchemaObject | undefined","content","name","schema","irOperation: IR.OperationObject","content","securitySchemeObjects: Map<string, IR.SecurityObject>","path","parametersObject: IR.ParametersObject","content","finalSchema: SchemaObject","irParameter: IR.ParameterObject","content","irRequestBody: IR.RequestBodyObject","issues: Array<ValidatorIssue>","path","state: Parameters<typeof parseWebhookOperation>[0]['state']","operationArgs: Omit<\n      Parameters<typeof parseWebhookOperation>[0],\n      'method'\n    >","state: State","path","operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method'\n    >"],"sources":["../src/generate/tsConfig.ts","../src/generate/utils.ts","../src/error.ts","../src/utils/input/heyApi.ts","../src/utils/input/readme.ts","../src/utils/input/scalar.ts","../src/utils/input/index.ts","../src/config/input.ts","../src/config/logs.ts","../src/config/merge.ts","../src/config/utils/config.ts","../src/config/output.ts","../src/config/packages.ts","../src/config/parser.ts","../src/plugins/shared/utils/config.ts","../src/plugins/@angular/common/httpRequests/config.ts","../src/openApi/shared/locations/operation.ts","../src/plugins/@angular/common/httpRequests/resolve.ts","../src/plugins/@angular/common/httpResources/config.ts","../src/plugins/@angular/common/httpResources/resolve.ts","../src/plugins/@hey-api/client-core/utils.ts","../src/ir/parameter.ts","../src/ir/schema.ts","../src/ir/utils.ts","../src/ir/operation.ts","../src/ts-dsl/base.ts","../src/ts-dsl/expr/id.ts","../src/ts-dsl/layout/newline.ts","../src/ts-dsl/mixins/args.ts","../src/ts-dsl/expr/prefix.ts","../src/ts-dsl/utils/factories.ts","../src/ts-dsl/mixins/as.ts","../src/ts-dsl/expr/literal.ts","../src/ts-dsl/utils/regexp.ts","../src/ts-dsl/utils/keywords.ts","../src/ts-dsl/utils/reserved.ts","../src/ts-dsl/utils/name.ts","../src/ts-dsl/decl/decorator.ts","../src/ts-dsl/mixins/decorator.ts","../src/ts-dsl/utils/context.ts","../src/ts-dsl/layout/doc.ts","../src/ts-dsl/mixins/doc.ts","../src/ts-dsl/mixins/modifiers.ts","../src/ts-dsl/type/param.ts","../src/ts-dsl/mixins/type-params.ts","../src/ts-dsl/mixins/optional.ts","../src/ts-dsl/mixins/value.ts","../src/ts-dsl/token.ts","../src/ts-dsl/mixins/type-args.ts","../src/ts-dsl/mixins/type-expr.ts","../src/ts-dsl/type/attr.ts","../src/ts-dsl/type/expr.ts","../src/ts-dsl/decl/field.ts","../src/ts-dsl/stmt/stmt.ts","../src/ts-dsl/mixins/do.ts","../src/ts-dsl/decl/pattern.ts","../src/ts-dsl/mixins/pattern.ts","../src/ts-dsl/decl/param.ts","../src/ts-dsl/mixins/param.ts","../src/ts-dsl/mixins/layout.ts","../src/ts-dsl/stmt/block.ts","../src/ts-dsl/decl/init.ts","../src/ts-dsl/mixins/type-returns.ts","../src/ts-dsl/decl/method.ts","../src/ts-dsl/decl/class.ts","../src/ts-dsl/decl/member.ts","../src/ts-dsl/decl/enum.ts","../src/ts-dsl/decl/func.ts","../src/ts-dsl/decl/getter.ts","../src/ts-dsl/decl/setter.ts","../src/ts-dsl/expr/array.ts","../src/ts-dsl/mixins/expr.ts","../src/ts-dsl/expr/as.ts","../src/ts-dsl/expr/binary.ts","../src/ts-dsl/mixins/operator.ts","../src/ts-dsl/expr/attr.ts","../src/ts-dsl/expr/await.ts","../src/ts-dsl/expr/call.ts","../src/ts-dsl/expr/expr.ts","../src/ts-dsl/layout/hint.ts","../src/ts-dsl/mixins/hint.ts","../src/ts-dsl/expr/prop.ts","../src/ts-dsl/expr/object.ts","../src/ts-dsl/expr/fromValue.ts","../src/ts-dsl/expr/new.ts","../src/ts-dsl/expr/regexp.ts","../src/ts-dsl/expr/template.ts","../src/ts-dsl/expr/ternary.ts","../src/ts-dsl/expr/typeof.ts","../src/ts-dsl/layout/note.ts","../src/ts-dsl/stmt/if.ts","../src/ts-dsl/stmt/return.ts","../src/ts-dsl/stmt/throw.ts","../src/ts-dsl/stmt/try.ts","../src/ts-dsl/stmt/var.ts","../src/ts-dsl/type/alias.ts","../src/ts-dsl/type/and.ts","../src/ts-dsl/type/literal.ts","../src/ts-dsl/type/idx-sig.ts","../src/ts-dsl/type/prop.ts","../src/ts-dsl/type/object.ts","../src/ts-dsl/type/tuple.ts","../src/ts-dsl/type/fromValue.ts","../src/ts-dsl/type/func.ts","../src/ts-dsl/type/idx.ts","../src/ts-dsl/type/mapped.ts","../src/ts-dsl/type/operator.ts","../src/ts-dsl/type/or.ts","../src/ts-dsl/type/query.ts","../src/ts-dsl/type/template.ts","../src/ts-dsl/utils/lazy.ts","../src/ts-dsl/utils/render-utils.ts","../src/ts-dsl/utils/render.ts","../src/ts-dsl/index.ts","../src/utils/naming/naming.ts","../src/plugins/@hey-api/sdk/shared/class.ts","../src/plugins/@hey-api/sdk/shared/constants.ts","../src/plugins/@hey-api/sdk/shared/auth.ts","../src/utils/ref.ts","../src/plugins/@hey-api/sdk/shared/signature.ts","../src/plugins/@hey-api/sdk/shared/validator.ts","../src/plugins/@hey-api/sdk/shared/operation.ts","../src/plugins/@hey-api/sdk/v1/node.ts","../src/utils/escape.ts","../src/plugins/shared/utils/operation.ts","../src/plugins/@angular/common/shared/node.ts","../src/plugins/@angular/common/plugin.ts","../src/plugins/@angular/common/config.ts","../src/plugins/@hey-api/client-core/config.ts","../src/generate/client.ts","../src/utils/url.ts","../src/plugins/@hey-api/client-core/client.ts","../src/plugins/@hey-api/client-core/createClientConfig.ts","../src/plugins/@hey-api/client-core/plugin.ts","../src/plugins/@hey-api/client-angular/config.ts","../src/plugins/@hey-api/client-axios/config.ts","../src/plugins/@hey-api/client-fetch/config.ts","../src/plugins/@hey-api/client-ky/config.ts","../src/plugins/@hey-api/client-next/config.ts","../src/plugins/@hey-api/client-nuxt/config.ts","../src/plugins/@hey-api/client-ofetch/config.ts","../src/config/utils/package.ts","../src/plugins/@hey-api/schemas/plugin.ts","../src/plugins/@hey-api/schemas/config.ts","../src/plugins/@hey-api/sdk/operations/config.ts","../src/plugins/@hey-api/sdk/operations/resolve.ts","../src/plugins/@hey-api/sdk/shared/typeOptions.ts","../src/plugins/@hey-api/sdk/v1/plugin.ts","../src/plugins/@hey-api/sdk/plugin.ts","../src/plugins/@hey-api/sdk/config.ts","../src/plugins/@hey-api/transformers/expressions.ts","../src/plugins/@hey-api/transformers/plugin.ts","../src/plugins/@hey-api/transformers/config.ts","../src/plugins/@hey-api/typescript/shared/clientOptions.ts","../src/plugins/shared/utils/schema.ts","../src/plugins/@hey-api/typescript/shared/export.ts","../src/plugins/@hey-api/typescript/shared/operation.ts","../src/plugins/@hey-api/typescript/shared/webhook.ts","../src/plugins/@hey-api/typescript/v1/toAst/array.ts","../src/plugins/@hey-api/typescript/v1/toAst/boolean.ts","../src/plugins/@hey-api/typescript/v1/toAst/enum.ts","../src/plugins/@hey-api/typescript/v1/toAst/never.ts","../src/plugins/@hey-api/typescript/v1/toAst/null.ts","../src/plugins/@hey-api/typescript/v1/toAst/number.ts","../src/plugins/@hey-api/typescript/v1/toAst/object.ts","../src/plugins/@hey-api/typescript/v1/toAst/string.ts","../src/plugins/@hey-api/typescript/v1/toAst/tuple.ts","../src/plugins/@hey-api/typescript/v1/toAst/undefined.ts","../src/plugins/@hey-api/typescript/v1/toAst/unknown.ts","../src/plugins/@hey-api/typescript/v1/toAst/void.ts","../src/plugins/@hey-api/typescript/v1/toAst/index.ts","../src/plugins/@hey-api/typescript/v1/plugin.ts","../src/plugins/@hey-api/typescript/api.ts","../src/plugins/@hey-api/typescript/plugin.ts","../src/plugins/@hey-api/typescript/config.ts","../src/plugins/@pinia/colada/meta.ts","../src/plugins/@pinia/colada/useType.ts","../src/plugins/@pinia/colada/utils.ts","../src/plugins/@pinia/colada/mutationOptions.ts","../src/plugins/@pinia/colada/queryKey.ts","../src/plugins/@pinia/colada/queryOptions.ts","../src/plugins/@pinia/colada/v0/plugin.ts","../src/plugins/@pinia/colada/plugin.ts","../src/plugins/@pinia/colada/config.ts","../src/plugins/@tanstack/query-core/shared/useType.ts","../src/plugins/@tanstack/query-core/queryKey.ts","../src/plugins/@tanstack/query-core/shared/meta.ts","../src/plugins/@tanstack/query-core/v5/infiniteQueryOptions.ts","../src/plugins/@tanstack/query-core/v5/mutationOptions.ts","../src/plugins/@tanstack/query-core/v5/queryOptions.ts","../src/plugins/@tanstack/query-core/v5/useQuery.ts","../src/plugins/@tanstack/query-core/v5/plugin.ts","../src/plugins/@tanstack/query-core/plugin.ts","../src/plugins/@tanstack/angular-query-experimental/config.ts","../src/plugins/@tanstack/react-query/config.ts","../src/plugins/@tanstack/solid-query/config.ts","../src/plugins/@tanstack/svelte-query/config.ts","../src/plugins/@tanstack/vue-query/config.ts","../src/plugins/arktype/v2/api.ts","../src/plugins/arktype/api.ts","../src/plugins/arktype/constants.ts","../src/plugins/arktype/shared/export.ts","../src/plugins/arktype/v2/toAst/null.ts","../src/plugins/arktype/v2/toAst/object.ts","../src/plugins/arktype/v2/toAst/string.ts","../src/plugins/arktype/v2/toAst/index.ts","../src/plugins/arktype/v2/plugin.ts","../src/plugins/arktype/plugin.ts","../src/plugins/arktype/config.ts","../src/plugins/fastify/plugin.ts","../src/plugins/fastify/config.ts","../src/plugins/swr/v2/useSwr.ts","../src/plugins/swr/v2/plugin.ts","../src/plugins/swr/plugin.ts","../src/plugins/swr/config.ts","../src/plugins/valibot/v1/constants.ts","../src/plugins/valibot/shared/pipes.ts","../src/plugins/valibot/v1/api.ts","../src/plugins/valibot/api.ts","../src/plugins/shared/utils/coerce.ts","../src/plugins/valibot/shared/export.ts","../src/plugins/valibot/shared/operation.ts","../src/plugins/valibot/shared/webhook.ts","../src/plugins/valibot/v1/toAst/unknown.ts","../src/plugins/valibot/v1/toAst/array.ts","../src/plugins/valibot/v1/toAst/boolean.ts","../src/plugins/valibot/v1/toAst/enum.ts","../src/plugins/valibot/v1/toAst/never.ts","../src/plugins/valibot/v1/toAst/null.ts","../src/plugins/shared/utils/formats.ts","../src/plugins/valibot/v1/toAst/number.ts","../src/plugins/valibot/v1/toAst/object.ts","../src/plugins/valibot/v1/toAst/string.ts","../src/plugins/valibot/v1/toAst/tuple.ts","../src/plugins/valibot/v1/toAst/undefined.ts","../src/plugins/valibot/v1/toAst/void.ts","../src/plugins/valibot/v1/toAst/index.ts","../src/plugins/valibot/v1/plugin.ts","../src/plugins/valibot/plugin.ts","../src/plugins/valibot/config.ts","../src/plugins/zod/constants.ts","../src/plugins/zod/mini/api.ts","../src/plugins/zod/v3/api.ts","../src/plugins/zod/v4/api.ts","../src/plugins/zod/api.ts","../src/plugins/zod/shared/export.ts","../src/plugins/zod/shared/module.ts","../src/plugins/zod/shared/operation.ts","../src/plugins/zod/shared/webhook.ts","../src/plugins/zod/mini/toAst/unknown.ts","../src/plugins/zod/mini/toAst/array.ts","../src/plugins/zod/mini/toAst/boolean.ts","../src/plugins/zod/mini/toAst/enum.ts","../src/plugins/zod/mini/toAst/never.ts","../src/plugins/zod/mini/toAst/null.ts","../src/plugins/zod/mini/toAst/number.ts","../src/plugins/zod/mini/toAst/object.ts","../src/plugins/zod/mini/toAst/string.ts","../src/plugins/zod/mini/toAst/tuple.ts","../src/plugins/zod/mini/toAst/undefined.ts","../src/plugins/zod/mini/toAst/void.ts","../src/plugins/zod/mini/toAst/index.ts","../src/plugins/zod/mini/plugin.ts","../src/plugins/zod/v3/toAst/unknown.ts","../src/plugins/zod/v3/toAst/array.ts","../src/plugins/zod/v3/toAst/boolean.ts","../src/plugins/zod/v3/toAst/enum.ts","../src/plugins/zod/v3/toAst/never.ts","../src/plugins/zod/v3/toAst/null.ts","../src/plugins/zod/v3/toAst/number.ts","../src/plugins/zod/v3/toAst/object.ts","../src/plugins/zod/v3/toAst/string.ts","../src/plugins/zod/v3/toAst/tuple.ts","../src/plugins/zod/v3/toAst/undefined.ts","../src/plugins/zod/v3/toAst/void.ts","../src/plugins/zod/v3/toAst/index.ts","../src/plugins/zod/v3/plugin.ts","../src/plugins/zod/v4/toAst/unknown.ts","../src/plugins/zod/v4/toAst/array.ts","../src/plugins/zod/v4/toAst/boolean.ts","../src/plugins/zod/v4/toAst/enum.ts","../src/plugins/zod/v4/toAst/never.ts","../src/plugins/zod/v4/toAst/null.ts","../src/plugins/zod/v4/toAst/number.ts","../src/plugins/zod/v4/toAst/object.ts","../src/plugins/zod/v4/toAst/string.ts","../src/plugins/zod/v4/toAst/tuple.ts","../src/plugins/zod/v4/toAst/undefined.ts","../src/plugins/zod/v4/toAst/void.ts","../src/plugins/zod/v4/toAst/index.ts","../src/plugins/zod/v4/plugin.ts","../src/plugins/zod/plugin.ts","../src/plugins/zod/config.ts","../src/plugins/config.ts","../src/config/plugins.ts","../src/config/init.ts","../src/plugins/@hey-api/client-core/bundle/params.ts","../src/plugins/@hey-api/client-core/bundle/pathSerializer.ts","../src/plugins/@hey-api/client-fetch/bundle/utils.ts","../src/getSpec.ts","../src/utils/minHeap.ts","../src/graph/walk.ts","../src/ir/graph.ts","../src/plugins/shared/utils/instance.ts","../src/ir/context.ts","../src/openApi/shared/utils/operation.ts","../src/openApi/shared/utils/filter.ts","../src/openApi/shared/graph/meta.ts","../src/openApi/shared/utils/schema.ts","../src/openApi/shared/utils/schemaChildRelationships.ts","../src/openApi/shared/utils/transforms.ts","../src/openApi/shared/transforms/utils.ts","../src/openApi/shared/transforms/enums.ts","../src/openApi/shared/transforms/propertiesRequiredByDefault.ts","../src/openApi/shared/utils/deepEqual.ts","../src/openApi/shared/utils/graph.ts","../src/openApi/shared/transforms/readWrite.ts","../src/openApi/shared/transforms/index.ts","../src/openApi/shared/utils/parameter.ts","../src/openApi/shared/utils/validator.ts","../src/openApi/2.0.x/parser/filter.ts","../src/ir/mediaType.ts","../src/openApi/2.0.x/parser/mediaType.ts","../src/ir/pagination.ts","../src/openApi/shared/utils/discriminator.ts","../src/openApi/2.0.x/parser/schema.ts","../src/openApi/2.0.x/parser/pagination.ts","../src/openApi/2.0.x/parser/operation.ts","../src/openApi/2.0.x/parser/parameter.ts","../src/openApi/2.0.x/parser/server.ts","../src/openApi/2.0.x/parser/validate.ts","../src/openApi/2.0.x/parser/index.ts","../src/openApi/3.0.x/parser/filter.ts","../src/openApi/3.0.x/parser/mediaType.ts","../src/openApi/3.0.x/parser/schema.ts","../src/openApi/3.0.x/parser/pagination.ts","../src/openApi/3.0.x/parser/operation.ts","../src/openApi/3.0.x/parser/parameter.ts","../src/openApi/3.0.x/parser/requestBody.ts","../src/openApi/3.0.x/parser/server.ts","../src/openApi/3.0.x/parser/validate.ts","../src/openApi/3.0.x/parser/index.ts","../src/openApi/3.1.x/parser/filter.ts","../src/openApi/3.1.x/parser/mediaType.ts","../src/openApi/3.1.x/parser/schema.ts","../src/openApi/3.1.x/parser/pagination.ts","../src/openApi/3.1.x/parser/operation.ts","../src/openApi/3.1.x/parser/parameter.ts","../src/openApi/3.1.x/parser/requestBody.ts","../src/openApi/3.1.x/parser/server.ts","../src/openApi/3.1.x/parser/validate.ts","../src/openApi/3.1.x/parser/webhook.ts","../src/openApi/3.1.x/parser/index.ts","../src/openApi/index.ts"],"sourcesContent":["import fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nimport ts from 'typescript';\n\nimport type { UserOutput } from '~/types/output';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nexport const findPackageJson = (): unknown | undefined => {\n  let dir = __dirname;\n  while (dir !== path.dirname(dir)) {\n    const files = fs.readdirSync(dir);\n    const candidates = files.filter((file) => file === 'package.json');\n\n    if (candidates[0]) {\n      const packageJsonPath = path.join(dir, candidates[0]);\n      return JSON.parse(\n        fs.readFileSync(packageJsonPath, {\n          encoding: 'utf8',\n        }),\n      );\n    }\n\n    dir = path.dirname(dir);\n  }\n\n  return;\n};\n\nexport const loadPackageJson = () => {\n  const packageJson = findPackageJson();\n\n  const safePackage = {\n    bugs: {\n      url: '',\n    },\n    name: '',\n    version: '',\n  };\n\n  if (packageJson && typeof packageJson === 'object') {\n    if ('name' in packageJson && typeof packageJson.name === 'string') {\n      safePackage.name = packageJson.name;\n    }\n\n    if ('version' in packageJson && typeof packageJson.version === 'string') {\n      safePackage.version = packageJson.version;\n    }\n\n    if (\n      'bugs' in packageJson &&\n      packageJson.bugs &&\n      typeof packageJson.bugs === 'object'\n    ) {\n      if (\n        'url' in packageJson.bugs &&\n        typeof packageJson.bugs.url === 'string'\n      ) {\n        safePackage.bugs.url = packageJson.bugs.url;\n        if (safePackage.bugs.url && !safePackage.bugs.url.endsWith('/')) {\n          safePackage.bugs.url += '/';\n        }\n      }\n    }\n  }\n\n  return safePackage;\n};\n\nexport const findTsConfigPath = (\n  tsConfigPath?: UserOutput['tsConfigPath'],\n): string | null => {\n  if (tsConfigPath === null) {\n    return null;\n  }\n\n  if (tsConfigPath) {\n    const resolved = path.isAbsolute(tsConfigPath)\n      ? tsConfigPath\n      : path.resolve(__dirname, tsConfigPath);\n    return fs.existsSync(resolved) ? resolved : null;\n  }\n\n  let dir = __dirname;\n  while (dir !== path.dirname(dir)) {\n    const files = fs.readdirSync(dir);\n    const candidates = files\n      .filter((file) => file.startsWith('tsconfig') && file.endsWith('.json'))\n      .sort((file) => (file === 'tsconfig.json' ? -1 : 1));\n\n    if (candidates[0]) {\n      return path.join(dir, candidates[0]);\n    }\n\n    dir = path.dirname(dir);\n  }\n\n  return null;\n};\n\nexport const loadTsConfig = (\n  configPath: string | null,\n): ts.ParsedCommandLine | null => {\n  if (!configPath) {\n    return null;\n  }\n\n  const raw = ts.readConfigFile(configPath, ts.sys.readFile);\n\n  if (raw.error) {\n    throw new Error(`Couldn't read tsconfig from path: ${configPath}`);\n  }\n\n  return ts.parseJsonConfigFileContent(\n    raw.config,\n    ts.sys,\n    path.dirname(configPath),\n  );\n};\n","import type { PathLike } from 'node:fs';\nimport fs from 'node:fs';\n\nexport const ensureDirSync = (path: PathLike) => {\n  if (!fs.existsSync(path)) {\n    fs.mkdirSync(path, { recursive: true });\n  }\n};\n","import fs from 'node:fs';\nimport path from 'node:path';\n\nimport colors from 'ansi-colors';\n\nimport { loadPackageJson } from '~/generate/tsConfig';\nimport { ensureDirSync } from '~/generate/utils';\n\ntype IJobError = {\n  error: Error;\n  jobIndex: number;\n};\n\n/**\n * Represents a single configuration error.\n *\n * Used for reporting issues with a specific config instance.\n */\nexport class ConfigError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ConfigError';\n  }\n}\n\n/**\n * Aggregates multiple config errors with their job indices for reporting.\n */\nexport class ConfigValidationError extends Error {\n  readonly errors: ReadonlyArray<IJobError>;\n\n  constructor(errors: Array<IJobError>) {\n    super(\n      `Found ${errors.length} configuration ${errors.length === 1 ? 'error' : 'errors'}.`,\n    );\n    this.name = 'ConfigValidationError';\n    this.errors = errors;\n  }\n}\n\n/**\n * Represents a runtime error originating from a specific job.\n *\n * Used for reporting job-level failures that are not config validation errors.\n */\nexport class JobError extends Error {\n  readonly originalError: IJobError;\n\n  constructor(message: string, error: IJobError) {\n    super(message);\n    this.name = 'JobError';\n    this.originalError = error;\n  }\n}\n\nexport class HeyApiError extends Error {\n  args: ReadonlyArray<unknown>;\n  event: string;\n  pluginName: string;\n\n  constructor({\n    args,\n    error,\n    event,\n    name,\n    pluginName,\n  }: {\n    args: unknown[];\n    error: Error;\n    event: string;\n    name: string;\n    pluginName: string;\n  }) {\n    const message = error instanceof Error ? error.message : 'Unknown error';\n    super(message);\n\n    this.args = args;\n    this.cause = error.cause;\n    this.event = event;\n    this.name = name || error.name;\n    this.pluginName = pluginName;\n    this.stack = error.stack;\n  }\n}\n\nexport const logCrashReport = (\n  error: unknown,\n  logsDir: string,\n): string | undefined => {\n  if (error instanceof ConfigError || error instanceof ConfigValidationError) {\n    return;\n  }\n\n  if (error instanceof JobError) {\n    error = error.originalError.error;\n  }\n\n  const logName = `openapi-ts-error-${Date.now()}.log`;\n  const fullDir = path.resolve(process.cwd(), logsDir);\n  ensureDirSync(fullDir);\n  const logPath = path.resolve(fullDir, logName);\n\n  let logContent = `[${new Date().toISOString()}] `;\n\n  if (error instanceof HeyApiError) {\n    logContent += `${error.name} during event \"${error.event}\"\\n`;\n    if (error.pluginName) {\n      logContent += `Plugin: ${error.pluginName}\\n`;\n    }\n    logContent += `Arguments: ${JSON.stringify(error.args, null, 2)}\\n\\n`;\n  }\n\n  const message = error instanceof Error ? error.message : String(error);\n  const stack = error instanceof Error ? error.stack : undefined;\n\n  logContent += `Error: ${message}\\n`;\n  if (stack) {\n    logContent += `Stack:\\n${stack}\\n`;\n  }\n\n  fs.writeFileSync(logPath, logContent);\n\n  return logPath;\n};\n\nexport const openGitHubIssueWithCrashReport = async (error: unknown) => {\n  const packageJson = loadPackageJson();\n  if (!packageJson.bugs.url) return;\n\n  if (error instanceof JobError) {\n    error = error.originalError.error;\n  }\n\n  let body = '';\n\n  if (error instanceof HeyApiError) {\n    if (error.pluginName) {\n      body += `**Plugin**: \\`${error.pluginName}\\`\\n`;\n    }\n    body += `**Event**: \\`${error.event}\\`\\n`;\n    body += `**Arguments**:\\n\\`\\`\\`ts\\n${JSON.stringify(error.args, null, 2)}\\n\\`\\`\\`\\n\\n`;\n  }\n\n  const message = error instanceof Error ? error.message : String(error);\n  const stack = error instanceof Error ? error.stack : undefined;\n\n  body += `**Error**: \\`${message}\\`\\n`;\n  if (stack) {\n    body += `\\n**Stack Trace**:\\n\\`\\`\\`\\n${stack}\\n\\`\\`\\``;\n  }\n\n  const search = new URLSearchParams({\n    body,\n    labels: 'bug üî•',\n    title: 'Crash Report',\n  });\n  const url = `${packageJson.bugs.url}new?${search.toString()}`;\n  const open = (await import('open')).default;\n  await open(url);\n};\n\nexport const printCrashReport = ({\n  error,\n  logPath,\n}: {\n  error: unknown;\n  logPath: string | undefined;\n}) => {\n  if (error instanceof ConfigValidationError && error.errors.length) {\n    const groupByJob = new Map<number, Array<Error>>();\n    for (const { error: err, jobIndex } of error.errors) {\n      if (!groupByJob.has(jobIndex)) {\n        groupByJob.set(jobIndex, []);\n      }\n      groupByJob.get(jobIndex)!.push(err);\n    }\n\n    for (const [jobIndex, errors] of groupByJob.entries()) {\n      const jobPrefix = colors.gray(`[Job ${jobIndex + 1}] `);\n      const count = errors.length;\n      const baseString = colors.red(\n        `Found ${count} configuration ${count === 1 ? 'error' : 'errors'}:`,\n      );\n      console.error(`${jobPrefix}‚ùóÔ∏è ${baseString}`);\n      errors.forEach((err, index) => {\n        const itemPrefixStr = `  [${index + 1}] `;\n        const itemPrefix = colors.red(itemPrefixStr);\n        console.error(`${jobPrefix}${itemPrefix}${colors.white(err.message)}`);\n      });\n    }\n  } else {\n    let jobPrefix = colors.gray('[root] ');\n    if (error instanceof JobError) {\n      jobPrefix = colors.gray(`[Job ${error.originalError.jobIndex + 1}] `);\n      error = error.originalError.error;\n    }\n\n    const baseString = colors.red('Failed with the message:');\n    console.error(`${jobPrefix}‚ùå ${baseString}`);\n    const itemPrefixStr = `  `;\n    const itemPrefix = colors.red(itemPrefixStr);\n    console.error(\n      `${jobPrefix}${itemPrefix}${typeof error === 'string' ? error : error instanceof Error ? error.message : 'Unknown error'}`,\n    );\n  }\n\n  if (logPath) {\n    const jobPrefix = colors.gray('[root] ');\n    console.error(\n      `${jobPrefix}${colors.cyan('üìÑ Crash log saved to:')} ${colors.gray(logPath)}`,\n    );\n  }\n};\n\nexport const shouldReportCrash = async ({\n  error,\n  isInteractive,\n}: {\n  error: unknown;\n  isInteractive: boolean | undefined;\n}): Promise<boolean> => {\n  if (\n    !isInteractive ||\n    error instanceof ConfigError ||\n    error instanceof ConfigValidationError\n  ) {\n    return false;\n  }\n\n  return new Promise((resolve) => {\n    const jobPrefix = colors.gray('[root] ');\n    console.log(\n      `${jobPrefix}${colors.yellow('üì¢ Open a GitHub issue with crash details? (y/N):')}`,\n    );\n    process.stdin.setEncoding('utf8');\n    process.stdin.once('data', (data: string) => {\n      resolve(data.trim().toLowerCase() === 'y');\n    });\n  });\n};\n","import type { Input } from '~/types/input';\n\n// Regular expression to match Hey API Registry input formats:\n//   - {organization}/{project}?{queryParams}\nconst registryRegExp = /^([\\w-]+)\\/([\\w-]+)(?:\\?([\\w=&.-]*))?$/;\n\nexport const heyApiRegistryBaseUrl = 'https://get.heyapi.dev';\n\n/**\n * Creates a full Hey API Registry URL.\n *\n * @param organization - Hey API organization slug\n * @param project - Hey API project slug\n * @param queryParams - Optional query parameters\n * @returns The full Hey API registry URL.\n */\nexport const getRegistryUrl = (\n  organization: string,\n  project: string,\n  queryParams?: string,\n): string =>\n  `${heyApiRegistryBaseUrl}/${organization}/${project}${queryParams ? `?${queryParams}` : ''}`;\n\nexport interface Parsed {\n  organization: string;\n  project: string;\n  queryParams?: string;\n}\n\n/**\n * Parses a Hey API input string and extracts components.\n *\n * @param input - Hey API configuration input\n * @returns Parsed Hey API input components\n * @throws Error if the input format is invalid\n */\nexport const parseShorthand = (\n  input: Input & {\n    path: string;\n  },\n): Parsed => {\n  let organization = input.organization;\n  let project = input.project;\n  let queryParams: string | undefined;\n\n  if (input.path) {\n    const match = input.path.match(registryRegExp);\n\n    if (!match) {\n      throw new Error(\n        `Invalid Hey API shorthand format. Expected \"organization/project?queryParams\" or \"organization/project\", received: ${input.path}`,\n      );\n    }\n\n    organization = match[1];\n    project = match[2];\n    queryParams = match[3];\n  }\n\n  if (!organization) {\n    throw new Error('The Hey API organization cannot be empty.');\n  }\n\n  if (!project) {\n    throw new Error('The Hey API project cannot be empty.');\n  }\n\n  const result: Parsed = {\n    organization,\n    project,\n    queryParams,\n  };\n\n  return result;\n};\n\n/**\n * Transforms a Hey API shorthand string to the corresponding API URL.\n *\n * @param input - Hey API configuration input\n * @returns The Hey API Registry URL\n */\nexport const inputToHeyApiPath = (\n  input: Input & {\n    path: string;\n  },\n): Partial<Input> => {\n  const parsed = parseShorthand(input);\n  return {\n    path: getRegistryUrl(\n      parsed.organization,\n      parsed.project,\n      parsed.queryParams,\n    ),\n    registry: 'hey-api',\n  };\n};\n","import type { Input } from '~/types/input';\n\n// Regular expression to match ReadMe API Registry input formats:\n//   - @{organization}/{project}#{uuid}\n//   - {uuid}\nconst registryRegExp = /^(@([\\w-]+)\\/([\\w\\-.]+)#)?([\\w-]+)$/;\n\n/**\n * Creates a full ReadMe API Registry URL.\n *\n * @param uuid - ReadMe UUID\n * @returns The full ReadMe API registry URL.\n */\nexport const getRegistryUrl = (uuid: string): string =>\n  `https://dash.readme.com/api/v1/api-registry/${uuid}`;\n\nexport interface Parsed {\n  organization?: string;\n  project?: string;\n  uuid: string;\n}\n\nconst namespace = 'readme';\n\n/**\n * Parses a ReadMe input string and extracts components.\n *\n * @param shorthand - ReadMe format string (@org/project#uuid or uuid)\n * @returns Parsed ReadMe input components\n * @throws Error if the input format is invalid\n */\nexport const parseShorthand = (shorthand: string): Parsed => {\n  const match = shorthand.match(registryRegExp);\n\n  if (!match) {\n    throw new Error(\n      `Invalid ReadMe shorthand format. Expected \"${namespace}:@organization/project#uuid\" or \"${namespace}:uuid\", received: ${namespace}:${shorthand}`,\n    );\n  }\n\n  const [, , organization, project, uuid] = match;\n\n  if (!uuid) {\n    throw new Error('The ReadMe UUID cannot be empty.');\n  }\n\n  const result: Parsed = {\n    organization,\n    project,\n    uuid,\n  };\n\n  return result;\n};\n\n/**\n * Transforms a ReadMe shorthand string to the corresponding API URL.\n *\n * @param input - ReadMe format string\n * @returns The ReadMe API Registry URL\n */\nexport const inputToReadmePath = (input: string): Partial<Input> => {\n  const shorthand = input.slice(`${namespace}:`.length);\n  const parsed = parseShorthand(shorthand);\n  return {\n    ...parsed,\n    path: getRegistryUrl(parsed.uuid),\n    registry: 'readme',\n  };\n};\n","import type { Input } from '~/types/input';\n\n// Regular expression to match Scalar API Registry input formats:\n//   - @{organization}/{project}\nconst registryRegExp = /^(@[\\w-]+)\\/([\\w.-]+)$/;\n\n/**\n * Creates a full Scalar API Registry URL.\n *\n * @param organization - Scalar organization slug\n * @param project - Scalar project slug\n * @returns The full Scalar API registry URL.\n */\nexport const getRegistryUrl = (organization: string, project: string): string =>\n  `https://registry.scalar.com/${organization}/apis/${project}/latest?format=json`;\n\nexport interface Parsed {\n  organization: string;\n  project: string;\n}\n\nconst namespace = 'scalar';\n\n/**\n * Parses a Scalar input string and extracts components.\n *\n * @param shorthand - Scalar format string (@org/project)\n * @returns Parsed Scalar input components\n * @throws Error if the input format is invalid\n */\nexport const parseShorthand = (shorthand: string): Parsed => {\n  const match = shorthand.match(registryRegExp);\n\n  if (!match) {\n    throw new Error(\n      `Invalid Scalar shorthand format. Expected \"${namespace}:@organization/project\", received: ${namespace}:${shorthand}`,\n    );\n  }\n\n  const [, organization, project] = match;\n\n  if (!organization) {\n    throw new Error('The Scalar organization cannot be empty.');\n  }\n\n  if (!project) {\n    throw new Error('The Scalar project cannot be empty.');\n  }\n\n  const result: Parsed = {\n    organization,\n    project,\n  };\n\n  return result;\n};\n\n/**\n * Transforms a Scalar shorthand string to the corresponding API URL.\n *\n * @param input - Scalar format string\n * @returns The Scalar API Registry URL\n */\nexport const inputToScalarPath = (input: string): Partial<Input> => {\n  const shorthand = input.slice(`${namespace}:`.length);\n  const parsed = parseShorthand(shorthand);\n  return {\n    ...parsed,\n    path: getRegistryUrl(parsed.organization, parsed.project),\n    registry: 'scalar',\n  };\n};\n","import type { Input } from '~/types/input';\n\nimport { heyApiRegistryBaseUrl, inputToHeyApiPath } from './heyApi';\nimport { inputToReadmePath } from './readme';\nimport { inputToScalarPath } from './scalar';\n\nexport const inputToApiRegistry = (\n  input: Input & {\n    path: string;\n  },\n) => {\n  if (input.path.startsWith('readme:')) {\n    Object.assign(input, inputToReadmePath(input.path));\n    return;\n  }\n\n  if (input.path.startsWith('scalar:')) {\n    Object.assign(input, inputToScalarPath(input.path));\n    return;\n  }\n\n  if (input.path.startsWith('.')) {\n    return;\n  }\n\n  if (input.path.startsWith(heyApiRegistryBaseUrl)) {\n    input.path = input.path.slice(heyApiRegistryBaseUrl.length + 1);\n    Object.assign(input, inputToHeyApiPath(input as Input & { path: string }));\n    return;\n  }\n\n  const parts = input.path.split('/');\n  if (parts.length === 2 && parts.filter(Boolean).length === 2) {\n    Object.assign(input, inputToHeyApiPath(input as Input & { path: string }));\n    return;\n  }\n};\n","import type { Config, UserConfig } from '~/types/config';\nimport type { Input, Watch } from '~/types/input';\nimport { inputToApiRegistry } from '~/utils/input';\nimport { heyApiRegistryBaseUrl } from '~/utils/input/heyApi';\n\nconst defaultWatch: Watch = {\n  enabled: false,\n  interval: 1_000,\n  timeout: 60_000,\n};\n\n// watch only remote files\nconst getWatch = (input: Pick<Input, 'path' | 'watch'>): Watch => {\n  let watch = { ...defaultWatch };\n\n  // we cannot watch spec passed as an object\n  if (typeof input.path !== 'string') {\n    return watch;\n  }\n\n  if (typeof input.watch === 'boolean') {\n    watch.enabled = input.watch;\n  } else if (typeof input.watch === 'number') {\n    watch.enabled = true;\n    watch.interval = input.watch;\n  } else if (input.watch) {\n    watch = {\n      ...watch,\n      ...input.watch,\n    };\n  }\n\n  return watch;\n};\n\nexport const getInput = (userConfig: UserConfig): Config['input'] => {\n  const userInputs =\n    userConfig.input instanceof Array ? userConfig.input : [userConfig.input];\n\n  const inputs: Array<Input> = [];\n\n  for (const userInput of userInputs) {\n    let input: Input = {\n      path: '',\n      watch: defaultWatch,\n    };\n\n    if (typeof userInput === 'string') {\n      input.path = userInput;\n    } else if (\n      userInput &&\n      (userInput.path !== undefined || userInput.organization !== undefined)\n    ) {\n      // @ts-expect-error\n      input = {\n        ...input,\n        path: heyApiRegistryBaseUrl,\n        ...userInput,\n      };\n\n      if (input.watch !== undefined) {\n        input.watch = getWatch(input);\n      }\n    } else {\n      input = {\n        ...input,\n        path: userInput,\n      };\n    }\n\n    if (typeof input.path === 'string') {\n      inputToApiRegistry(input as Input & { path: string });\n    }\n\n    if (\n      userConfig.watch !== undefined &&\n      input.watch.enabled === defaultWatch.enabled &&\n      input.watch.interval === defaultWatch.interval &&\n      input.watch.timeout === defaultWatch.timeout\n    ) {\n      input.watch = getWatch({\n        path: input.path,\n        // @ts-expect-error\n        watch: userConfig.watch,\n      });\n    }\n\n    if (input.path) {\n      inputs.push(input);\n    }\n  }\n\n  return inputs;\n};\n","import type { Config, UserConfig } from '~/types/config';\n\nexport const getLogs = (\n  userConfig: Pick<UserConfig, 'logs'> | undefined,\n): Config['logs'] => {\n  let logs: Config['logs'] = {\n    file: true,\n    level: 'info',\n    path: process.cwd(),\n  };\n\n  if (typeof userConfig?.logs === 'string') {\n    logs.path = userConfig.logs;\n  } else {\n    logs = {\n      ...logs,\n      ...userConfig?.logs,\n    };\n  }\n\n  return logs;\n};\n","import type { UserConfig } from '~/types/config';\n\nconst mergeObjects = (\n  objA: Record<string, unknown> | undefined,\n  objB: Record<string, unknown> | undefined,\n): Record<string, unknown> => {\n  const a = objA || {};\n  const b = objB || {};\n  return {\n    ...a,\n    ...b,\n  };\n};\n\nexport const mergeConfigs = (\n  configA: UserConfig | undefined,\n  configB: UserConfig | undefined,\n): UserConfig => {\n  const a: Partial<UserConfig> = configA || {};\n  const b: Partial<UserConfig> = configB || {};\n  const merged: UserConfig = {\n    ...(a as UserConfig),\n    ...(b as UserConfig),\n  };\n  if (typeof merged.logs === 'object') {\n    merged.logs = mergeObjects(\n      a.logs as Record<string, unknown>,\n      b.logs as Record<string, unknown>,\n    );\n  }\n  return merged;\n};\n","type ObjectType<T> =\n  Extract<T, Record<string, any>> extends never\n    ? Record<string, any>\n    : Extract<T, Record<string, any>>;\n\ntype NotArray<T> = T extends Array<any> ? never : T;\ntype NotFunction<T> = T extends (...args: Array<any>) => any ? never : T;\ntype PlainObject<T> = T extends object\n  ? NotFunction<T> extends never\n    ? never\n    : NotArray<T> extends never\n      ? never\n      : T\n  : never;\n\ntype MappersType<T> = {\n  boolean: T extends boolean\n    ? (value: boolean) => Partial<ObjectType<T>>\n    : never;\n  function: T extends (...args: Array<any>) => any\n    ? (value: (...args: Array<any>) => any) => Partial<ObjectType<T>>\n    : never;\n  number: T extends number ? (value: number) => Partial<ObjectType<T>> : never;\n  object?: PlainObject<T> extends never\n    ? never\n    : (\n        value: Partial<PlainObject<T>>,\n        defaultValue: PlainObject<T>,\n      ) => Partial<ObjectType<T>>;\n  string: T extends string ? (value: string) => Partial<ObjectType<T>> : never;\n} extends infer U\n  ? { [K in keyof U as U[K] extends never ? never : K]: U[K] }\n  : never;\n\ntype IsObjectOnly<T> = T extends Record<string, any> | undefined\n  ? Extract<\n      T,\n      string | boolean | number | ((...args: Array<any>) => any)\n    > extends never\n    ? true\n    : false\n  : false;\n\nexport type ValueToObject = <\n  T extends\n    | undefined\n    | string\n    | boolean\n    | number\n    | ((...args: Array<any>) => any)\n    | Record<string, any>,\n>(\n  args: {\n    defaultValue: ObjectType<T>;\n    value: T;\n  } & (IsObjectOnly<T> extends true\n    ? {\n        mappers?: MappersType<T>;\n      }\n    : {\n        mappers: MappersType<T>;\n      }),\n) => PlainObject<T>;\n\nconst isPlainObject = (value: unknown): value is Record<string, any> =>\n  typeof value === 'object' &&\n  value !== null &&\n  !Array.isArray(value) &&\n  typeof value !== 'function';\n\nconst mergeResult = <T>(\n  result: ObjectType<T>,\n  mapped: Record<string, any>,\n): ObjectType<T> => {\n  for (const [key, value] of Object.entries(mapped)) {\n    if (value !== undefined && value !== '') {\n      (result as Record<string, any>)[key] = value;\n    }\n  }\n  return result;\n};\n\nexport const valueToObject: ValueToObject = ({\n  defaultValue,\n  mappers,\n  value,\n}) => {\n  let result = { ...defaultValue };\n\n  switch (typeof value) {\n    case 'boolean':\n      if (mappers && 'boolean' in mappers) {\n        const mapper = mappers.boolean as (\n          value: boolean,\n        ) => Record<string, any>;\n        result = mergeResult(result, mapper(value));\n      }\n      break;\n    case 'function':\n      if (mappers && 'function' in mappers) {\n        const mapper = mappers.function as (\n          value: (...args: Array<any>) => any,\n        ) => Record<string, any>;\n        result = mergeResult(\n          result,\n          mapper(value as (...args: Array<any>) => any),\n        );\n      }\n      break;\n    case 'number':\n      if (mappers && 'number' in mappers) {\n        const mapper = mappers.number as (value: number) => Record<string, any>;\n        result = mergeResult(result, mapper(value));\n      }\n      break;\n    case 'string':\n      if (mappers && 'string' in mappers) {\n        const mapper = mappers.string as (value: string) => Record<string, any>;\n        result = mergeResult(result, mapper(value));\n      }\n      break;\n    case 'object':\n      if (isPlainObject(value)) {\n        if (\n          mappers &&\n          'object' in mappers &&\n          typeof mappers.object === 'function'\n        ) {\n          const mapper = mappers.object as (\n            value: Record<string, any>,\n            defaultValue: ObjectType<any>,\n          ) => Partial<ObjectType<any>>;\n          result = mergeResult(result, mapper(value, defaultValue));\n        } else {\n          result = mergeResult(result, value);\n        }\n      }\n      break;\n  }\n\n  return result as any;\n};\n","import ts from 'typescript';\n\nimport { findTsConfigPath, loadTsConfig } from '~/generate/tsConfig';\nimport type { Config, UserConfig } from '~/types/config';\n\nimport { valueToObject } from './utils/config';\n\nexport const getOutput = (userConfig: UserConfig): Config['output'] => {\n  if (userConfig.output instanceof Array) {\n    throw new Error(\n      'Unexpected array of outputs in user configuration. This should have been expanded already.',\n    );\n  }\n\n  const output = valueToObject({\n    defaultValue: {\n      clean: true,\n      fileName: {\n        case: 'preserve',\n        name: '{{name}}',\n        suffix: '.gen',\n      },\n      format: null,\n      header: '// This file is auto-generated by @hey-api/openapi-ts',\n      indexFile: true,\n      lint: null,\n      path: '',\n      preferExportAll: false,\n    },\n    mappers: {\n      object: (fields, defaultValue) => ({\n        ...fields,\n        fileName: valueToObject({\n          defaultValue: {\n            ...(defaultValue.fileName as Extract<\n              typeof defaultValue.fileName,\n              Record<string, unknown>\n            >),\n          },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: fields.fileName,\n        }),\n      }),\n      string: (path) => ({ path }),\n    },\n    value: userConfig.output,\n  }) as Config['output'];\n  output.tsConfig = loadTsConfig(findTsConfigPath(output.tsConfigPath));\n  if (\n    output.importFileExtension === undefined &&\n    (output.tsConfig?.options.moduleResolution ===\n      ts.ModuleResolutionKind.NodeNext ||\n      output.tsConfig?.options.moduleResolution ===\n        ts.ModuleResolutionKind.Node16)\n  ) {\n    output.importFileExtension = '.js';\n  }\n  if (\n    output.importFileExtension &&\n    !output.importFileExtension.startsWith('.')\n  ) {\n    output.importFileExtension = `.${output.importFileExtension}`;\n  }\n  return output;\n};\n","import fs from 'node:fs';\nimport path from 'node:path';\n\n/**\n * Finds and reads the project's package.json file by searching upwards from the config file location,\n * or from process.cwd() if no config file is provided.\n * This ensures we get the correct dependencies even in monorepo setups.\n *\n * @param configFilePath - The path to the configuration file (e.g., openapi-ts.config.ts)\n * @returns An object containing all project dependencies (dependencies, devDependencies, peerDependencies, optionalDependencies)\n */\nexport const getProjectDependencies = (\n  configFilePath?: string,\n): Record<string, string> => {\n  let currentDir = configFilePath\n    ? path.dirname(configFilePath)\n    : process.cwd();\n\n  while (currentDir !== path.dirname(currentDir)) {\n    const packageJsonPath = path.join(currentDir, 'package.json');\n\n    if (fs.existsSync(packageJsonPath)) {\n      try {\n        const packageJson = JSON.parse(\n          fs.readFileSync(packageJsonPath, 'utf8'),\n        );\n        return {\n          ...packageJson.dependencies,\n          ...packageJson.devDependencies,\n          ...packageJson.peerDependencies,\n          ...packageJson.optionalDependencies,\n        };\n      } catch {\n        // Silently ignore JSON parsing errors and continue searching\n      }\n    }\n\n    const parentDir = path.dirname(currentDir);\n    if (parentDir === currentDir) {\n      break;\n    }\n    currentDir = parentDir;\n  }\n\n  return {};\n};\n","import type { Config, UserConfig } from '~/types/config';\n\nimport { valueToObject } from './utils/config';\n\nexport const defaultPaginationKeywords = [\n  'after',\n  'before',\n  'cursor',\n  'offset',\n  'page',\n  'start',\n] as const;\n\nexport const getParser = (userConfig: UserConfig): Config['parser'] => {\n  const parser = valueToObject({\n    defaultValue: {\n      hooks: {},\n      pagination: {\n        keywords: defaultPaginationKeywords,\n      },\n      transforms: {\n        enums: {\n          case: 'PascalCase',\n          enabled: false,\n          mode: 'root',\n          name: '{{name}}Enum',\n        },\n        propertiesRequiredByDefault: false,\n        readWrite: {\n          enabled: true,\n          requests: {\n            case: 'preserve',\n            name: '{{name}}Writable',\n          },\n          responses: {\n            case: 'preserve',\n            name: '{{name}}',\n          },\n        },\n      },\n      validate_EXPERIMENTAL: false,\n    },\n    mappers: {\n      object: (fields, defaultValue) => ({\n        ...fields,\n        pagination: valueToObject({\n          defaultValue: {\n            ...(defaultValue.pagination as Extract<\n              typeof defaultValue.pagination,\n              Record<string, unknown>\n            >),\n          },\n          value: fields.pagination,\n        }),\n        transforms: valueToObject({\n          defaultValue: {\n            ...(defaultValue.transforms as Extract<\n              typeof defaultValue.transforms,\n              Record<string, unknown>\n            >),\n          },\n          mappers: {\n            object: (fields, defaultValue) => ({\n              ...fields,\n              enums: valueToObject({\n                defaultValue: {\n                  ...(defaultValue.enums as Extract<\n                    typeof defaultValue.enums,\n                    Record<string, unknown>\n                  >),\n                  enabled:\n                    fields.enums !== undefined\n                      ? Boolean(fields.enums)\n                      : (\n                          defaultValue.enums as Extract<\n                            typeof defaultValue.enums,\n                            Record<string, unknown>\n                          >\n                        ).enabled,\n                },\n                mappers: {\n                  boolean: (enabled) => ({ enabled }),\n                  string: (mode) => ({ mode }),\n                },\n                value: fields.enums,\n              }),\n              propertiesRequiredByDefault:\n                fields.propertiesRequiredByDefault !== undefined\n                  ? fields.propertiesRequiredByDefault\n                  : defaultValue.propertiesRequiredByDefault,\n              readWrite: valueToObject({\n                defaultValue: {\n                  ...(defaultValue.readWrite as Extract<\n                    typeof defaultValue.readWrite,\n                    Record<string, unknown>\n                  >),\n                  enabled:\n                    fields.readWrite !== undefined\n                      ? Boolean(fields.readWrite)\n                      : (\n                          defaultValue.readWrite as Extract<\n                            typeof defaultValue.readWrite,\n                            Record<string, unknown>\n                          >\n                        ).enabled,\n                },\n                mappers: {\n                  boolean: (enabled) => ({ enabled }),\n                  object: (fields, defaultValue) => ({\n                    ...fields,\n                    requests: valueToObject({\n                      defaultValue: {\n                        ...(defaultValue.requests as Extract<\n                          typeof defaultValue.requests,\n                          Record<string, unknown>\n                        >),\n                      },\n                      mappers: {\n                        function: (name) => ({ name }),\n                        string: (name) => ({ name }),\n                      },\n                      value: fields.requests,\n                    }),\n                    responses: valueToObject({\n                      defaultValue: {\n                        ...(defaultValue.responses as Extract<\n                          typeof defaultValue.responses,\n                          Record<string, unknown>\n                        >),\n                      },\n                      mappers: {\n                        function: (name) => ({ name }),\n                        string: (name) => ({ name }),\n                      },\n                      value: fields.responses,\n                    }),\n                  }),\n                },\n                value: fields.readWrite,\n              }),\n            }),\n          },\n          value: fields.transforms,\n        }),\n        validate_EXPERIMENTAL:\n          fields.validate_EXPERIMENTAL === true\n            ? 'warn'\n            : fields.validate_EXPERIMENTAL,\n      }),\n    },\n    value: userConfig.parser,\n  });\n  return parser as Config['parser'];\n};\n","import type { Plugin } from '~/plugins';\n\nexport const definePluginConfig =\n  <T extends Plugin.Types>(defaultConfig: Plugin.Config<T>) =>\n  (\n    userConfig?: Omit<T['config'], 'name'>,\n  ): Omit<Plugin.Config<T>, 'name'> & {\n    /**\n     * Cast name to `any` so it doesn't throw type error in `plugins` array.\n     * We could allow any `string` as plugin `name` in the object syntax, but\n     * that TypeScript trick would cause all string methods to appear as\n     * suggested auto completions, which is undesirable.\n     */\n    name: any;\n  } => ({\n    ...defaultConfig,\n    config: {\n      ...defaultConfig.config,\n      ...userConfig,\n    },\n  });\n\n/**\n * Reusable mappers for `enabled` and `name` fields.\n */\nexport const mappers = {\n  boolean: (enabled: boolean) => ({ enabled }),\n  function: (name: (...args: Array<any>) => any) => ({ name }),\n  string: (name: string) => ({ name }),\n} as const;\n","import type { PluginContext } from '~/plugins/types';\n\nimport type { UserConfig } from '../types';\nimport type { HttpRequestsConfig, UserHttpRequestsConfig } from './types';\n\ntype Config = Omit<UserConfig, 'name'>;\n\nexport function resolveHttpRequests(\n  config: Config,\n  context: PluginContext,\n): HttpRequestsConfig {\n  let input = config.httpRequests;\n  if (typeof input === 'string' || typeof input === 'function') {\n    input = { strategy: input };\n  } else if (typeof input === 'boolean' || !input) {\n    input = { enabled: Boolean(input) };\n  }\n\n  const strategy = input.strategy ?? 'flat';\n\n  return context.valueToObject({\n    defaultValue: {\n      container: 'class',\n      enabled: true,\n      methods: 'instance',\n      nesting: 'operationId',\n      nestingDelimiters: /[./]/,\n      strategy,\n      strategyDefaultTag: 'default',\n    },\n    mappers: {\n      object(value) {\n        value.containerName = context.valueToObject({\n          defaultValue:\n            strategy === 'single'\n              ? { casing: 'PascalCase', name: 'HttpRequests' }\n              : { casing: 'PascalCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.containerName,\n        });\n        value.methodName = context.valueToObject({\n          defaultValue:\n            strategy === 'flat'\n              ? { casing: 'camelCase', name: '{{name}}Request' }\n              : { casing: 'camelCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.methodName,\n        });\n        value.segmentName = context.valueToObject({\n          defaultValue: { casing: 'PascalCase', name: '{{name}}Requests' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.segmentName,\n        });\n        return value;\n      },\n    },\n    value: input as UserHttpRequestsConfig,\n  }) as HttpRequestsConfig;\n}\n","import type { StructureLocation } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\n\n/**\n * A function that derives path segments from an operation.\n *\n * Used by location strategies to build paths within containers.\n */\nexport type OperationPathStrategy = (\n  operation: IR.OperationObject,\n) => ReadonlyArray<string>;\n\n/**\n * A function that determines where an operation appears in the structure.\n *\n * Returns one or more locations, each with a full path.\n */\nexport type OperationStructureStrategy = (\n  operation: IR.OperationObject,\n) => ReadonlyArray<StructureLocation['path']>;\n\nexport type OperationsStrategy =\n  | 'byTags'\n  | 'flat'\n  | 'single'\n  | OperationStructureStrategy;\n\n/**\n * Built-in strategies for operations.\n */\nexport const OperationStrategy = {\n  /**\n   * Creates one root container per operation tag.\n   *\n   * Operations with multiple tags appear in multiple root containers.\n   * Operations without tags use the fallback root container.\n   *\n   * @example\n   * // Operation with tags: ['users', 'admin']\n   * // Path function returns: ['list']\n   * // Result: [{ path: ['users', 'list'], shell }, { path: ['admin', 'list'], shell }]\n   */\n  byTags:\n    (config: {\n      /**\n       * Root name for operations without tags.\n       */\n      fallback: string;\n      /**\n       * Derives path segments from the operation.\n       *\n       * @default OperationPath.id()\n       */\n      path?: OperationPathStrategy;\n    }): OperationStructureStrategy =>\n    (operation) => {\n      const tags =\n        operation.tags && operation.tags.length > 0\n          ? operation.tags\n          : [config.fallback];\n      const path = config.path ?? OperationPath.id();\n      const pathSegments = path(operation);\n      return tags.map((tag) => [tag, ...pathSegments]);\n    },\n\n  /**\n   * Creates flat functions without any container.\n   *\n   * Each operation becomes a standalone function at the root level.\n   * No shell is applied.\n   *\n   * @example\n   * // Operation id: 'getUsers'\n   * // Result: [{ path: ['getUsers'] }]\n   */\n  flat:\n    (config?: {\n      /**\n       * Derives path segments within the root from the operation.\n       *\n       * @default OperationPath.id()\n       */\n      path?: OperationPathStrategy;\n    }): OperationStructureStrategy =>\n    (operation) => {\n      const path = config?.path ?? OperationPath.id();\n      const pathSegments = path(operation);\n      return [[pathSegments[pathSegments.length - 1]!]];\n    },\n\n  /**\n   * Places all operations under a single root container.\n   *\n   * @example\n   * // Root: 'Sdk', path function returns: ['users', 'list']\n   * // Result: [{ path: ['Sdk', 'users', 'list'], shell }]\n   */\n  single:\n    (config: {\n      /**\n       * Derives path segments within the root from the operation.\n       *\n       * @default OperationPath.id()\n       */\n      path?: OperationPathStrategy;\n      /**\n       * Name of the container.\n       */\n      root: string;\n    }): OperationStructureStrategy =>\n    (operation) => {\n      const path = config.path ?? OperationPath.id();\n      const pathSegments = path(operation);\n      return [[config.root, ...pathSegments]];\n    },\n};\n\n/**\n * Built-in path derivation helpers for operations.\n */\nexport const OperationPath = {\n  /**\n   * Splits operationId by delimiters to create nested paths.\n   *\n   * @example\n   * // operationId: 'users.accounts.list'\n   * // Result: ['users', 'accounts', 'list']\n   *\n   * @example\n   * // operationId: 'users/accounts/getAll'\n   * // Result: ['users', 'accounts', 'getAll']\n   */\n  fromOperationId:\n    (config?: {\n      /**\n       * Pattern to split operationId.\n       *\n       * @default /[./]/\n       */\n      delimiters?: RegExp;\n      /**\n       * Fallback strategy if operationId is missing.\n       *\n       * @default OperationPath.id()\n       */\n      fallback?: OperationPathStrategy;\n    }): OperationPathStrategy =>\n    (operation) => {\n      const fallback = config?.fallback ?? OperationPath.id();\n      if (!operation.operationId) return fallback(operation);\n      const delimiters = config?.delimiters ?? /[./]/;\n      const segments = operation.operationId.split(delimiters).filter(Boolean);\n      return segments.length === 0 ? fallback(operation) : segments;\n    },\n\n  /**\n   * Splits path by delimiters to create nested paths.\n   *\n   * Can include the method as a prefix or suffix segment.\n   *\n   * @example\n   * // path: '/users/{id}/accounts', method: 'get', delimiters: /[\\/{}]+/, methodPosition: 'none'\n   * // Result: ['users', 'id', 'accounts']\n   *\n   * @example\n   * // path: '/users/{id}/accounts', method: 'get', delimiters: /[\\/{}]+/, methodPosition: 'prefix'\n   * // Result: ['get', 'users', 'id', 'accounts']\n   *\n   * @example\n   * // path: '/users/{id}/accounts', method: 'get', delimiters: /[\\/{}]+/, methodPosition: 'suffix'\n   * // Result: ['users', 'id', 'accounts', 'get']\n   */\n  fromPath:\n    (config?: {\n      /**\n       * Pattern to split the path.\n       *\n       * @default /[./]/\n       */\n      delimiters?: RegExp;\n      /**\n       * Position of the method segment.\n       *\n       * @default 'none'\n       */\n      methodPosition?: 'prefix' | 'suffix';\n    }): OperationPathStrategy =>\n    (operation) => {\n      const delimiters = config?.delimiters ?? /[./]/;\n      const segments = operation.path.split(delimiters).filter(Boolean);\n      switch (config?.methodPosition) {\n        case 'prefix':\n          segments.unshift(operation.method.toLowerCase());\n          break;\n        case 'suffix':\n          segments.push(operation.method.toLowerCase());\n          break;\n        default:\n          break;\n      }\n      return segments;\n    },\n\n  /**\n   * Uses operation.id as a single path segment.\n   *\n   * @example\n   * // operation.id: 'getUserById'\n   * // Result: ['getUserById']\n   */\n  id: (): OperationPathStrategy => (operation) => [operation.id],\n};\n","import type {\n  OperationPathStrategy,\n  OperationStructureStrategy,\n} from '~/openApi/shared/locations';\nimport { OperationPath, OperationStrategy } from '~/openApi/shared/locations';\n\nimport type { AngularCommonPlugin } from '../types';\n\nfunction resolvePath(\n  plugin: AngularCommonPlugin['Instance'],\n): OperationPathStrategy {\n  if (plugin.config.httpRequests.nesting === 'id') {\n    return OperationPath.id();\n  }\n\n  if (plugin.config.httpRequests.nesting === 'operationId') {\n    return OperationPath.fromOperationId({\n      delimiters: plugin.config.httpRequests.nestingDelimiters,\n      fallback: OperationPath.id(),\n    });\n  }\n\n  return plugin.config.httpRequests.nesting;\n}\n\nexport function resolveHttpRequestsStrategy(\n  plugin: AngularCommonPlugin['Instance'],\n): OperationStructureStrategy {\n  if (plugin.config.httpRequests.strategy === 'flat') {\n    return OperationStrategy.flat({\n      path: (operation) => [resolvePath(plugin)(operation).join('.')],\n    });\n  }\n\n  if (plugin.config.httpRequests.strategy === 'single') {\n    const root = plugin.config.httpRequests.containerName;\n    return OperationStrategy.single({\n      path: resolvePath(plugin),\n      root: typeof root.name === 'string' ? root.name : (root.name?.('') ?? ''),\n    });\n  }\n\n  if (plugin.config.httpRequests.strategy === 'byTags') {\n    return OperationStrategy.byTags({\n      fallback: plugin.config.httpRequests.strategyDefaultTag,\n      path: resolvePath(plugin),\n    });\n  }\n\n  return plugin.config.httpRequests.strategy;\n}\n","import type { PluginContext } from '~/plugins/types';\n\nimport type { UserConfig } from '../types';\nimport type { HttpResourcesConfig, UserHttpResourcesConfig } from './types';\n\ntype Config = Omit<UserConfig, 'name'>;\n\nexport function resolveHttpResources(\n  config: Config,\n  context: PluginContext,\n): HttpResourcesConfig {\n  let input = config.httpResources;\n  if (typeof input === 'string' || typeof input === 'function') {\n    input = { strategy: input };\n  } else if (typeof input === 'boolean' || !input) {\n    input = { enabled: Boolean(input) };\n  }\n\n  const strategy = input.strategy ?? 'flat';\n\n  return context.valueToObject({\n    defaultValue: {\n      container: 'class',\n      enabled: true,\n      methods: 'instance',\n      nesting: 'operationId',\n      nestingDelimiters: /[./]/,\n      strategy,\n      strategyDefaultTag: 'default',\n    },\n    mappers: {\n      object(value) {\n        value.containerName = context.valueToObject({\n          defaultValue:\n            strategy === 'single'\n              ? { casing: 'PascalCase', name: 'HttpResources' }\n              : { casing: 'PascalCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.containerName,\n        });\n        value.methodName = context.valueToObject({\n          defaultValue:\n            strategy === 'flat'\n              ? { casing: 'camelCase', name: '{{name}}Resource' }\n              : { casing: 'camelCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.methodName,\n        });\n        value.segmentName = context.valueToObject({\n          defaultValue: { casing: 'PascalCase', name: '{{name}}Resources' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.segmentName,\n        });\n        return value;\n      },\n    },\n    value: input as UserHttpResourcesConfig,\n  }) as HttpResourcesConfig;\n}\n","import type {\n  OperationPathStrategy,\n  OperationStructureStrategy,\n} from '~/openApi/shared/locations';\nimport { OperationPath, OperationStrategy } from '~/openApi/shared/locations';\n\nimport type { AngularCommonPlugin } from '../types';\n\nfunction resolvePath(\n  plugin: AngularCommonPlugin['Instance'],\n): OperationPathStrategy {\n  if (plugin.config.httpResources.nesting === 'id') {\n    return OperationPath.id();\n  }\n\n  if (plugin.config.httpResources.nesting === 'operationId') {\n    return OperationPath.fromOperationId({\n      delimiters: plugin.config.httpResources.nestingDelimiters,\n      fallback: OperationPath.id(),\n    });\n  }\n\n  return plugin.config.httpResources.nesting;\n}\n\nexport function resolveHttpResourcesStrategy(\n  plugin: AngularCommonPlugin['Instance'],\n): OperationStructureStrategy {\n  if (plugin.config.httpResources.strategy === 'flat') {\n    return OperationStrategy.flat({\n      path: (operation) => [resolvePath(plugin)(operation).join('.')],\n    });\n  }\n\n  if (plugin.config.httpResources.strategy === 'single') {\n    const root = plugin.config.httpResources.containerName;\n    return OperationStrategy.single({\n      path: resolvePath(plugin),\n      root: typeof root.name === 'string' ? root.name : (root.name?.('') ?? ''),\n    });\n  }\n\n  if (plugin.config.httpResources.strategy === 'byTags') {\n    return OperationStrategy.byTags({\n      fallback: plugin.config.httpResources.strategyDefaultTag,\n      path: resolvePath(plugin),\n    });\n  }\n\n  return plugin.config.httpResources.strategy;\n}\n","import type { PluginClientNames } from '~/plugins/types';\nimport type { Config } from '~/types/config';\n\nexport const getClientBaseUrlKey = (config: Config) => {\n  const client = getClientPlugin(config);\n  if (\n    client.name === '@hey-api/client-axios' ||\n    client.name === '@hey-api/client-nuxt'\n  ) {\n    return 'baseURL';\n  }\n  return 'baseUrl';\n};\n\nexport const getClientPlugin = (\n  config: Config,\n): Config['plugins'][PluginClientNames] & { name: PluginClientNames } => {\n  for (const name of config.pluginOrder) {\n    const plugin = config.plugins[name];\n    if (plugin?.tags?.includes('client')) {\n      return plugin as Config['plugins'][PluginClientNames] & {\n        name: PluginClientNames;\n      };\n    }\n  }\n\n  return {\n    config: {\n      // @ts-expect-error\n      name: '',\n    },\n    // @ts-expect-error\n    name: '',\n  };\n};\n","import type { Context } from './context';\nimport type { Pagination } from './pagination';\nimport type { IR } from './types';\n\nconst getPaginationSchema = ({\n  context,\n  parameter,\n}: {\n  context: Context;\n  parameter: IR.ParameterObject;\n}): IR.SchemaObject | undefined => {\n  if (!parameter.pagination) {\n    return;\n  }\n\n  if (parameter.pagination === true) {\n    return parameter.schema;\n  }\n\n  let schema = parameter.schema;\n  if (schema.$ref) {\n    schema = context.resolveIrRef<IR.SchemaObject>(schema.$ref);\n  }\n\n  return schema.properties![parameter.pagination]!;\n};\n\nexport const hasParameterGroupObjectRequired = (\n  parameterGroup?: Record<string, IR.ParameterObject>,\n): boolean => {\n  for (const name in parameterGroup) {\n    if (parameterGroup[name]!.required) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport const hasParametersObjectRequired = (\n  parameters: IR.ParametersObject | undefined,\n): boolean => {\n  if (!parameters) {\n    return false;\n  }\n\n  if (hasParameterGroupObjectRequired(parameters.cookie)) {\n    return true;\n  }\n\n  if (hasParameterGroupObjectRequired(parameters.header)) {\n    return true;\n  }\n\n  if (hasParameterGroupObjectRequired(parameters.path)) {\n    return true;\n  }\n\n  if (hasParameterGroupObjectRequired(parameters.query)) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const parameterWithPagination = ({\n  context,\n  parameters,\n}: {\n  context: Context;\n  parameters: IR.ParametersObject | undefined;\n}): Pagination | undefined => {\n  if (!parameters) {\n    return;\n  }\n\n  for (const name in parameters.cookie) {\n    const parameter = parameters.cookie[name]!;\n    if (parameter.pagination) {\n      return {\n        in: parameter.location,\n        name:\n          parameter.pagination === true\n            ? parameter.name\n            : `${parameter.name}.${parameter.pagination}`,\n        schema: getPaginationSchema({ context, parameter })!,\n      };\n    }\n  }\n\n  for (const name in parameters.header) {\n    const parameter = parameters.header[name]!;\n    if (parameter.pagination) {\n      return {\n        in: parameter.location,\n        name:\n          parameter.pagination === true\n            ? parameter.name\n            : `${parameter.name}.${parameter.pagination}`,\n        schema: getPaginationSchema({ context, parameter })!,\n      };\n    }\n  }\n\n  for (const name in parameters.path) {\n    const parameter = parameters.path[name]!;\n    if (parameter.pagination) {\n      return {\n        in: parameter.location,\n        name:\n          parameter.pagination === true\n            ? parameter.name\n            : `${parameter.name}.${parameter.pagination}`,\n        schema: getPaginationSchema({ context, parameter })!,\n      };\n    }\n  }\n\n  for (const name in parameters.query) {\n    const parameter = parameters.query[name]!;\n    if (parameter.pagination) {\n      return {\n        in: parameter.location,\n        name:\n          parameter.pagination === true\n            ? parameter.name\n            : `${parameter.name}.${parameter.pagination}`,\n        schema: getPaginationSchema({ context, parameter })!,\n      };\n    }\n  }\n\n  return;\n};\n","import type { IR } from './types';\n\n/**\n * Ensure we don't produce redundant types, e.g. string | string.\n */\nexport const deduplicateSchema = <T extends IR.SchemaObject>({\n  detectFormat = true,\n  schema,\n}: {\n  detectFormat?: boolean;\n  schema: T;\n}): T => {\n  if (!schema.items) {\n    return schema;\n  }\n\n  const uniqueItems: Array<IR.SchemaObject> = [];\n  const typeIds: Array<string> = [];\n\n  for (const item of schema.items) {\n    // skip nested schemas for now, handle if necessary\n    if ((!item.type && item.items) || schema.type === 'tuple') {\n      uniqueItems.push(item);\n      continue;\n    }\n\n    if (\n      // no `type` might still include `$ref` or `const`\n      !item.type ||\n      item.type === 'boolean' ||\n      item.type === 'integer' ||\n      item.type === 'null' ||\n      item.type === 'number' ||\n      item.type === 'string' ||\n      item.type === 'unknown' ||\n      item.type === 'void'\n    ) {\n      // const needs namespace to handle empty string values, otherwise\n      // fallback would equal an actual value and we would skip an item\n      const constant = item.const !== undefined ? `const-${item.const}` : '';\n      const format =\n        item.format !== undefined && detectFormat\n          ? `format-${item.format}`\n          : '';\n\n      // Include validation constraints in the type ID to avoid incorrect deduplication\n      const constraints = [\n        item.minLength !== undefined ? `minLength-${item.minLength}` : '',\n        item.maxLength !== undefined ? `maxLength-${item.maxLength}` : '',\n        item.minimum !== undefined ? `minimum-${item.minimum}` : '',\n        item.maximum !== undefined ? `maximum-${item.maximum}` : '',\n        item.exclusiveMinimum !== undefined\n          ? `exclusiveMinimum-${item.exclusiveMinimum}`\n          : '',\n        item.exclusiveMaximum !== undefined\n          ? `exclusiveMaximum-${item.exclusiveMaximum}`\n          : '',\n        item.minItems !== undefined ? `minItems-${item.minItems}` : '',\n        item.maxItems !== undefined ? `maxItems-${item.maxItems}` : '',\n        item.pattern !== undefined ? `pattern-${item.pattern}` : '',\n      ].join('');\n\n      const typeId = `${item.$ref ?? ''}${item.type ?? ''}${constant}${format}${constraints}`;\n      if (!typeIds.includes(typeId)) {\n        typeIds.push(typeId);\n        uniqueItems.push(item);\n      }\n      continue;\n    }\n\n    uniqueItems.push(item);\n  }\n\n  let result = { ...schema };\n  result.items = uniqueItems;\n\n  if (\n    result.items.length <= 1 &&\n    result.type !== 'array' &&\n    result.type !== 'enum' &&\n    result.type !== 'tuple'\n  ) {\n    // bring the only item up to clean up the schema\n    const liftedSchema = result.items[0];\n    delete result.logicalOperator;\n    delete result.items;\n    result = {\n      ...result,\n      ...liftedSchema,\n    };\n  }\n\n  // exclude unknown if it's the only type left\n  if (result.type === 'unknown') {\n    return {} as T;\n  }\n\n  return result;\n};\n","import type { IR } from './types';\n\n/**\n * Simply adds `items` to the schema. Also handles setting the logical operator\n * and avoids setting it for a single item or tuples.\n */\nexport const addItemsToSchema = ({\n  items,\n  logicalOperator = 'or',\n  mutateSchemaOneItem = false,\n  schema,\n}: {\n  items: Array<IR.SchemaObject>;\n  logicalOperator?: IR.SchemaObject['logicalOperator'];\n  mutateSchemaOneItem?: boolean;\n  schema: IR.SchemaObject;\n}) => {\n  if (!items.length) {\n    return schema;\n  }\n\n  if (schema.type === 'tuple') {\n    schema.items = items;\n    return schema;\n  }\n\n  if (items.length !== 1) {\n    schema.items = items;\n    schema.logicalOperator = logicalOperator;\n    return schema;\n  }\n\n  if (mutateSchemaOneItem) {\n    // bring composition up to avoid extraneous brackets\n    schema = {\n      ...schema,\n      ...items[0],\n    };\n    return schema;\n  }\n\n  schema.items = items;\n  return schema;\n};\n","import type { Context } from './context';\nimport type { Pagination } from './pagination';\nimport {\n  hasParametersObjectRequired,\n  parameterWithPagination,\n} from './parameter';\nimport { deduplicateSchema } from './schema';\nimport type { IR } from './types';\nimport { addItemsToSchema } from './utils';\n\nexport const hasOperationDataRequired = (\n  operation: IR.OperationObject,\n): boolean => {\n  if (hasParametersObjectRequired(operation.parameters)) {\n    return true;\n  }\n\n  if (operation.body?.required) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const createOperationKey = ({\n  method,\n  path,\n}: {\n  method: string;\n  path: string;\n}) => `${method.toUpperCase()} ${path}`;\n\nexport const operationPagination = ({\n  context,\n  operation,\n}: {\n  context: Context;\n  operation: IR.OperationObject;\n}): Pagination | undefined => {\n  const body = operation.body;\n\n  if (!body || !body.pagination) {\n    return parameterWithPagination({\n      context,\n      parameters: operation.parameters,\n    });\n  }\n\n  if (body.pagination === true) {\n    return {\n      in: 'body',\n      name: 'body',\n      schema: body.schema,\n    };\n  }\n\n  const schema = body.schema;\n  const resolvedSchema = schema.$ref\n    ? context.resolveIrRef<IR.RequestBodyObject | IR.SchemaObject>(schema.$ref)\n    : schema;\n\n  const finalSchema =\n    'schema' in resolvedSchema ? resolvedSchema.schema : resolvedSchema;\n  const paginationProp = finalSchema?.properties?.[body.pagination];\n\n  if (!paginationProp) {\n    return parameterWithPagination({\n      context,\n      parameters: operation.parameters,\n    });\n  }\n\n  return {\n    in: 'body',\n    name: body.pagination,\n    schema: paginationProp,\n  };\n};\n\ntype StatusGroup = '1XX' | '2XX' | '3XX' | '4XX' | '5XX' | 'default';\n\nexport const statusCodeToGroup = ({\n  statusCode,\n}: {\n  statusCode: string;\n}): StatusGroup => {\n  switch (statusCode) {\n    case '1XX':\n      return '1XX';\n    case '2XX':\n      return '2XX';\n    case '3XX':\n      return '3XX';\n    case '4XX':\n      return '4XX';\n    case '5XX':\n      return '5XX';\n    case 'default':\n      return 'default';\n    default:\n      return `${statusCode[0]}XX` as StatusGroup;\n  }\n};\n\ninterface OperationResponsesMap {\n  /**\n   * A deduplicated union of all error types. Unknown types are omitted.\n   */\n  error?: IR.SchemaObject;\n  /**\n   * An object containing a map of status codes for each error type.\n   */\n  errors?: IR.SchemaObject;\n  /**\n   * A deduplicated union of all response types. Unknown types are omitted.\n   */\n  response?: IR.SchemaObject;\n  /**\n   * An object containing a map of status codes for each response type.\n   */\n  responses?: IR.SchemaObject;\n}\n\nexport const operationResponsesMap = (\n  operation: IR.OperationObject,\n): OperationResponsesMap => {\n  const result: OperationResponsesMap = {};\n\n  if (!operation.responses) {\n    return result;\n  }\n\n  const errors: Omit<IR.SchemaObject, 'properties'> &\n    Pick<Required<IR.SchemaObject>, 'properties'> = {\n    properties: {},\n    type: 'object',\n  };\n\n  const responses: Omit<IR.SchemaObject, 'properties'> &\n    Pick<Required<IR.SchemaObject>, 'properties'> = {\n    properties: {},\n    type: 'object',\n  };\n\n  // store default response to be evaluated last\n  let defaultResponse: IR.ResponseObject | undefined;\n\n  for (const name in operation.responses) {\n    const response = operation.responses[name]!;\n\n    switch (statusCodeToGroup({ statusCode: name })) {\n      case '1XX':\n      case '3XX':\n        // TODO: parser - handle informational and redirection status codes\n        break;\n      case '2XX':\n        responses.properties[name] = response.schema;\n        break;\n      case '4XX':\n      case '5XX':\n        errors.properties[name] = response.schema;\n        break;\n      case 'default':\n        defaultResponse = response;\n        break;\n    }\n  }\n\n  // infer default response type\n  if (defaultResponse) {\n    let inferred = false;\n\n    // assume default is intended for success if none exists yet\n    if (!Object.keys(responses.properties).length) {\n      responses.properties.default = defaultResponse.schema;\n      inferred = true;\n    }\n\n    const description = (\n      defaultResponse.schema.description ?? ''\n    ).toLocaleLowerCase();\n    const $ref = (defaultResponse.schema.$ref ?? '').toLocaleLowerCase();\n\n    // TODO: parser - this could be rewritten using regular expressions\n    const successKeywords = ['success'];\n    if (\n      successKeywords.some(\n        (keyword) => description.includes(keyword) || $ref.includes(keyword),\n      )\n    ) {\n      responses.properties.default = defaultResponse.schema;\n      inferred = true;\n    }\n\n    // TODO: parser - this could be rewritten using regular expressions\n    const errorKeywords = ['error', 'problem'];\n    if (\n      errorKeywords.some(\n        (keyword) => description.includes(keyword) || $ref.includes(keyword),\n      )\n    ) {\n      errors.properties.default = defaultResponse.schema;\n      inferred = true;\n    }\n\n    // if no keyword match, assume default schema is intended for error\n    if (!inferred) {\n      errors.properties.default = defaultResponse.schema;\n    }\n  }\n\n  const errorKeys = Object.keys(errors.properties);\n  if (errorKeys.length) {\n    errors.required = errorKeys;\n    result.errors = errors;\n\n    let errorUnion = addItemsToSchema({\n      items: Object.values(errors.properties),\n      mutateSchemaOneItem: true,\n      schema: {},\n    });\n    errorUnion = deduplicateSchema({ schema: errorUnion });\n    if (Object.keys(errorUnion).length && errorUnion.type !== 'unknown') {\n      result.error = errorUnion;\n    }\n  }\n\n  const responseKeys = Object.keys(responses.properties);\n  if (responseKeys.length) {\n    responses.required = responseKeys;\n    result.responses = responses;\n\n    let responseUnion = addItemsToSchema({\n      items: Object.values(responses.properties),\n      mutateSchemaOneItem: true,\n      schema: {},\n    });\n    responseUnion = deduplicateSchema({ schema: responseUnion });\n    if (Object.keys(responseUnion).length && responseUnion.type !== 'unknown') {\n      result.response = responseUnion;\n    }\n  }\n\n  return result;\n};\n","// TODO: symbol should be protected, but needs to be public to satisfy types\nimport type {\n  AnalysisContext,\n  File,\n  FromRef,\n  Language,\n  Node,\n  NodeName,\n  NodeNameSanitizer,\n  NodeRelationship,\n  NodeScope,\n  Ref,\n  Symbol,\n} from '@hey-api/codegen-core';\nimport {\n  fromRef,\n  isNode,\n  isRef,\n  isSymbol,\n  nodeBrand,\n  ref,\n} from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { AccessOptions } from './utils/context';\n\n/**\n * Accepts a value or a readonly array of values of type T.\n */\nexport type MaybeArray<T> = T | ReadonlyArray<T>;\n\n/**\n * Accepts a value or a function returning a value.\n */\nexport type MaybeFunc<T extends (...args: Array<any>) => any> =\n  | T\n  | ReturnType<T>;\n\nexport abstract class TsDsl<T extends ts.Node = ts.Node> implements Node<T> {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  analyze(_: AnalysisContext): void {}\n  clone(): this {\n    const cloned = Object.create(Object.getPrototypeOf(this));\n    Object.assign(cloned, this);\n    return cloned;\n  }\n  exported?: boolean;\n  file?: File;\n  get name(): Node['name'] {\n    return {\n      ...this._name,\n      set: (value) => {\n        this._name = ref(value);\n        if (isSymbol(value)) {\n          value.setNode(this);\n        }\n      },\n      toString: () => (this._name ? this.$name(this._name) : ''),\n    } as Node['name'];\n  }\n  readonly nameSanitizer?: NodeNameSanitizer;\n  language: Language = 'typescript';\n  parent?: Node;\n  root: boolean = false;\n  scope?: NodeScope = 'value';\n  structuralChildren?: Map<TsDsl, NodeRelationship>;\n  structuralParents?: Map<TsDsl, NodeRelationship>;\n  symbol?: Symbol;\n  toAst(): T {\n    return undefined as unknown as T;\n  }\n  readonly '~brand' = nodeBrand;\n\n  /** Access patterns for this node. */\n  toAccessNode?(\n    node: this,\n    options: AccessOptions,\n    ctx: {\n      /** The full chain. */\n      chain: ReadonlyArray<TsDsl>;\n      /** Position in the chain (0 = root). */\n      index: number;\n      /** Is this the leaf node? */\n      isLeaf: boolean;\n      /** Is this the root node? */\n      isRoot: boolean;\n      /** Total length of the chain. */\n      length: number;\n    },\n  ): TsDsl | undefined;\n  /** Branding property to identify the DSL class at runtime. */\n  abstract readonly '~dsl': string & {};\n\n  /** Conditionally applies a callback to this builder. */\n  $if<T extends TsDsl, V, R extends TsDsl = T>(\n    this: T,\n    value: V,\n    ifTrue: (self: T, v: Exclude<V, false | null | undefined>) => R | void,\n    ifFalse?: (self: T, v: Extract<V, false | null | undefined>) => R | void,\n  ): R | T;\n  $if<T extends TsDsl, V, R extends TsDsl = T>(\n    this: T,\n    value: V,\n    ifTrue: (v: Exclude<V, false | null | undefined>) => R | void,\n    ifFalse?: (v: Extract<V, false | null | undefined>) => R | void,\n  ): R | T;\n  $if<T extends TsDsl, V, R extends TsDsl = T>(\n    this: T,\n    value: V,\n    ifTrue: () => R | void,\n    ifFalse?: () => R | void,\n  ): R | T;\n  $if<T extends TsDsl, V, R extends TsDsl = T>(\n    this: T,\n    value: V,\n    ifTrue: any,\n    ifFalse?: any,\n  ): R | T {\n    if (value) {\n      // Try calling with (self, value), then (value), then ()\n      let result: R | void | undefined;\n      try {\n        result = ifTrue?.(this, value as Exclude<V, false | null | undefined>);\n      } catch {\n        // ignore and try other signatures\n      }\n      if (result === undefined) {\n        try {\n          result = ifTrue?.(value as Exclude<V, false | null | undefined>);\n        } catch {\n          // ignore and try zero-arg\n        }\n      }\n      if (result === undefined) {\n        try {\n          result = ifTrue?.();\n        } catch {\n          // swallow\n        }\n      }\n      return (result ?? this) as R | T;\n    }\n    if (ifFalse) {\n      let result: R | void | undefined;\n      try {\n        result = ifFalse?.(this, value as Extract<V, false | null | undefined>);\n      } catch {\n        // ignore\n      }\n      if (result === undefined) {\n        try {\n          result = ifFalse?.(value as Extract<V, false | null | undefined>);\n        } catch {\n          // ignore\n        }\n      }\n      if (result === undefined) {\n        try {\n          result = ifFalse?.();\n        } catch {\n          // ignore\n        }\n      }\n      return (result ?? this) as R | T;\n    }\n    return this;\n  }\n\n  protected $maybeId<T extends string | ts.Expression>(\n    expr: T,\n  ): T extends string ? ts.Identifier : T {\n    return (\n      typeof expr === 'string' ? ts.factory.createIdentifier(expr) : expr\n    ) as T extends string ? ts.Identifier : T;\n  }\n\n  protected $name(name: Ref<NodeName>): string {\n    const value = fromRef(name);\n    if (isSymbol(value)) {\n      try {\n        return value.finalName;\n      } catch {\n        return value.name;\n      }\n    }\n    return String(value);\n  }\n\n  protected $node<I>(value: I): NodeOfMaybe<I> {\n    if (value === undefined) {\n      return undefined as NodeOfMaybe<I>;\n    }\n    // @ts-expect-error\n    if (isRef(value)) value = fromRef(value);\n    if (isSymbol(value)) {\n      return this.$maybeId(value.finalName) as NodeOfMaybe<I>;\n    }\n    if (typeof value === 'string') {\n      return this.$maybeId(value) as NodeOfMaybe<I>;\n    }\n    if (value instanceof Array) {\n      return value.map((item) => {\n        if (isRef(item)) item = fromRef(item);\n        return this.unwrap(item);\n      }) as NodeOfMaybe<I>;\n    }\n    return this.unwrap(value as any) as NodeOfMaybe<I>;\n  }\n\n  protected $type<I>(\n    value: I,\n    args?: ReadonlyArray<ts.TypeNode>,\n  ): TypeOfMaybe<I> {\n    if (value === undefined) {\n      return undefined as TypeOfMaybe<I>;\n    }\n    // @ts-expect-error\n    if (isRef(value)) value = fromRef(value);\n    if (isSymbol(value)) {\n      return ts.factory.createTypeReferenceNode(\n        value.finalName,\n        args,\n      ) as TypeOfMaybe<I>;\n    }\n    if (typeof value === 'string') {\n      return ts.factory.createTypeReferenceNode(value, args) as TypeOfMaybe<I>;\n    }\n    if (typeof value === 'boolean') {\n      const literal = value\n        ? ts.factory.createTrue()\n        : ts.factory.createFalse();\n      return ts.factory.createLiteralTypeNode(literal) as TypeOfMaybe<I>;\n    }\n    if (typeof value === 'number') {\n      return ts.factory.createLiteralTypeNode(\n        ts.factory.createNumericLiteral(value),\n      ) as TypeOfMaybe<I>;\n    }\n    if (value instanceof Array) {\n      return value.map((item) => this.$type(item, args)) as TypeOfMaybe<I>;\n    }\n    return this.unwrap(value as any) as TypeOfMaybe<I>;\n  }\n\n  private _name?: Ref<NodeName>;\n\n  /** Unwraps nested nodes into raw TypeScript AST. */\n  private unwrap<I>(value: I): I extends TsDsl<infer N> ? N : I {\n    return (isNode(value) ? value.toAst() : value) as I extends TsDsl<infer N>\n      ? N\n      : I;\n  }\n}\n\ntype NodeOfMaybe<I> = undefined extends I\n  ? NodeOf<NonNullable<FromRef<I>>> | undefined\n  : NodeOf<FromRef<I>>;\n\ntype NodeOf<I> =\n  I extends ReadonlyArray<infer U>\n    ? ReadonlyArray<U extends TsDsl<infer N> ? N : U>\n    : I extends string\n      ? ts.Expression\n      : I extends TsDsl<infer N>\n        ? N\n        : I extends ts.Node\n          ? I\n          : never;\n\nexport type MaybeTsDsl<T> =\n  T extends TsDsl<infer U>\n    ? U | TsDsl<U>\n    : T extends ts.Node\n      ? T | TsDsl<T>\n      : never;\n\nexport abstract class TypeTsDsl<\n  T extends\n    | ts.LiteralTypeNode\n    | ts.QualifiedName\n    | ts.TypeElement\n    | ts.TypeNode\n    | ts.TypeParameterDeclaration = ts.TypeNode,\n> extends TsDsl<T> {}\n\ntype TypeOfMaybe<I> = undefined extends I\n  ? TypeOf<NonNullable<FromRef<I>>> | undefined\n  : TypeOf<FromRef<I>>;\n\ntype TypeOf<I> =\n  I extends ReadonlyArray<infer U>\n    ? ReadonlyArray<TypeOf<U>>\n    : I extends string\n      ? ts.TypeNode\n      : I extends boolean\n        ? ts.LiteralTypeNode\n        : I extends TsDsl<infer N>\n          ? N\n          : I extends ts.TypeNode\n            ? I\n            : never;\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\n\nconst Mixed = TsDsl<ts.Identifier>;\n\nexport class IdTsDsl extends Mixed {\n  readonly '~dsl' = 'IdTsDsl';\n\n  constructor(name: string) {\n    super();\n    this.name.set(name);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  override toAst() {\n    return ts.factory.createIdentifier(this.name.toString());\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\n\nexport class NewlineTsDsl extends TsDsl<ts.Identifier> {\n  readonly '~dsl' = 'NewlineTsDsl';\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  override toAst(): ts.Identifier {\n    return this.$node(new IdTsDsl('\\n'));\n  }\n}\n","import type {\n  AnalysisContext,\n  Node,\n  NodeName,\n  Ref,\n} from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport type { BaseCtor, MixinCtor } from './types';\n\ntype Arg = NodeName | MaybeTsDsl<ts.Expression>;\n\nexport interface ArgsMethods extends Node {\n  /** Renders the arguments into an array of `Expression`s. */\n  $args(): ReadonlyArray<ts.Expression>;\n  /** Adds a single expression argument. */\n  arg(arg: Arg | undefined): this;\n  /** Adds one or more expression arguments. */\n  args(...args: ReadonlyArray<Arg | undefined>): this;\n}\n\n/**\n * Adds `.arg()` and `.args()` for managing expression arguments in call-like nodes.\n */\nexport function ArgsMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class Args extends Base {\n    protected _args: Array<Ref<Arg>> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      for (const arg of this._args) {\n        ctx.analyze(arg);\n      }\n    }\n\n    protected arg(arg: Arg | undefined): this {\n      if (arg !== undefined) this._args.push(ref(arg));\n      return this;\n    }\n\n    protected args(...args: ReadonlyArray<Arg | undefined>): this {\n      this._args.push(\n        ...args\n          .filter((a): a is NonNullable<typeof a> => a !== undefined)\n          .map((a) => ref(a)),\n      );\n      return this;\n    }\n\n    protected $args(): ReadonlyArray<ts.Expression> {\n      return this.$node(this._args).map((arg) => this.$node(arg));\n    }\n  }\n\n  return Args as unknown as MixinCtor<TBase, ArgsMethods>;\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nconst Mixed = TsDsl<ts.PrefixUnaryExpression>;\n\nexport class PrefixTsDsl extends Mixed {\n  readonly '~dsl' = 'PrefixTsDsl';\n\n  protected _expr?: string | MaybeTsDsl<ts.Expression>;\n  protected _op?: ts.PrefixUnaryOperator;\n\n  constructor(\n    expr?: string | MaybeTsDsl<ts.Expression>,\n    op?: ts.PrefixUnaryOperator,\n  ) {\n    super();\n    this._expr = expr;\n    this._op = op;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._expr);\n  }\n\n  /** Sets the operand (the expression being prefixed). */\n  expr(expr: string | MaybeTsDsl<ts.Expression>): this {\n    this._expr = expr;\n    return this;\n  }\n\n  /** Sets the operator to MinusToken for negation (`-`). */\n  neg(): this {\n    this._op = ts.SyntaxKind.MinusToken;\n    return this;\n  }\n\n  /** Sets the operator to ExclamationToken for logical NOT (`!`). */\n  not(): this {\n    this._op = ts.SyntaxKind.ExclamationToken;\n    return this;\n  }\n\n  /** Sets the operator (e.g. `ts.SyntaxKind.ExclamationToken` for `!`). */\n  op(op: ts.PrefixUnaryOperator): this {\n    this._op = op;\n    return this;\n  }\n\n  override toAst() {\n    if (!this._expr) {\n      throw new Error('Missing expression for prefix unary expression');\n    }\n    if (!this._op) {\n      throw new Error('Missing operator for prefix unary expression');\n    }\n    return ts.factory.createPrefixUnaryExpression(\n      this._op,\n      this.$node(this._expr),\n    );\n  }\n}\n","import type { AsCtor } from '../expr/as';\nimport type { AttrCtor } from '../expr/attr';\nimport type { AwaitCtor } from '../expr/await';\nimport type { CallCtor } from '../expr/call';\nimport type { NewCtor } from '../expr/new';\nimport type { TypeOfExprCtor } from '../expr/typeof';\nimport type { ReturnCtor } from '../stmt/return';\nimport type { TypeExprCtor } from '../type/expr';\nimport type { TypeIdxCtor } from '../type/idx';\nimport type { TypeOperatorCtor } from '../type/operator';\nimport type { TypeQueryCtor } from '../type/query';\n\ntype Ctor = (...args: Array<any>) => any;\n\ntype Factory<T extends Ctor> = {\n  (...args: Parameters<T>): ReturnType<T>;\n  /** Sets the implementation of this factory. */\n  set(fn: T): void;\n};\n\nfunction createFactory<T extends Ctor>(name: string): Factory<T> {\n  let impl: T | undefined;\n\n  const slot = ((...args: Parameters<T>) => {\n    if (!impl) throw new Error(`${name} factory not registered`);\n    return impl(...args);\n  }) as Factory<T>;\n\n  slot.set = (fn: T) => {\n    impl = fn;\n  };\n\n  return slot;\n}\n\nexport const f = {\n  /** Factory for creating `as` type assertion expressions (e.g. `value as Type`). */\n  as: createFactory<AsCtor>('as'),\n\n  /** Factory for creating property access expressions (e.g. `obj.foo`). */\n  attr: createFactory<AttrCtor>('attr'),\n\n  /** Factory for creating await expressions (e.g. `await promise`). */\n  await: createFactory<AwaitCtor>('await'),\n\n  /** Factory for creating function or method call expressions (e.g. `fn(arg)`). */\n  call: createFactory<CallCtor>('call'),\n\n  /** Factory for creating new expressions (e.g. `new ClassName()`). */\n  new: createFactory<NewCtor>('new'),\n\n  /** Factory for creating return statements. */\n  return: createFactory<ReturnCtor>('return'),\n\n  /** Factories for creating type nodes. */\n  type: {\n    /** Factory for creating basic type references or type expressions (e.g. Foo or Foo<T>). */\n    expr: createFactory<TypeExprCtor>('type.expr'),\n\n    /** Factory for creating indexed-access types (e.g. `Foo<T>[K]`). */\n    idx: createFactory<TypeIdxCtor>('type.idx'),\n\n    /** Factory for creating type operator nodes (e.g. `readonly T`, `keyof T`, `unique T`). */\n    operator: createFactory<TypeOperatorCtor>('type.operator'),\n\n    /** Factory for creating type query nodes (e.g. `typeof Foo`). */\n    query: createFactory<TypeQueryCtor>('type.query'),\n  },\n\n  /** Factory for creating `typeof` expressions (e.g. `typeof value`). */\n  typeofExpr: createFactory<TypeOfExprCtor>('typeofExpr'),\n};\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { f } from '../utils/factories';\nimport type { BaseCtor, DropFirst, MixinCtor } from './types';\n\nexport interface AsMethods extends Node {\n  /** Creates an `as` type assertion expression (e.g. `value as Type`). */\n  as(...args: DropFirst<Parameters<typeof f.as>>): ReturnType<typeof f.as>;\n}\n\nexport function AsMixin<T extends ts.Expression, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class As extends Base {\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected as(\n      ...args: DropFirst<Parameters<typeof f.as>>\n    ): ReturnType<typeof f.as> {\n      return f.as(this, ...args);\n    }\n  }\n\n  return As as unknown as MixinCtor<TBase, AsMethods>;\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { PrefixTsDsl } from '../expr/prefix';\nimport { AsMixin } from '../mixins/as';\n\nexport type LiteralValue = string | number | boolean | bigint | null;\n\nconst Mixed = AsMixin(\n  TsDsl<\n    | ts.BigIntLiteral\n    | ts.BooleanLiteral\n    | ts.NullLiteral\n    | ts.NumericLiteral\n    | ts.PrefixUnaryExpression\n    | ts.StringLiteral\n  >,\n);\n\nexport class LiteralTsDsl extends Mixed {\n  readonly '~dsl' = 'LiteralTsDsl';\n\n  protected value: LiteralValue;\n\n  constructor(value: LiteralValue) {\n    super();\n    this.value = value;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  override toAst() {\n    if (typeof this.value === 'boolean') {\n      return this.value ? ts.factory.createTrue() : ts.factory.createFalse();\n    }\n    if (typeof this.value === 'number') {\n      const expr = ts.factory.createNumericLiteral(Math.abs(this.value));\n      return this.value < 0 ? this.$node(new PrefixTsDsl(expr).neg()) : expr;\n    }\n    if (typeof this.value === 'string') {\n      return ts.factory.createStringLiteral(this.value, true);\n    }\n    if (typeof this.value === 'bigint') {\n      return ts.factory.createBigIntLiteral(this.value.toString());\n    }\n    if (this.value === null) {\n      return ts.factory.createNull();\n    }\n    throw new Error(`Unsupported literal: ${String(this.value)}`);\n  }\n}\n","/**\n * Matches characters from the start as long as they're not allowed.\n */\nconst illegalStartCharactersRegExp = /^[^$_\\p{ID_Start}]+/u;\n\n/**\n * Matches string if it contains only digits and optionally decimal point or\n * leading minus sign.\n */\nconst numberRegExp = /^-?\\d+(\\.\\d+)?$/;\n\n/**\n * Javascript identifier regexp pattern retrieved from\n * {@link} https://developer.mozilla.org/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n */\nconst validTypescriptIdentifierRegExp =\n  /^[$_\\p{ID_Start}][$\\u200c\\u200d\\p{ID_Continue}]*$/u;\n\nexport const regexp = {\n  /**\n   * Matches characters from the start as long as they're not allowed.\n   */\n  illegalStartCharacters: illegalStartCharactersRegExp,\n  /**\n   * Matches string if it contains only digits and optionally decimal point or\n   * leading minus sign.\n   */\n  number: numberRegExp,\n  /**\n   * Javascript identifier regexp pattern retrieved from\n   * {@link} https://developer.mozilla.org/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n   */\n  typeScriptIdentifier: validTypescriptIdentifierRegExp,\n};\n","const browserGlobals = [\n  'document',\n  'history',\n  'location',\n  'navigator',\n  'window',\n];\n\nconst javaScriptGlobals = [\n  'console',\n  'Array',\n  'Date',\n  'Error',\n  'Function',\n  'JSON',\n  'Map',\n  'Math',\n  'Object',\n  'Promise',\n  'RegExp',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n];\n\nconst javaScriptKeywords = [\n  'arguments',\n  'async',\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'enum',\n  'eval',\n  'export',\n  'extends',\n  'false',\n  'finally',\n  'for',\n  'from',\n  'function',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'interface',\n  'let',\n  'new',\n  'null',\n  'package',\n  'private',\n  'protected',\n  'public',\n  'return',\n  'static',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n];\n\nconst nodeGlobals = ['global', 'process', 'Buffer'];\n\nconst typeScriptKeywords = [\n  'any',\n  'as',\n  'bigint',\n  'boolean',\n  'namespace',\n  'never',\n  'null',\n  'number',\n  'string',\n  'symbol',\n  'type',\n  'undefined',\n  'unknown',\n  'void',\n];\n\nexport const keywords = {\n  browserGlobals,\n  javaScriptGlobals,\n  javaScriptKeywords,\n  nodeGlobals,\n  typeScriptKeywords,\n};\n","import { keywords } from './keywords';\n\ntype List = ReadonlyArray<string>;\n\nexport class ReservedList {\n  private _array: List;\n  private _set: Set<string>;\n\n  constructor(values: List) {\n    this._array = values;\n    this._set = new Set(values);\n  }\n\n  get '~values'() {\n    return this._set;\n  }\n\n  /**\n   * Updates the reserved list with new values.\n   *\n   * @param values New reserved values or a function that receives the previous\n   * reserved values and returns the new ones.\n   */\n  set(values: List | ((prev: List) => List)): void {\n    const vals = typeof values === 'function' ? values(this._array) : values;\n    this._array = vals;\n    this._set = new Set(vals);\n  }\n}\n\nconst runtimeReserved = new ReservedList([\n  ...keywords.browserGlobals,\n  ...keywords.javaScriptGlobals,\n  ...keywords.javaScriptKeywords,\n  ...keywords.nodeGlobals,\n  ...keywords.typeScriptKeywords,\n]);\n\nconst typeReserved = new ReservedList([\n  ...keywords.javaScriptKeywords,\n  ...keywords.typeScriptKeywords,\n]);\n\n/**\n * Reserved names for identifiers. These names will not be used\n * for variables, functions, classes, or other identifiers in generated code.\n */\nexport const reserved = {\n  /**\n   * Reserved names for runtime identifiers. These names will not be used\n   * for variables, functions, classes, or other runtime identifiers in\n   * generated code.\n   */\n  runtime: runtimeReserved,\n  /**\n   * Reserved names for type identifiers. These names will not be used\n   * for type or interface identifiers in generated code.\n   */\n  type: typeReserved,\n};\n","import type ts from 'typescript';\n\nimport type { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\nimport { LiteralTsDsl } from '../expr/literal';\nimport { regexp } from './regexp';\nimport type { ReservedList } from './reserved';\nimport { reserved } from './reserved';\n\nexport const safeAccessorName = (name: string): string => {\n  regexp.number.lastIndex = 0;\n  if (regexp.number.test(name)) {\n    return name.startsWith('-') ? `'${name}'` : name;\n  }\n\n  regexp.typeScriptIdentifier.lastIndex = 0;\n  if (regexp.typeScriptIdentifier.test(name)) {\n    return name;\n  }\n  return `'${name}'`;\n};\n\nexport const safeMemberName = (\n  name: string,\n): TsDsl<ts.StringLiteral> | IdTsDsl => {\n  regexp.typeScriptIdentifier.lastIndex = 0;\n  if (regexp.typeScriptIdentifier.test(name)) {\n    return new IdTsDsl(name);\n  }\n  return new LiteralTsDsl(name) as TsDsl<ts.StringLiteral>;\n};\n\nexport const safePropName = (\n  name: string,\n): TsDsl<ts.StringLiteral | ts.NumericLiteral> | IdTsDsl => {\n  regexp.number.lastIndex = 0;\n  if (regexp.number.test(name)) {\n    return name.startsWith('-')\n      ? (new LiteralTsDsl(name) as TsDsl<ts.StringLiteral>)\n      : (new LiteralTsDsl(Number(name)) as TsDsl<ts.NumericLiteral>);\n  }\n\n  regexp.typeScriptIdentifier.lastIndex = 0;\n  if (regexp.typeScriptIdentifier.test(name)) {\n    return new IdTsDsl(name);\n  }\n\n  return new LiteralTsDsl(name) as TsDsl<ts.StringLiteral>;\n};\n\nconst safeName = (name: string, reserved: ReservedList): string => {\n  let sanitized = '';\n  let index: number;\n\n  const first = name[0]!;\n  regexp.illegalStartCharacters.lastIndex = 0;\n  if (regexp.illegalStartCharacters.test(first)) {\n    sanitized += '_';\n    index = 0;\n  } else {\n    sanitized += first;\n    index = 1;\n  }\n\n  while (index < name.length) {\n    const char = name[index]!;\n    sanitized += /^[\\u200c\\u200d\\p{ID_Continue}]$/u.test(char) ? char : '_';\n    index += 1;\n  }\n\n  if (reserved['~values'].has(sanitized)) {\n    sanitized = `${sanitized}_`;\n  }\n\n  return sanitized || '_';\n};\n\nexport const safeRuntimeName = (name: string): string =>\n  safeName(name, reserved.runtime);\n\nexport const safeTypeName = (name: string): string =>\n  safeName(name, reserved.type);\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { ArgsMixin } from '../mixins/args';\nimport { safeRuntimeName } from '../utils/name';\n\nconst Mixed = ArgsMixin(TsDsl<ts.Decorator>);\n\nexport class DecoratorTsDsl extends Mixed {\n  readonly '~dsl' = 'DecoratorTsDsl';\n  override readonly nameSanitizer = safeRuntimeName;\n\n  constructor(\n    name: NodeName,\n    ...args: ReadonlyArray<string | MaybeTsDsl<ts.Expression>>\n  ) {\n    super();\n    this.name.set(name);\n    this.args(...args);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n  }\n\n  override toAst() {\n    const target = this.$node(this.name);\n    const args = this.$args();\n    return ts.factory.createDecorator(\n      args.length\n        ? ts.factory.createCallExpression(target, undefined, args)\n        : target,\n    );\n  }\n}\n","import type { AnalysisContext, Node, NodeName } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { DecoratorTsDsl } from '../decl/decorator';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface DecoratorMethods extends Node {\n  /** Renders the decorators into an array of `ts.Decorator`s. */\n  $decorators(): ReadonlyArray<ts.Decorator>;\n  /** Adds a decorator (e.g. `@sealed({ in: 'root' })`). */\n  decorator(\n    name: NodeName | MaybeTsDsl<ts.Expression>,\n    ...args: ReadonlyArray<string | MaybeTsDsl<ts.Expression>>\n  ): this;\n}\n\nexport function DecoratorMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class Decorator extends Base {\n    protected decorators: Array<DecoratorTsDsl> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      for (const decorator of this.decorators) {\n        ctx.analyze(decorator);\n      }\n    }\n\n    protected decorator(\n      name: NodeName,\n      ...args: ReadonlyArray<string | MaybeTsDsl<ts.Expression>>\n    ): this {\n      this.decorators.push(new DecoratorTsDsl(name, ...args));\n      return this;\n    }\n\n    protected $decorators(): ReadonlyArray<ts.Decorator> {\n      return this.$node(this.decorators);\n    }\n  }\n\n  return Decorator as unknown as MixinCtor<TBase, DecoratorMethods>;\n}\n","import type { BindingKind, NodeScope, Symbol } from '@hey-api/codegen-core';\nimport { isSymbol } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { $, TypeScriptRenderer } from '~/ts-dsl';\n\nimport type { TsDsl } from '../base';\nimport type { CallArgs } from '../expr/call';\n\nexport type NodeChain = ReadonlyArray<TsDsl>;\n\nexport interface AccessOptions {\n  /** The access context. */\n  context?: 'example';\n  /** Enable debug mode. */\n  debug?: boolean;\n  /** Transform function for each node in the access chain. */\n  transform?: (node: TsDsl, index: number, chain: NodeChain) => TsDsl;\n}\n\nexport type AccessResult = ReturnType<\n  typeof $.expr | typeof $.attr | typeof $.call | typeof $.new\n>;\n\nexport interface ExampleOptions {\n  /** Import kind for the root node. */\n  importKind?: BindingKind;\n  /** Import name for the root node. */\n  importName?: string;\n  /** Setup to run before calling the example. */\n  importSetup?:\n    | TsDsl<ts.Expression>\n    | ((imp: TsDsl<ts.Expression>) => TsDsl<ts.Expression>);\n  /** Module to import from. */\n  moduleName: string;\n  /** Example request payload. */\n  payload?: CallArgs | CallArgs[number];\n  /** Variable name for setup node. */\n  setupName?: string;\n}\n\nfunction accessChainToNode<T = AccessResult>(accessChain: NodeChain): T {\n  let result!: AccessResult;\n  accessChain.forEach((node, index) => {\n    if (index === 0) {\n      // assume correct node\n      result = node as typeof result;\n    } else {\n      result = result.attr(node.name);\n    }\n  });\n  return result as T;\n}\n\nfunction getAccessChainForNode(node: TsDsl): NodeChain {\n  const structuralChain = [...getStructuralChainForNode(node, new Set())];\n  const accessChain = structuralToAccessChain(structuralChain);\n  if (accessChain.length === 0) {\n    // I _think_ this should not happen, but it does and this fix works for now.\n    // I assume this will cause issues with imports in some cases, investigate\n    // when it actually happens.\n    return [node.clone()];\n  }\n  return accessChain.map((node) => node.clone());\n}\n\nfunction getScope(node: TsDsl): NodeScope {\n  return node.scope ?? 'value';\n}\n\nfunction getStructuralChainForNode(\n  node: TsDsl,\n  visited: Set<TsDsl>,\n): NodeChain {\n  if (visited.has(node)) return [];\n  visited.add(node);\n\n  if (isStopNode(node)) return [];\n\n  if (node.structuralParents) {\n    for (const [parent] of node.structuralParents) {\n      if (getScope(parent) !== getScope(node)) continue;\n\n      const chain = getStructuralChainForNode(parent, visited);\n      if (chain.length > 0) return [...chain, node];\n    }\n  }\n\n  if (!node.root) return [];\n\n  return [node];\n}\n\nfunction isAccessorNode(node: TsDsl): boolean {\n  return (\n    node['~dsl'] === 'FieldTsDsl' ||\n    node['~dsl'] === 'GetterTsDsl' ||\n    node['~dsl'] === 'MethodTsDsl'\n  );\n}\n\nfunction isStopNode(node: TsDsl): boolean {\n  return node['~dsl'] === 'FuncTsDsl' || node['~dsl'] === 'TemplateTsDsl';\n}\n\n/**\n * Fold a structural chain to an access chain by removing\n * non-accessor nodes.\n */\nfunction structuralToAccessChain(structuralChain: NodeChain): NodeChain {\n  const accessChain: Array<TsDsl> = [];\n  structuralChain.forEach((node, index) => {\n    // assume first node is always included\n    if (index === 0) {\n      accessChain.push(node);\n    } else if (isAccessorNode(node)) {\n      accessChain.push(node);\n    }\n  });\n  return accessChain;\n}\n\nfunction transformAccessChain(\n  accessChain: NodeChain,\n  options: AccessOptions = {},\n): NodeChain {\n  return accessChain.map((node, index) => {\n    const transformedNode = options.transform?.(node, index, accessChain);\n    if (transformedNode) return transformedNode;\n    const accessNode = node.toAccessNode?.(node, options, {\n      chain: accessChain,\n      index,\n      isLeaf: index === accessChain.length - 1,\n      isRoot: index === 0,\n      length: accessChain.length,\n    });\n    if (accessNode) return accessNode;\n    if (index === 0) {\n      if (node['~dsl'] === 'ClassTsDsl') {\n        const nextNode = accessChain[index + 1];\n        if (nextNode && isAccessorNode(nextNode)) {\n          if ((nextNode as ReturnType<typeof $.field>).hasModifier('static')) {\n            return $(node.name);\n          }\n        }\n        return $.new(node.name).args();\n      }\n      return $(node.name);\n    }\n    return node;\n  });\n}\n\nexport class TsDslContext {\n  /**\n   * Build an expression for accessing the node.\n   *\n   * @param node - The node or symbol to build access for\n   * @param options - Access options\n   * @returns Expression for accessing the node\n   *\n   * @example\n   * ```ts\n   * ctx.access(node); // ‚Üí Expression for accessing the node\n   * ```\n   */\n  access<T = AccessResult>(\n    node: TsDsl | Symbol<TsDsl>,\n    options?: AccessOptions,\n  ): T {\n    const n = isSymbol(node) ? node.node : node;\n    if (!n) {\n      throw new Error(`Symbol ${node.name} is not resolved to a node.`);\n    }\n    const accessChain = getAccessChainForNode(n);\n    const finalChain = transformAccessChain(accessChain, options);\n    return accessChainToNode<T>(finalChain);\n  }\n\n  /**\n   * Build an example.\n   *\n   * @param node - The node to generate an example for\n   * @param options - Example options\n   * @returns Full example string\n   *\n   * @example\n   * ```ts\n   * ctx.example(node, { moduleName: 'my-sdk' }); // ‚Üí Full example string\n   * ```\n   */\n  example(\n    node: TsDsl,\n    options: ExampleOptions | undefined,\n    astOptions?: Parameters<typeof TypeScriptRenderer.astToString>[0],\n  ): string {\n    if (astOptions) {\n      return TypeScriptRenderer.astToString(astOptions);\n    }\n\n    if (!options) {\n      throw new Error('Example options are required.');\n    }\n\n    const accessChain = getAccessChainForNode(node);\n    if (options.importName) {\n      accessChain[0]!.name.set(options.importName);\n    }\n    const importNode = $(accessChain[0]!.name.toString()); // must store name before transform\n    const finalChain = transformAccessChain(accessChain, {\n      context: 'example',\n    });\n\n    const setupNode = options.importSetup\n      ? typeof options.importSetup === 'function'\n        ? options.importSetup(importNode)\n        : options.importSetup\n      : (finalChain[0]! as TsDsl<ts.Expression>);\n    const setupName = options.setupName;\n    const payload =\n      options.payload instanceof Array\n        ? options.payload\n        : options.payload\n          ? [options.payload]\n          : [];\n\n    let nodes: Array<TsDsl> = [];\n    if (setupName) {\n      nodes = [\n        $.const(setupName).assign(setupNode),\n        accessChainToNode([$(setupName), ...finalChain.slice(1)]).call(\n          ...payload,\n        ),\n      ];\n    } else {\n      nodes = [\n        accessChainToNode([setupNode, ...finalChain.slice(1)]).call(...payload),\n      ];\n    }\n\n    const localName = importNode.name.toString();\n    return TypeScriptRenderer.astToString({\n      imports: [\n        [\n          {\n            imports:\n              !options.importKind || options.importKind === 'named'\n                ? [\n                    {\n                      isTypeOnly: false,\n                      localName,\n                      sourceName: localName,\n                    },\n                  ]\n                : [],\n            isTypeOnly: false,\n            kind: options.importKind ?? 'named',\n            localName: options.importKind !== 'named' ? localName : undefined,\n            modulePath: options.moduleName,\n          },\n        ],\n      ],\n      nodes,\n      trailingNewline: false,\n    });\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeArray } from '../base';\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\nimport { TsDslContext } from '../utils/context';\n\ntype DocMaybeLazy<T> = ((ctx: TsDslContext) => T) | T;\nexport type DocFn = (d: DocTsDsl) => void;\nexport type DocLines = DocMaybeLazy<MaybeArray<string>>;\n\nexport class DocTsDsl extends TsDsl<ts.Node> {\n  readonly '~dsl' = 'DocTsDsl';\n\n  protected _lines: Array<DocLines> = [];\n\n  constructor(lines?: DocLines, fn?: DocFn) {\n    super();\n    if (lines) this.add(lines);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  add(lines: DocLines): this {\n    this._lines.push(lines);\n    return this;\n  }\n\n  apply<T extends ts.Node>(node: T): T {\n    const ctx = new TsDslContext();\n    const lines = this._lines.reduce((lines: Array<string>, line: DocLines) => {\n      if (typeof line === 'function') line = line(ctx);\n      for (const l of typeof line === 'string' ? [line] : line) {\n        if (l || l === '') lines.push(l);\n      }\n      return lines;\n    }, []);\n    if (!lines.length) return node;\n\n    const jsdocTexts = lines.map((line) =>\n      ts.factory.createJSDocText(`${line}\\n`),\n    );\n\n    const jsdoc = ts.factory.createJSDocComment(\n      ts.factory.createNodeArray(jsdocTexts),\n      undefined,\n    );\n\n    const cleanedJsdoc = ts\n      .createPrinter()\n      .printNode(\n        ts.EmitHint.Unspecified,\n        jsdoc,\n        node.getSourceFile?.() ??\n          ts.createSourceFile('', '', ts.ScriptTarget.Latest),\n      )\n      .replace('/*', '')\n      .replace('*  */', '');\n\n    ts.addSyntheticLeadingComment(\n      node,\n      ts.SyntaxKind.MultiLineCommentTrivia,\n      cleanedJsdoc,\n      true,\n    );\n\n    return node;\n  }\n\n  override toAst(): ts.Node {\n    // this class does not build a standalone node;\n    // it modifies other nodes via `apply()`.\n    // Return a dummy comment node for compliance.\n    return this.$node(new IdTsDsl(''));\n  }\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { DocFn, DocLines } from '../layout/doc';\nimport { DocTsDsl } from '../layout/doc';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface DocMethods extends Node {\n  $docs<T extends ts.Node>(node: T): T;\n  doc(lines?: DocLines, fn?: DocFn): this;\n}\n\nexport function DocMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class Doc extends Base {\n    private _doc?: DocTsDsl;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected doc(lines?: DocLines, fn?: DocFn): this {\n      this._doc = new DocTsDsl(lines, fn);\n      return this;\n    }\n\n    protected $docs<T extends ts.Node>(node: T): T {\n      return this._doc ? this._doc.apply(node) : node;\n    }\n  }\n\n  return Doc as unknown as MixinCtor<TBase, DocMethods>;\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport type Modifiers = {\n  /**\n   * Checks if the specified modifier is present.\n   *\n   * @param modifier - The modifier to check.\n   * @returns True if the modifier is present, false otherwise.\n   */\n  hasModifier(modifier: Modifier): boolean;\n  modifiers: Array<ts.Modifier>;\n};\n\ntype Modifier =\n  | 'abstract'\n  | 'async'\n  | 'const'\n  | 'declare'\n  | 'default'\n  | 'export'\n  | 'override'\n  | 'private'\n  | 'protected'\n  | 'public'\n  | 'readonly'\n  | 'static';\n\nexport interface ModifierMethods extends Modifiers {\n  /**\n   * Adds a modifier of the specified kind to the modifiers list if the condition is true.\n   *\n   * @param modifier - The modifier to add.\n   * @param condition - Whether to add the modifier.\n   * @returns The parent node for chaining.\n   */\n  _m(modifier: Modifier, condition: boolean): this;\n}\n\nfunction modifierToKind(modifier: Modifier): ts.ModifierSyntaxKind {\n  switch (modifier) {\n    case 'abstract':\n      return ts.SyntaxKind.AbstractKeyword;\n    case 'async':\n      return ts.SyntaxKind.AsyncKeyword;\n    case 'const':\n      return ts.SyntaxKind.ConstKeyword;\n    case 'declare':\n      return ts.SyntaxKind.DeclareKeyword;\n    case 'default':\n      return ts.SyntaxKind.DefaultKeyword;\n    case 'export':\n      return ts.SyntaxKind.ExportKeyword;\n    case 'override':\n      return ts.SyntaxKind.OverrideKeyword;\n    case 'private':\n      return ts.SyntaxKind.PrivateKeyword;\n    case 'protected':\n      return ts.SyntaxKind.ProtectedKeyword;\n    case 'public':\n      return ts.SyntaxKind.PublicKeyword;\n    case 'readonly':\n      return ts.SyntaxKind.ReadonlyKeyword;\n    case 'static':\n      return ts.SyntaxKind.StaticKeyword;\n  }\n}\n\nfunction ModifiersMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class Modifiers extends Base {\n    protected modifiers: Array<ts.Modifier> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected hasModifier(modifier: Modifier): boolean {\n      const kind = modifierToKind(modifier);\n      return Boolean(this.modifiers.find((mod) => mod.kind === kind));\n    }\n\n    protected _m(modifier: Modifier, condition: boolean): this {\n      if (condition) {\n        const kind = modifierToKind(modifier);\n        this.modifiers.push(ts.factory.createModifier(kind));\n      }\n      return this;\n    }\n  }\n\n  return Modifiers as unknown as MixinCtor<TBase, ModifierMethods>;\n}\n\nexport interface AbstractMethods extends Modifiers {\n  /**\n   * Adds the `abstract` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  abstract(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds an `abstract` modifier to a node.\n */\nexport function AbstractMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Abstract extends Mixed {\n    protected abstract(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('abstract', cond);\n    }\n  }\n\n  return Abstract as unknown as MixinCtor<TBase, AbstractMethods>;\n}\n\nexport interface AsyncMethods extends Modifiers {\n  /**\n   * Adds the `async` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  async(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds an `async` modifier to a node.\n */\nexport function AsyncMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Async extends Mixed {\n    protected async(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('async', cond);\n    }\n  }\n\n  return Async as unknown as MixinCtor<TBase, AsyncMethods>;\n}\n\nexport interface ConstMethods extends Modifiers {\n  /**\n   * Adds the `const` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  const(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `const` modifier to a node.\n */\nexport function ConstMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Const extends Mixed {\n    protected const(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('const', cond);\n    }\n  }\n\n  return Const as unknown as MixinCtor<TBase, ConstMethods>;\n}\n\nexport interface DeclareMethods extends Modifiers {\n  /**\n   * Adds the `declare` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  declare(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `declare` modifier to a node.\n */\nexport function DeclareMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Declare extends Mixed {\n    protected declare(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('declare', cond);\n    }\n  }\n\n  return Declare as unknown as MixinCtor<TBase, DeclareMethods>;\n}\n\nexport interface DefaultMethods extends Modifiers {\n  /**\n   * Adds the `default` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  default(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `default` modifier to a node.\n */\nexport function DefaultMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Default extends Mixed {\n    /**\n     * Adds the `default` keyword modifier if the condition is true.\n     *\n     * @param condition - Whether to add the modifier (default: true).\n     * @returns The target object for chaining.\n     */\n    protected default(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('default', cond);\n    }\n  }\n\n  return Default as unknown as MixinCtor<TBase, DefaultMethods>;\n}\n\nexport interface ExportMethods extends Modifiers {\n  /**\n   * Adds the `export` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  export(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds an `export` modifier to a node.\n */\nexport function ExportMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Export extends Mixed {\n    /**\n     * Adds the `export` keyword modifier if the condition is true.\n     *\n     * @param condition - Whether to add the modifier (default: true).\n     * @returns The target object for chaining.\n     */\n    protected export(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      this.exported = cond;\n      // TODO: remove this side-effect once planner handles exported flag\n      if (this.symbol) this.symbol.setExported(cond);\n      return this._m('export', cond);\n    }\n  }\n\n  return Export as unknown as MixinCtor<TBase, ExportMethods>;\n}\n\nexport interface OverrideMethods extends Modifiers {\n  /**\n   * Adds the `override` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  override(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds an `override` modifier to a node.\n */\nexport function OverrideMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Override extends Mixed {\n    protected override(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('override', cond);\n    }\n  }\n\n  return Override as unknown as MixinCtor<TBase, OverrideMethods>;\n}\n\nexport interface PrivateMethods extends Modifiers {\n  /**\n   * Adds the `private` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  private(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `private` modifier to a node.\n */\nexport function PrivateMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Private extends Mixed {\n    protected private(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('private', cond);\n    }\n  }\n\n  return Private as unknown as MixinCtor<TBase, PrivateMethods>;\n}\n\nexport interface ProtectedMethods extends Modifiers {\n  /**\n   * Adds the `protected` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  protected(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `protected` modifier to a node.\n */\nexport function ProtectedMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Protected extends Mixed {\n    protected protected(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('protected', cond);\n    }\n  }\n\n  return Protected as unknown as MixinCtor<TBase, ProtectedMethods>;\n}\n\nexport interface PublicMethods extends Modifiers {\n  /**\n   * Adds the `public` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  public(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `public` modifier to a node.\n */\nexport function PublicMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Public extends Mixed {\n    protected public(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('public', cond);\n    }\n  }\n\n  return Public as unknown as MixinCtor<TBase, PublicMethods>;\n}\n\nexport interface ReadonlyMethods extends Modifiers {\n  /**\n   * Adds the `readonly` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  readonly(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `readonly` modifier to a node.\n */\nexport function ReadonlyMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Readonly extends Mixed {\n    protected readonly(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('readonly', cond);\n    }\n  }\n\n  return Readonly as unknown as MixinCtor<TBase, ReadonlyMethods>;\n}\n\nexport interface StaticMethods extends Modifiers {\n  /**\n   * Adds the `static` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  static(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `static` modifier to a node.\n */\nexport function StaticMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Static extends Mixed {\n    protected static(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('static', cond);\n    }\n  }\n\n  return Static as unknown as MixinCtor<TBase, StaticMethods>;\n}\n","import type {\n  AnalysisContext,\n  NodeName,\n  NodeScope,\n  Ref,\n} from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nexport type TypeParamExpr = NodeName | boolean | MaybeTsDsl<TypeTsDsl>;\n\nconst Mixed = TsDsl<ts.TypeParameterDeclaration>;\n\nexport class TypeParamTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeParamTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected constraint?: Ref<TypeParamExpr>;\n  protected defaultValue?: Ref<TypeParamExpr>;\n\n  constructor(name?: NodeName, fn?: (name: TypeParamTsDsl) => void) {\n    super();\n    if (name) this.name.set(name);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n    ctx.analyze(this.constraint);\n    ctx.analyze(this.defaultValue);\n  }\n\n  default(value: TypeParamExpr): this {\n    this.defaultValue = ref(value);\n    return this;\n  }\n\n  extends(constraint: TypeParamExpr): this {\n    this.constraint = ref(constraint);\n    return this;\n  }\n\n  override toAst() {\n    const name = this.name.toString();\n    if (!name) throw new Error('Missing type name');\n    return ts.factory.createTypeParameterDeclaration(\n      undefined,\n      this.$node(this.name) as ts.Identifier,\n      this.$type(this.constraint),\n      this.$type(this.defaultValue),\n    );\n  }\n}\n","import type { AnalysisContext, Node, NodeName } from '@hey-api/codegen-core';\nimport { isRef, isSymbol } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TypeParamTsDsl } from '../type/param';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface TypeParamsMethods extends Node {\n  /** Returns the type parameters as an array of ts.TypeParameterDeclaration nodes. */\n  $generics(): ReadonlyArray<ts.TypeParameterDeclaration> | undefined;\n  /** Adds a single type parameter (e.g. `T` in `Array<T>`). */\n  generic(...args: ConstructorParameters<typeof TypeParamTsDsl>): this;\n  /** Adds type parameters (e.g. `Map<string, T>`). */\n  generics(...args: ReadonlyArray<NodeName | MaybeTsDsl<TypeParamTsDsl>>): this;\n}\n\nexport function TypeParamsMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class TypeParams extends Base {\n    protected _generics: Array<MaybeTsDsl<TypeParamTsDsl>> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      for (const g of this._generics) {\n        ctx.analyze(g);\n      }\n    }\n\n    protected generic(\n      ...args: ConstructorParameters<typeof TypeParamTsDsl>\n    ): this {\n      const g = new TypeParamTsDsl(...args);\n      this._generics.push(g);\n      return this;\n    }\n\n    protected generics(\n      ...args: ReadonlyArray<NodeName | MaybeTsDsl<TypeParamTsDsl>>\n    ): this {\n      for (let arg of args) {\n        if (\n          typeof arg === 'string' ||\n          typeof arg === 'number' ||\n          isSymbol(arg) ||\n          isRef(arg)\n        ) {\n          arg = new TypeParamTsDsl(arg);\n        }\n        this._generics.push(arg);\n      }\n      return this;\n    }\n\n    protected $generics():\n      | ReadonlyArray<ts.TypeParameterDeclaration>\n      | undefined {\n      return this.$node(this._generics);\n    }\n  }\n\n  return TypeParams as unknown as MixinCtor<TBase, TypeParamsMethods>;\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface OptionalMethods extends Node {\n  _optional?: boolean;\n  /** Marks the node as optional when the condition is true. */\n  optional(condition?: boolean): this;\n  /** Marks the node as required when the condition is true. */\n  required(condition?: boolean): this;\n}\n\nexport function OptionalMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class Optional extends Base {\n    protected _optional?: boolean;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected optional(condition?: boolean): this {\n      this._optional = arguments.length === 0 ? true : Boolean(condition);\n      return this;\n    }\n\n    protected required(condition?: boolean): this {\n      this._optional = arguments.length === 0 ? false : !condition;\n      return this;\n    }\n  }\n\n  return Optional as unknown as MixinCtor<TBase, OptionalMethods>;\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport type ValueExpr = string | MaybeTsDsl<ts.Expression>;\n\nexport interface ValueMethods extends Node {\n  $value(): ts.Expression | undefined;\n  /** Sets the initializer expression (e.g. `= expr`). */\n  assign(expr: ValueExpr): this;\n}\n\nexport function ValueMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class Value extends Base {\n    protected value?: ValueExpr;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      ctx.analyze(this.value);\n    }\n\n    protected assign(expr: ValueExpr): this {\n      this.value = expr;\n      return this;\n    }\n\n    protected $value(): ts.Expression | undefined {\n      return this.$node(this.value);\n    }\n  }\n\n  return Value as unknown as MixinCtor<TBase, ValueMethods>;\n}\n","import ts from 'typescript';\n\nimport { TsDsl } from './base';\n\nexport class TokenTsDsl<K extends ts.SyntaxKind = never> extends TsDsl<\n  ts.Token<K>\n> {\n  readonly '~dsl' = 'TokenTsDsl';\n\n  protected _kind?: K;\n\n  /** Sets the token kind */\n  kind(kind: K): this {\n    this._kind = kind;\n    return this;\n  }\n\n  /** Creates `-` */\n  minus(): TokenTsDsl<ts.SyntaxKind.MinusToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.MinusToken>).kind(\n      ts.SyntaxKind.MinusToken,\n    );\n  }\n\n  /** Creates `?` (optional) */\n  optional(): TokenTsDsl<ts.SyntaxKind.QuestionToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.QuestionToken>).kind(\n      ts.SyntaxKind.QuestionToken,\n    );\n  }\n\n  /** Creates `+` */\n  plus(): TokenTsDsl<ts.SyntaxKind.PlusToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.PlusToken>).kind(\n      ts.SyntaxKind.PlusToken,\n    );\n  }\n\n  /** Creates `?.` (optional chaining token) */\n  questionDot(): TokenTsDsl<ts.SyntaxKind.QuestionDotToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.QuestionDotToken>).kind(\n      ts.SyntaxKind.QuestionDotToken,\n    );\n  }\n\n  /** Creates `readonly` */\n  readonly(): TokenTsDsl<ts.SyntaxKind.ReadonlyKeyword> {\n    return (this as TokenTsDsl<ts.SyntaxKind.ReadonlyKeyword>).kind(\n      ts.SyntaxKind.ReadonlyKeyword,\n    );\n  }\n\n  /** Creates `...` (spread / rest) */\n  spread(): TokenTsDsl<ts.SyntaxKind.DotDotDotToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.DotDotDotToken>).kind(\n      ts.SyntaxKind.DotDotDotToken,\n    );\n  }\n\n  override toAst(): ts.Token<K> {\n    if (!this._kind) {\n      throw new Error(`Token missing \\`.kind(kind)\\``);\n    }\n    // @ts-expect-error\n    return ts.factory.createToken(this._kind);\n  }\n}\n","import type {\n  AnalysisContext,\n  Node,\n  NodeName,\n  Ref,\n} from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport type { BaseCtor, MixinCtor } from './types';\n\ntype Arg = NodeName | MaybeTsDsl<TypeTsDsl>;\n\nexport interface TypeArgsMethods extends Node {\n  /** Returns the type arguments as an array of ts.TypeNode nodes. */\n  $generics(): ReadonlyArray<ts.TypeNode> | undefined;\n  /** Adds a single type argument (e.g. `string` in `Foo<string>`). */\n  generic(arg: Arg): this;\n  /** Adds type arguments (e.g. `Map<string, number>`). */\n  generics(...args: ReadonlyArray<Arg>): this;\n}\n\nexport function TypeArgsMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class TypeArgs extends Base {\n    protected _generics: Array<Ref<Arg>> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      for (const g of this._generics) {\n        ctx.analyze(g);\n      }\n    }\n\n    protected generic(arg: Arg): this {\n      this._generics.push(ref(arg));\n      return this;\n    }\n\n    protected generics(...args: ReadonlyArray<Arg>): this {\n      this._generics.push(...args.map((a) => ref(a)));\n      return this;\n    }\n\n    protected $generics(): ReadonlyArray<ts.TypeNode> | undefined {\n      return this.$type(this._generics);\n    }\n  }\n\n  return TypeArgs as unknown as MixinCtor<TBase, TypeArgsMethods>;\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport { f } from '../utils/factories';\nimport type { BaseCtor, DropFirst, MixinCtor } from './types';\n\nexport interface TypeExprMethods extends Node {\n  /** Creates an indexed-access type (e.g. `Foo<T>[K]`). */\n  idx(\n    this: Parameters<typeof f.type.idx>[0],\n    ...args: DropFirst<Parameters<typeof f.type.idx>>\n  ): ReturnType<typeof f.type.idx>;\n  /** Shorthand: builds `keyof T`. */\n  keyof(this: MaybeTsDsl<TypeTsDsl>): ReturnType<typeof f.type.operator>;\n  /** Shorthand: builds `readonly T`. */\n  readonly(this: MaybeTsDsl<TypeTsDsl>): ReturnType<typeof f.type.operator>;\n  /** Create a TypeExpr node representing ReturnType<this>. */\n  returnType(\n    this: Parameters<typeof f.type.query>[0],\n    ...args: DropFirst<Parameters<typeof f.type.query>>\n  ): ReturnType<typeof f.type.expr>;\n  /** Create a TypeOfExpr node representing typeof this. */\n  typeofExpr(\n    this: Parameters<typeof f.typeofExpr>[0],\n    ...args: DropFirst<Parameters<typeof f.typeofExpr>>\n  ): ReturnType<typeof f.typeofExpr>;\n  /** Create a TypeQuery node representing typeof this. */\n  typeofType(\n    this: Parameters<typeof f.type.query>[0],\n    ...args: DropFirst<Parameters<typeof f.type.query>>\n  ): ReturnType<typeof f.type.query>;\n  /** Shorthand: builds `unique T`. */\n  unique(this: MaybeTsDsl<TypeTsDsl>): ReturnType<typeof f.type.operator>;\n}\n\nexport function TypeExprMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class TypeExpr extends Base {\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected idx(\n      this: Parameters<typeof f.type.idx>[0],\n      ...args: DropFirst<Parameters<typeof f.type.idx>>\n    ): ReturnType<typeof f.type.idx> {\n      return f.type.idx(this, ...args);\n    }\n\n    protected keyof(this: TypeTsDsl): ReturnType<typeof f.type.operator> {\n      return f.type.operator().keyof(this);\n    }\n\n    protected readonly(this: TypeTsDsl): ReturnType<typeof f.type.operator> {\n      return f.type.operator().readonly(this);\n    }\n\n    protected returnType(\n      this: Parameters<typeof f.type.query>[0],\n      ...args: DropFirst<Parameters<typeof f.type.query>>\n    ): ReturnType<typeof f.type.expr> {\n      return f.type.expr('ReturnType').generic(f.type.query(this, ...args));\n    }\n\n    protected typeofExpr(\n      this: Parameters<typeof f.typeofExpr>[0],\n      ...args: DropFirst<Parameters<typeof f.typeofExpr>>\n    ): ReturnType<typeof f.typeofExpr> {\n      return f.typeofExpr(this, ...args);\n    }\n\n    protected typeofType(\n      this: Parameters<typeof f.type.query>[0],\n      ...args: DropFirst<Parameters<typeof f.type.query>>\n    ): ReturnType<typeof f.type.query> {\n      return f.type.query(this, ...args);\n    }\n\n    protected unique(this: TypeTsDsl): ReturnType<typeof f.type.operator> {\n      return f.type.operator().unique(this);\n    }\n  }\n\n  return TypeExpr as unknown as MixinCtor<TBase, TypeExprMethods>;\n}\n","import type {\n  AnalysisContext,\n  NodeName,\n  NodeScope,\n  Ref,\n} from '@hey-api/codegen-core';\nimport { isRef, ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { TypeExprMixin } from '../mixins/type-expr';\n\ntype Base = NodeName | MaybeTsDsl<ts.EntityName>;\ntype Right = NodeName | ts.Identifier;\n\nconst Mixed = TypeExprMixin(TsDsl<ts.QualifiedName>);\n\nexport class TypeAttrTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeAttrTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _base?: Ref<Base>;\n  protected _right!: Ref<Right>;\n\n  constructor(base: Base | Ref<Base>, right: string | ts.Identifier);\n  constructor(right: Right);\n  constructor(base: Base | Ref<Base>, right?: Right) {\n    super();\n    if (right) {\n      this.base(base);\n      this.right(right);\n    } else {\n      this.base();\n      this.right(base as Right);\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._base);\n    ctx.analyze(this._right);\n  }\n\n  base(base?: Base | Ref<Base>): this {\n    if (isRef(base)) {\n      this._base = base;\n    } else {\n      this._base = base ? ref(base) : undefined;\n    }\n    return this;\n  }\n\n  right(right: Right): this {\n    this._right = ref(right);\n    return this;\n  }\n\n  override toAst() {\n    if (!this._base) {\n      throw new Error('TypeAttrTsDsl: missing base for qualified name');\n    }\n    const left = this.$node(this._base);\n    if (!ts.isEntityName(left)) {\n      throw new Error('TypeAttrTsDsl: base must be an EntityName');\n    }\n    return ts.factory.createQualifiedName(\n      left,\n      this.$node(this._right) as ts.Identifier,\n    );\n  }\n}\n","import type {\n  AnalysisContext,\n  NodeName,\n  NodeScope,\n  Ref,\n} from '@hey-api/codegen-core';\nimport { isNode, ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { TypeArgsMixin } from '../mixins/type-args';\nimport { TypeExprMixin } from '../mixins/type-expr';\nimport { f } from '../utils/factories';\nimport { TypeAttrTsDsl } from './attr';\n\nexport type TypeExprExpr = NodeName | TypeAttrTsDsl;\nexport type TypeExprFn = (t: TypeExprTsDsl) => void;\nexport type TypeExprCtor = (\n  nameOrFn?: NodeName | TypeExprFn,\n  fn?: TypeExprFn,\n) => TypeExprTsDsl;\n\nconst Mixed = TypeArgsMixin(TypeExprMixin(TsDsl<ts.TypeReferenceNode>));\n\nexport class TypeExprTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeExprTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _exprInput?: Ref<TypeExprExpr>;\n\n  constructor();\n  constructor(fn: TypeExprFn);\n  constructor(name: NodeName);\n  constructor(name: NodeName, fn?: TypeExprFn);\n  constructor(name?: NodeName | TypeExprFn, fn?: TypeExprFn) {\n    super();\n    if (typeof name === 'function') {\n      name(this);\n    } else {\n      this._exprInput = name ? ref(name) : undefined;\n      fn?.(this);\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._exprInput);\n  }\n\n  /** Accesses a nested type (e.g. `Foo.Bar`). */\n  attr(right: string | ts.Identifier | TypeAttrTsDsl): this {\n    this._exprInput = isNode(right)\n      ? ref(right.base(this._exprInput))\n      : ref(new TypeAttrTsDsl(this._exprInput!, right));\n    return this;\n  }\n\n  override toAst() {\n    if (!this._exprInput) throw new Error('TypeExpr must have an expression');\n    return ts.factory.createTypeReferenceNode(\n      this.$type(this._exprInput) as ts.EntityName,\n      this.$generics(),\n    );\n  }\n}\n\nf.type.expr.set(\n  (...args) =>\n    new TypeExprTsDsl(...(args as ConstructorParameters<typeof TypeExprTsDsl>)),\n);\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl, TypeTsDsl } from '../base';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  ReadonlyMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { OptionalMixin } from '../mixins/optional';\nimport { ValueMixin } from '../mixins/value';\nimport { TokenTsDsl } from '../token';\nimport { TypeExprTsDsl } from '../type/expr';\nimport { safeAccessorName } from '../utils/name';\n\nexport type FieldType = NodeName | TypeTsDsl;\n\nconst Mixed = DecoratorMixin(\n  DocMixin(\n    OptionalMixin(\n      PrivateMixin(\n        ProtectedMixin(\n          PublicMixin(\n            ReadonlyMixin(\n              StaticMixin(ValueMixin(TsDsl<ts.PropertyDeclaration>)),\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n\nexport class FieldTsDsl extends Mixed {\n  readonly '~dsl' = 'FieldTsDsl';\n  override readonly nameSanitizer = safeAccessorName;\n\n  protected _type?: TypeTsDsl;\n\n  constructor(name: NodeName, fn?: (f: FieldTsDsl) => void) {\n    super();\n    this.name.set(name);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n    ctx.analyze(this._type);\n  }\n\n  /** Sets the field type. */\n  type(type: FieldType): this {\n    this._type = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n    return this;\n  }\n\n  override toAst() {\n    const node = ts.factory.createPropertyDeclaration(\n      [...this.$decorators(), ...this.modifiers],\n      this.$node(this.name) as ts.PropertyName,\n      this._optional ? this.$node(new TokenTsDsl().optional()) : undefined,\n      this.$type(this._type),\n      this.$value(),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\n\nconst Mixed = TsDsl<ts.Statement>;\n\nexport class StmtTsDsl extends Mixed {\n  readonly '~dsl' = 'StmtTsDsl';\n\n  protected _inner: ts.Expression | ts.Statement | TsDsl<any>;\n\n  constructor(inner: ts.Expression | ts.Statement | TsDsl<any>) {\n    super();\n    this._inner = inner;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._inner);\n  }\n\n  override toAst() {\n    const node = this.$node(this._inner);\n    return ts.isStatement(node)\n      ? node\n      : ts.factory.createExpressionStatement(node);\n  }\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { StmtTsDsl } from '../stmt/stmt';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport type DoExpr = MaybeTsDsl<ts.Expression | ts.Statement>;\n\nexport interface DoMethods extends Node {\n  /** Renders the collected `.do()` calls into an array of `Statement` nodes. */\n  $do(): ReadonlyArray<ts.Statement>;\n  _do: Array<DoExpr>;\n  /** Adds one or more expressions/statements to the body. */\n  do(...items: ReadonlyArray<DoExpr>): this;\n}\n\n/**\n * Adds `.do()` for appending statements or expressions to a body.\n */\nexport function DoMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class Do extends Base {\n    protected _do: Array<DoExpr> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      ctx.pushScope();\n      try {\n        for (const item of this._do) {\n          ctx.analyze(item);\n        }\n      } finally {\n        ctx.popScope();\n      }\n    }\n\n    protected do(...items: ReadonlyArray<DoExpr>): this {\n      this._do.push(...items);\n      return this;\n    }\n\n    protected $do(): ReadonlyArray<ts.Statement> {\n      return this.$node(this._do.map((item) => new StmtTsDsl(item)));\n    }\n  }\n\n  return Do as unknown as MixinCtor<TBase, DoMethods>;\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeArray } from '../base';\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\nimport { TokenTsDsl } from '../token';\n\nconst Mixed = TsDsl<ts.BindingName>;\n\n/**\n * Builds binding patterns (e.g. `{ foo, bar }`, `[a, b, ...rest]`).\n */\nexport class PatternTsDsl extends Mixed {\n  readonly '~dsl' = 'PatternTsDsl';\n\n  protected pattern?:\n    | { kind: 'array'; values: ReadonlyArray<string> }\n    | { kind: 'object'; values: Record<string, string> };\n  protected _spread?: string;\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  /** Defines an array pattern (e.g. `[a, b, c]`). */\n  array(...props: ReadonlyArray<string> | [ReadonlyArray<string>]): this {\n    const values =\n      props[0] instanceof Array\n        ? [...props[0]]\n        : (props as ReadonlyArray<string>);\n    this.pattern = { kind: 'array', values };\n    return this;\n  }\n\n  /** Defines an object pattern (e.g. `{ a, b: alias }`). */\n  object(\n    ...props: ReadonlyArray<MaybeArray<string> | Record<string, string>>\n  ): this {\n    const entries: Record<string, string> = {};\n    for (const p of props) {\n      if (typeof p === 'string') entries[p] = p;\n      else if (p instanceof Array) for (const n of p) entries[n] = n;\n      else Object.assign(entries, p);\n    }\n    this.pattern = { kind: 'object', values: entries };\n    return this;\n  }\n\n  /** Adds a spread element (e.g. `...rest`, `...options`, `...args`). */\n  spread(name: string): this {\n    this._spread = name;\n    return this;\n  }\n\n  override toAst() {\n    if (!this.pattern) {\n      throw new Error('PatternTsDsl requires object() or array() pattern');\n    }\n\n    if (this.pattern.kind === 'object') {\n      const elements = Object.entries(this.pattern.values).map(\n        ([key, alias]) =>\n          key === alias\n            ? ts.factory.createBindingElement(\n                undefined,\n                undefined,\n                key,\n                undefined,\n              )\n            : ts.factory.createBindingElement(undefined, key, alias, undefined),\n      );\n      const spread = this.createSpread();\n      if (spread) elements.push(spread);\n      return ts.factory.createObjectBindingPattern(elements);\n    }\n\n    if (this.pattern.kind === 'array') {\n      const elements = this.pattern.values.map((p) =>\n        ts.factory.createBindingElement(undefined, undefined, p, undefined),\n      );\n      const spread = this.createSpread();\n      if (spread) elements.push(spread);\n      return ts.factory.createArrayBindingPattern(elements);\n    }\n\n    throw new Error('PatternTsDsl requires object() or array() pattern');\n  }\n\n  private createSpread(): ts.BindingElement | undefined {\n    return this._spread\n      ? ts.factory.createBindingElement(\n          this.$node(new TokenTsDsl().spread()),\n          undefined,\n          this.$node(new IdTsDsl(this._spread)),\n        )\n      : undefined;\n  }\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeArray } from '../base';\nimport { PatternTsDsl } from '../decl/pattern';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface PatternMethods extends Node {\n  /** Renders the pattern into a `BindingName`. */\n  $pattern(): ts.BindingName | undefined;\n  /** Defines an array binding pattern. */\n  array(...props: ReadonlyArray<string> | [ReadonlyArray<string>]): this;\n  /** Defines an object binding pattern. */\n  object(\n    ...props: ReadonlyArray<MaybeArray<string> | Record<string, string>>\n  ): this;\n  /** Adds a spread element (e.g. `...args`, `...options`) to the pattern. */\n  spread(name: string): this;\n}\n\n/**\n * Mixin providing `.array()`, `.object()`, and `.spread()` methods for defining destructuring patterns.\n */\nexport function PatternMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class Pattern extends Base {\n    protected pattern?: PatternTsDsl;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      ctx.analyze(this.pattern);\n    }\n\n    protected array(\n      ...props: ReadonlyArray<string> | [ReadonlyArray<string>]\n    ): this {\n      (this.pattern ??= new PatternTsDsl()).array(...props);\n      return this;\n    }\n\n    protected object(\n      ...props: ReadonlyArray<MaybeArray<string> | Record<string, string>>\n    ): this {\n      (this.pattern ??= new PatternTsDsl()).object(...props);\n      return this;\n    }\n\n    /** Adds a spread element (e.g. `...args`, `...options`) to the pattern. */\n    protected spread(name: string): this {\n      (this.pattern ??= new PatternTsDsl()).spread(name);\n      return this;\n    }\n\n    /** Renders the pattern into a `BindingName`. */\n    protected $pattern(): ts.BindingName | undefined {\n      if (!this.pattern) return;\n      return this.$node(this.pattern);\n    }\n  }\n\n  return Pattern as unknown as MixinCtor<TBase, PatternMethods>;\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl, TypeTsDsl } from '../base';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { OptionalMixin } from '../mixins/optional';\nimport { PatternMixin } from '../mixins/pattern';\nimport { ValueMixin } from '../mixins/value';\nimport { TokenTsDsl } from '../token';\nimport { TypeExprTsDsl } from '../type/expr';\n\nexport type ParamCtor = (\n  name: NodeName | ((p: ParamTsDsl) => void),\n  fn?: (p: ParamTsDsl) => void,\n) => ParamTsDsl;\n\nconst Mixed = DecoratorMixin(\n  OptionalMixin(PatternMixin(ValueMixin(TsDsl<ts.ParameterDeclaration>))),\n);\n\nexport class ParamTsDsl extends Mixed {\n  readonly '~dsl' = 'ParamTsDsl';\n\n  protected _type?: TypeTsDsl;\n\n  constructor(\n    name: NodeName | ((p: ParamTsDsl) => void),\n    fn?: (p: ParamTsDsl) => void,\n  ) {\n    super();\n    if (typeof name === 'function') {\n      name(this);\n    } else {\n      this.name.set(name);\n      fn?.(this);\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n    ctx.analyze(this._type);\n  }\n\n  /** Sets the parameter type. */\n  type(type: string | TypeTsDsl): this {\n    this._type = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n    return this;\n  }\n\n  override toAst() {\n    const name = this.$pattern() || this.name.toString();\n    if (!name) {\n      throw new Error(\n        'Param must have either a name or a destructuring pattern',\n      );\n    }\n    return ts.factory.createParameterDeclaration(\n      this.$decorators(),\n      undefined,\n      name,\n      this._optional ? this.$node(new TokenTsDsl().optional()) : undefined,\n      this.$type(this._type),\n      this.$value(),\n    );\n  }\n}\n","import type { AnalysisContext, Node, NodeName } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport type { ParamCtor } from '../decl/param';\nimport { ParamTsDsl } from '../decl/param';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface ParamMethods extends Node {\n  /** Renders the parameters into an array of `ParameterDeclaration`s. */\n  $params(): ReadonlyArray<ts.ParameterDeclaration>;\n  /** Adds a parameter. */\n  param(...args: Parameters<ParamCtor>): this;\n  /** Adds multiple parameters. */\n  params(...params: ReadonlyArray<MaybeTsDsl<ts.ParameterDeclaration>>): this;\n}\n\nexport function ParamMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class Param extends Base {\n    protected _params: Array<MaybeTsDsl<ts.ParameterDeclaration>> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      for (const param of this._params) {\n        ctx.analyze(param);\n      }\n    }\n\n    protected param(\n      name: NodeName | ((p: ParamTsDsl) => void),\n      fn?: (p: ParamTsDsl) => void,\n    ): this {\n      const p = new ParamTsDsl(name, fn);\n      this._params.push(p);\n      return this;\n    }\n\n    protected params(\n      ...params: ReadonlyArray<MaybeTsDsl<ts.ParameterDeclaration>>\n    ): this {\n      this._params.push(...params);\n      return this;\n    }\n\n    protected $params(): ReadonlyArray<ts.ParameterDeclaration> {\n      return this.$node(this._params);\n    }\n  }\n\n  return Param as unknown as MixinCtor<TBase, ParamMethods>;\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface LayoutMethods extends Node {\n  /** Computes whether output should be multiline based on layout setting and element count. */\n  $multiline(count: number): boolean;\n  /** Sets automatic line output with optional threshold (default: 3). */\n  auto(threshold?: number): this;\n  /** Sets single line output. */\n  inline(): this;\n  /** Sets multi line output. */\n  pretty(): this;\n}\n\nexport function LayoutMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class Layout extends Base {\n    protected static readonly DEFAULT_THRESHOLD = 3;\n    protected layout: boolean | number | undefined;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected auto(threshold: number = Layout.DEFAULT_THRESHOLD): this {\n      this.layout = threshold;\n      return this;\n    }\n\n    protected inline(): this {\n      this.layout = false;\n      return this;\n    }\n\n    protected pretty(): this {\n      this.layout = true;\n      return this;\n    }\n\n    protected $multiline(count: number): boolean {\n      if (this.layout === undefined) {\n        this.layout = Layout.DEFAULT_THRESHOLD;\n      }\n      if (count === 0) return false;\n      return typeof this.layout === 'number'\n        ? count >= this.layout\n        : this.layout;\n    }\n  }\n\n  return Layout as unknown as MixinCtor<TBase, LayoutMethods>;\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport type { DoExpr } from '../mixins/do';\nimport { DoMixin } from '../mixins/do';\nimport { LayoutMixin } from '../mixins/layout';\n\nconst Mixed = DoMixin(LayoutMixin(TsDsl<ts.Block>));\n\nexport class BlockTsDsl extends Mixed {\n  readonly '~dsl' = 'BlockTsDsl';\n\n  constructor(...items: Array<DoExpr>) {\n    super();\n    this.do(...items);\n  }\n\n  override analyze(ctx: AnalysisContext) {\n    super.analyze(ctx);\n  }\n\n  override toAst() {\n    const statements = this.$do();\n    return ts.factory.createBlock(\n      statements,\n      this.$multiline(statements.length),\n    );\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport { PrivateMixin, ProtectedMixin, PublicMixin } from '../mixins/modifiers';\nimport { ParamMixin } from '../mixins/param';\nimport { BlockTsDsl } from '../stmt/block';\n\nconst Mixed = DecoratorMixin(\n  DoMixin(\n    DocMixin(\n      ParamMixin(\n        PrivateMixin(\n          ProtectedMixin(PublicMixin(TsDsl<ts.ConstructorDeclaration>)),\n        ),\n      ),\n    ),\n  ),\n);\n\nexport class InitTsDsl extends Mixed {\n  readonly '~dsl' = 'InitTsDsl';\n\n  constructor(fn?: (i: InitTsDsl) => void) {\n    super();\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    ctx.pushScope();\n    try {\n      super.analyze(ctx);\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  override toAst() {\n    const node = ts.factory.createConstructorDeclaration(\n      [...this.$decorators(), ...this.modifiers],\n      this.$params(),\n      this.$node(new BlockTsDsl(...this._do).pretty()),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext, Node, NodeName } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { TypeTsDsl } from '../base';\nimport { TypeExprTsDsl } from '../type/expr';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface TypeReturnsMethods extends Node {\n  /** Returns the return type node. */\n  $returns(): ts.TypeNode | undefined;\n  /** Sets the return type. */\n  returns(type: NodeName | TypeTsDsl): this;\n}\n\nexport function TypeReturnsMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class TypeReturns extends Base {\n    protected _returns?: TypeTsDsl;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      ctx.analyze(this._returns);\n    }\n\n    protected returns(type: NodeName | TypeTsDsl): this {\n      this._returns =\n        type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n      return this;\n    }\n\n    protected $returns(): ts.TypeNode | undefined {\n      return this.$type(this._returns);\n    }\n  }\n\n  return TypeReturns as unknown as MixinCtor<TBase, TypeReturnsMethods>;\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  AbstractMixin,\n  AsyncMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { OptionalMixin } from '../mixins/optional';\nimport { ParamMixin } from '../mixins/param';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { TypeReturnsMixin } from '../mixins/type-returns';\nimport { BlockTsDsl } from '../stmt/block';\nimport { TokenTsDsl } from '../token';\nimport { safeAccessorName } from '../utils/name';\n\nconst Mixed = AbstractMixin(\n  AsyncMixin(\n    DecoratorMixin(\n      DoMixin(\n        DocMixin(\n          OptionalMixin(\n            ParamMixin(\n              PrivateMixin(\n                ProtectedMixin(\n                  PublicMixin(\n                    StaticMixin(\n                      TypeParamsMixin(\n                        TypeReturnsMixin(TsDsl<ts.MethodDeclaration>),\n                      ),\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n\nexport class MethodTsDsl extends Mixed {\n  readonly '~dsl' = 'MethodTsDsl';\n  override readonly nameSanitizer = safeAccessorName;\n\n  constructor(name: NodeName, fn?: (m: MethodTsDsl) => void) {\n    super();\n    this.name.set(name);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    ctx.analyze(this.name);\n\n    ctx.pushScope();\n    try {\n      super.analyze(ctx);\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  override toAst() {\n    const node = ts.factory.createMethodDeclaration(\n      [...this.$decorators(), ...this.modifiers],\n      undefined,\n      this.$node(this.name) as ts.PropertyName,\n      this._optional ? this.$node(new TokenTsDsl().optional()) : undefined,\n      this.$generics(),\n      this.$params(),\n      this.$returns(),\n      this.$node(new BlockTsDsl(...this._do).pretty()),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { isSymbol, ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { NewlineTsDsl } from '../layout/newline';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DocMixin } from '../mixins/doc';\nimport { AbstractMixin, DefaultMixin, ExportMixin } from '../mixins/modifiers';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { safeRuntimeName } from '../utils/name';\nimport { FieldTsDsl } from './field';\nimport { InitTsDsl } from './init';\nimport { MethodTsDsl } from './method';\n\ntype Body = Array<MaybeTsDsl<ts.ClassElement | ts.Node>>;\n\nconst Mixed = AbstractMixin(\n  DecoratorMixin(\n    DefaultMixin(\n      DocMixin(ExportMixin(TypeParamsMixin(TsDsl<ts.ClassDeclaration>))),\n    ),\n  ),\n);\n\nexport class ClassTsDsl extends Mixed {\n  readonly '~dsl' = 'ClassTsDsl';\n  override readonly nameSanitizer = safeRuntimeName;\n\n  protected baseClass?: Ref<NodeName>;\n  protected body: Body = [];\n\n  constructor(name: NodeName) {\n    super();\n    this.name.set(name);\n    if (isSymbol(name)) {\n      name.setKind('class');\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.baseClass);\n    ctx.analyze(this.name);\n    ctx.pushScope();\n    try {\n      for (const item of this.body) {\n        ctx.analyze(item);\n      }\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  /** Returns true if the class has any members. */\n  get hasBody(): boolean {\n    return this.body.length > 0;\n  }\n\n  /** Adds one or more class members (fields, methods, etc.). */\n  do(...items: Body): this {\n    this.body.push(...items);\n    return this;\n  }\n\n  /** Records a base class to extend from. */\n  extends(base?: NodeName): this {\n    this.baseClass = base ? ref(base) : undefined;\n    return this;\n  }\n\n  /** Adds a class field. */\n  field(name: NodeName, fn?: (f: FieldTsDsl) => void): this {\n    const f = new FieldTsDsl(name, fn);\n    this.body.push(f);\n    return this;\n  }\n\n  /** Adds a class constructor. */\n  init(fn?: InitTsDsl | ((i: InitTsDsl) => void)): this {\n    const i =\n      typeof fn === 'function' ? new InitTsDsl(fn) : fn || new InitTsDsl();\n    this.body.push(i);\n    return this;\n  }\n\n  /** Adds a class method. */\n  method(name: NodeName, fn?: (m: MethodTsDsl) => void): this {\n    const m = new MethodTsDsl(name, fn);\n    this.body.push(m);\n    return this;\n  }\n\n  /** Inserts an empty line between members for formatting. */\n  newline(): this {\n    this.body.push(new NewlineTsDsl());\n    return this;\n  }\n\n  override toAst() {\n    const body = this.$node(this.body) as ReadonlyArray<ts.ClassElement>;\n    const node = ts.factory.createClassDeclaration(\n      [...this.$decorators(), ...this.modifiers],\n      this.$node(this.name) as ts.Identifier,\n      this.$generics(),\n      this._heritage(),\n      body,\n    );\n    return this.$docs(node);\n  }\n\n  /** Builds heritage clauses (extends). */\n  private _heritage(): ReadonlyArray<ts.HeritageClause> {\n    const node = this.$node(this.baseClass);\n    if (!node) return [];\n    return [\n      ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [\n        ts.factory.createExpressionWithTypeArguments(node, undefined),\n      ]),\n    ];\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { safeMemberName } from '../utils/name';\n\ntype Value = string | number | MaybeTsDsl<ts.Expression>;\ntype ValueFn = Value | ((m: EnumMemberTsDsl) => void);\n\nconst Mixed = DocMixin(TsDsl<ts.EnumMember>);\n\nexport class EnumMemberTsDsl extends Mixed {\n  readonly '~dsl' = 'EnumMemberTsDsl';\n\n  private _value?: Value;\n\n  constructor(name: NodeName, value?: ValueFn) {\n    super();\n    this.name.set(name);\n    if (typeof value === 'function') {\n      value(this);\n    } else {\n      this.value(value);\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._value);\n  }\n\n  /** Sets the enum member value. */\n  value(value?: Value): this {\n    this._value = value;\n    return this;\n  }\n\n  override toAst() {\n    const node = ts.factory.createEnumMember(\n      this.$node(safeMemberName(this.name.toString())),\n      this.$node(this._value),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport { isSymbol } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { ConstMixin, ExportMixin } from '../mixins/modifiers';\nimport { safeRuntimeName } from '../utils/name';\nimport { EnumMemberTsDsl } from './member';\n\ntype Value = string | number | MaybeTsDsl<ts.Expression>;\ntype ValueFn = Value | ((m: EnumMemberTsDsl) => void);\n\nconst Mixed = ConstMixin(DocMixin(ExportMixin(TsDsl<ts.EnumDeclaration>)));\n\nexport class EnumTsDsl extends Mixed {\n  readonly '~dsl' = 'EnumTsDsl';\n  override readonly nameSanitizer = safeRuntimeName;\n\n  private _members: Array<EnumMemberTsDsl> = [];\n\n  constructor(name: NodeName, fn?: (e: EnumTsDsl) => void) {\n    super();\n    this.name.set(name);\n    if (isSymbol(name)) {\n      name.setKind('enum');\n    }\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n    ctx.pushScope();\n    try {\n      for (const member of this._members) {\n        ctx.analyze(member);\n      }\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  /** Adds an enum member. */\n  member(name: string, value?: ValueFn): this {\n    const m = new EnumMemberTsDsl(name, value);\n    this._members.push(m);\n    return this;\n  }\n\n  /** Adds multiple enum members. */\n  members(...members: ReadonlyArray<EnumMemberTsDsl>): this {\n    this._members.push(...members);\n    return this;\n  }\n\n  override toAst() {\n    const node = ts.factory.createEnumDeclaration(\n      this.modifiers,\n      this.$node(this.name) as ts.Identifier,\n      this.$node(this._members) as ReadonlyArray<ts.EnumMember>,\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport { isSymbol } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  AbstractMixin,\n  AsyncMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { ParamMixin } from '../mixins/param';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { TypeReturnsMixin } from '../mixins/type-returns';\nimport { BlockTsDsl } from '../stmt/block';\nimport { safeRuntimeName } from '../utils/name';\n\nexport type FuncMode = 'arrow' | 'decl' | 'expr';\n\nconst Mixed = AbstractMixin(\n  AsMixin(\n    AsyncMixin(\n      DecoratorMixin(\n        DoMixin(\n          DocMixin(\n            ParamMixin(\n              PrivateMixin(\n                ProtectedMixin(\n                  PublicMixin(\n                    StaticMixin(\n                      TypeParamsMixin(\n                        TypeReturnsMixin(TsDsl<ts.ArrowFunction>),\n                      ),\n                    ),\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n\nclass ImplFuncTsDsl<M extends FuncMode = 'arrow'> extends Mixed {\n  readonly '~dsl' = 'FuncTsDsl';\n  override readonly nameSanitizer = safeRuntimeName;\n\n  protected mode?: FuncMode;\n\n  constructor();\n  constructor(fn: (f: ImplFuncTsDsl<'arrow'>) => void);\n  constructor(name: NodeName);\n  constructor(name: NodeName, fn: (f: ImplFuncTsDsl<'decl'>) => void);\n  constructor(\n    name?: NodeName | ((f: ImplFuncTsDsl<'arrow'>) => void),\n    fn?: (f: ImplFuncTsDsl<'decl'>) => void,\n  ) {\n    super();\n    if (typeof name === 'function') {\n      this.mode = 'arrow';\n      name(this as unknown as FuncTsDsl<'arrow'>);\n    } else if (name) {\n      this.mode = 'decl';\n      this.name.set(name);\n      if (isSymbol(name)) {\n        name.setKind('function');\n      }\n      fn?.(this as unknown as FuncTsDsl<'decl'>);\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    ctx.pushScope();\n    try {\n      super.analyze(ctx);\n      ctx.analyze(this.name);\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  /** Switches the function to an arrow function form. */\n  arrow(): FuncTsDsl<'arrow'> {\n    this.mode = 'arrow';\n    return this as unknown as FuncTsDsl<'arrow'>;\n  }\n\n  /** Switches the function to a function declaration form. */\n  decl(): FuncTsDsl<'decl'> {\n    this.mode = 'decl';\n    return this as unknown as FuncTsDsl<'decl'>;\n  }\n\n  /** Switches the function to a function expression form. */\n  expr(): FuncTsDsl<'expr'> {\n    this.mode = 'expr';\n    return this as unknown as FuncTsDsl<'expr'>;\n  }\n\n  // @ts-expect-error --- need to fix types ---\n  override toAst(): M extends 'decl'\n    ? ts.FunctionDeclaration\n    : M extends 'expr'\n      ? ts.FunctionExpression\n      : ts.ArrowFunction {\n    const body = this.$node(new BlockTsDsl(...this._do).pretty());\n\n    if (this.mode === 'decl') {\n      const name = this.name.toString();\n      if (!name) throw new Error('Function declaration requires a name');\n      const node = ts.factory.createFunctionDeclaration(\n        [...this.$decorators(), ...this.modifiers],\n        undefined,\n        this.$node(this.name) as ts.Identifier,\n        this.$generics(),\n        this.$params(),\n        this.$returns(),\n        body,\n      ) as any;\n      return this.$docs(node);\n    }\n\n    if (this.mode === 'expr') {\n      const node = ts.factory.createFunctionExpression(\n        this.modifiers,\n        undefined,\n        this.$node(this.name) as ts.Identifier,\n        this.$generics(),\n        this.$params(),\n        this.$returns(),\n        body,\n      ) as any;\n      return this.$docs(node);\n    }\n\n    const node = ts.factory.createArrowFunction(\n      this.modifiers,\n      this.$generics(),\n      this.$params(),\n      this.$returns(),\n      undefined,\n      body.statements.length === 1 &&\n        ts.isReturnStatement(body.statements[0]!) &&\n        body.statements[0].expression\n        ? body.statements[0].expression\n        : body,\n    ) as any;\n    return this.$docs(node);\n  }\n}\n\nexport const FuncTsDsl = ImplFuncTsDsl as {\n  new (): FuncTsDsl<'arrow'>;\n  new (fn: (f: FuncTsDsl<'arrow'>) => void): FuncTsDsl<'arrow'>;\n  new (name: NodeName): FuncTsDsl<'decl'>;\n  new (name: NodeName, fn: (f: FuncTsDsl<'decl'>) => void): FuncTsDsl<'decl'>;\n} & typeof ImplFuncTsDsl;\nexport type FuncTsDsl<M extends FuncMode = 'arrow'> = ImplFuncTsDsl<M>;\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  AbstractMixin,\n  AsyncMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { ParamMixin } from '../mixins/param';\nimport { TypeReturnsMixin } from '../mixins/type-returns';\nimport { BlockTsDsl } from '../stmt/block';\nimport { safeAccessorName } from '../utils/name';\n\nconst Mixed = AbstractMixin(\n  AsyncMixin(\n    DecoratorMixin(\n      DoMixin(\n        DocMixin(\n          ParamMixin(\n            PrivateMixin(\n              ProtectedMixin(\n                PublicMixin(\n                  StaticMixin(\n                    TypeReturnsMixin(TsDsl<ts.GetAccessorDeclaration>),\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n\nexport class GetterTsDsl extends Mixed {\n  readonly '~dsl' = 'GetterTsDsl';\n  override readonly nameSanitizer = safeAccessorName;\n\n  constructor(name: NodeName, fn?: (g: GetterTsDsl) => void) {\n    super();\n    this.name.set(name);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    ctx.analyze(this.name);\n\n    ctx.pushScope();\n    try {\n      super.analyze(ctx);\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  override toAst() {\n    const node = ts.factory.createGetAccessorDeclaration(\n      [...this.$decorators(), ...this.modifiers],\n      this.$node(this.name) as ts.PropertyName,\n      this.$params(),\n      this.$returns(),\n      this.$node(new BlockTsDsl(...this._do).pretty()),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  AbstractMixin,\n  AsyncMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { ParamMixin } from '../mixins/param';\nimport { BlockTsDsl } from '../stmt/block';\nimport { safeAccessorName } from '../utils/name';\n\nconst Mixed = AbstractMixin(\n  AsyncMixin(\n    DecoratorMixin(\n      DoMixin(\n        DocMixin(\n          ParamMixin(\n            PrivateMixin(\n              ProtectedMixin(\n                PublicMixin(StaticMixin(TsDsl<ts.SetAccessorDeclaration>)),\n              ),\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n\nexport class SetterTsDsl extends Mixed {\n  readonly '~dsl' = 'SetterTsDsl';\n  override readonly nameSanitizer = safeAccessorName;\n\n  constructor(name: NodeName, fn?: (s: SetterTsDsl) => void) {\n    super();\n    this.name.set(name);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    ctx.analyze(this.name);\n\n    ctx.pushScope();\n    try {\n      super.analyze(ctx);\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  override toAst() {\n    const node = ts.factory.createSetAccessorDeclaration(\n      [...this.$decorators(), ...this.modifiers],\n      this.$node(this.name) as ts.PropertyName,\n      this.$params(),\n      this.$node(new BlockTsDsl(...this._do).pretty()),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { LayoutMixin } from '../mixins/layout';\nimport { LiteralTsDsl } from './literal';\n\nconst Mixed = AsMixin(LayoutMixin(TsDsl<ts.ArrayLiteralExpression>));\n\nexport class ArrayTsDsl extends Mixed {\n  readonly '~dsl' = 'ArrayTsDsl';\n\n  protected _elements: Array<\n    | { expr: MaybeTsDsl<ts.Expression>; kind: 'element' }\n    | { expr: MaybeTsDsl<ts.Expression>; kind: 'spread' }\n  > = [];\n\n  constructor(\n    ...exprs: Array<string | number | boolean | MaybeTsDsl<ts.Expression>>\n  ) {\n    super();\n    this.elements(...exprs);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const item of this._elements) {\n      ctx.analyze(item.expr);\n    }\n  }\n\n  /** Adds a single array element. */\n  element(expr: string | number | boolean | MaybeTsDsl<ts.Expression>): this {\n    const node =\n      typeof expr === 'string' ||\n      typeof expr === 'number' ||\n      typeof expr === 'boolean'\n        ? new LiteralTsDsl(expr)\n        : expr;\n    this._elements.push({ expr: node, kind: 'element' });\n    return this;\n  }\n\n  /** Adds multiple array elements. */\n  elements(\n    ...exprs: ReadonlyArray<\n      string | number | boolean | MaybeTsDsl<ts.Expression>\n    >\n  ): this {\n    for (const expr of exprs) this.element(expr);\n    return this;\n  }\n\n  /** Adds a spread element (`...expr`). */\n  spread(expr: MaybeTsDsl<ts.Expression>): this {\n    this._elements.push({ expr, kind: 'spread' });\n    return this;\n  }\n\n  override toAst() {\n    const elements = this._elements.map((item) => {\n      const node = this.$node(item.expr);\n      return item.kind === 'spread'\n        ? ts.factory.createSpreadElement(node)\n        : node;\n    });\n\n    return ts.factory.createArrayLiteralExpression(\n      elements,\n      this.$multiline(this._elements.length),\n    );\n  }\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { f } from '../utils/factories';\nimport type { BaseCtor, DropFirst, MixinCtor } from './types';\n\nexport interface ExprMethods extends Node {\n  /** Accesses a property on the current expression (e.g. `this.foo`). */\n  attr(\n    ...args: DropFirst<Parameters<typeof f.attr>>\n  ): ReturnType<typeof f.attr>;\n  /** Awaits the current expression (e.g. `await expr`). */\n  await(): ReturnType<typeof f.await>;\n  /** Calls the current expression (e.g. `fn(arg1, arg2)`). */\n  call(\n    ...args: DropFirst<Parameters<typeof f.call>>\n  ): ReturnType<typeof f.call>;\n  /** Produces a `return` statement returning the current expression. */\n  return(): ReturnType<typeof f.return>;\n}\n\nexport function ExprMixin<T extends ts.Expression, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class Expr extends Base {\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected attr(\n      ...args: DropFirst<Parameters<typeof f.attr>>\n    ): ReturnType<typeof f.attr> {\n      return f.attr(this, ...args);\n    }\n\n    protected await(): ReturnType<typeof f.await> {\n      return f.await(this);\n    }\n\n    protected call(\n      ...args: DropFirst<Parameters<typeof f.call>>\n    ): ReturnType<typeof f.call> {\n      return f.call(this, ...args);\n    }\n\n    protected return(): ReturnType<typeof f.return> {\n      return f.return(this);\n    }\n  }\n\n  return Expr as unknown as MixinCtor<TBase, ExprMethods>;\n}\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { f } from '../utils/factories';\n\nexport type AsExpr = NodeName | MaybeTsDsl<ts.Expression>;\nexport type AsType = NodeName | TypeTsDsl;\nexport type AsCtor = (expr: AsExpr, type: AsType) => AsTsDsl;\n\nconst Mixed = AsMixin(ExprMixin(TsDsl<ts.AsExpression>));\n\nexport class AsTsDsl extends Mixed {\n  readonly '~dsl' = 'AsTsDsl';\n\n  protected expr: Ref<AsExpr>;\n  protected type: Ref<AsType>;\n\n  constructor(expr: AsExpr, type: AsType) {\n    super();\n    this.expr = ref(expr);\n    this.type = ref(type);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.expr);\n    ctx.analyze(this.type);\n  }\n\n  override toAst() {\n    return ts.factory.createAsExpression(\n      this.$node(this.expr),\n      this.$type(this.type),\n    );\n  }\n}\n\nf.as.set((...args) => new AsTsDsl(...args));\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\n\ntype Expr = NodeName | MaybeTsDsl<ts.Expression>;\ntype Op = Operator | ts.BinaryOperator;\ntype Operator =\n  | '!='\n  | '!=='\n  | '&&'\n  | '*'\n  | '+'\n  | '-'\n  | '/'\n  | '<'\n  | '<='\n  | '='\n  | '=='\n  | '==='\n  | '>'\n  | '>='\n  | '??'\n  | '??='\n  | '||';\n\nconst Mixed = AsMixin(ExprMixin(TsDsl<ts.BinaryExpression>));\n\nexport class BinaryTsDsl extends Mixed {\n  readonly '~dsl' = 'BinaryTsDsl';\n\n  protected _base: Ref<Expr>;\n  protected _expr?: Ref<Expr>;\n  protected _op?: Op;\n\n  constructor(base: Expr, op?: Op, expr?: Expr) {\n    super();\n    this._base = ref(base);\n    this._op = op;\n    if (expr) this._expr = ref(expr);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._base);\n    ctx.analyze(this._expr);\n  }\n\n  /** Logical AND ‚Äî `this && expr` */\n  and(expr: Expr): this {\n    return this.opAndExpr('&&', expr);\n  }\n\n  /** Creates an assignment expression (e.g. `this = expr`). */\n  assign(expr: Expr): this {\n    return this.opAndExpr('=', expr);\n  }\n\n  /** Nullish coalescing ‚Äî `this ?? expr` */\n  coalesce(expr: Expr): this {\n    return this.opAndExpr('??', expr);\n  }\n\n  /** Division ‚Äî `this / expr` */\n  div(expr: Expr): this {\n    return this.opAndExpr('/', expr);\n  }\n\n  /** Strict equality ‚Äî `this === expr` */\n  eq(expr: Expr): this {\n    return this.opAndExpr('===', expr);\n  }\n\n  /** Greater than ‚Äî `this > expr` */\n  gt(expr: Expr): this {\n    return this.opAndExpr('>', expr);\n  }\n\n  /** Greater than or equal ‚Äî `this >= expr` */\n  gte(expr: Expr): this {\n    return this.opAndExpr('>=', expr);\n  }\n\n  /** Loose equality ‚Äî `this == expr` */\n  looseEq(expr: Expr): this {\n    return this.opAndExpr('==', expr);\n  }\n\n  /** Loose inequality ‚Äî `this != expr` */\n  looseNeq(expr: Expr): this {\n    return this.opAndExpr('!=', expr);\n  }\n\n  /** Less than ‚Äî `this < expr` */\n  lt(expr: Expr): this {\n    return this.opAndExpr('<', expr);\n  }\n\n  /** Less than or equal ‚Äî `this <= expr` */\n  lte(expr: Expr): this {\n    return this.opAndExpr('<=', expr);\n  }\n\n  /** Subtraction ‚Äî `this - expr` */\n  minus(expr: Expr): this {\n    return this.opAndExpr('-', expr);\n  }\n\n  /** Strict inequality ‚Äî `this !== expr` */\n  neq(expr: Expr): this {\n    return this.opAndExpr('!==', expr);\n  }\n\n  /** Nullish assignment ‚Äî `this ??= expr` */\n  nullishAssign(expr: Expr): this {\n    return this.opAndExpr('??=', expr);\n  }\n\n  /** Logical OR ‚Äî `this || expr` */\n  or(expr: Expr): this {\n    return this.opAndExpr('||', expr);\n  }\n\n  /** Addition ‚Äî `this + expr` */\n  plus(expr: Expr): this {\n    return this.opAndExpr('+', expr);\n  }\n\n  /** Multiplication ‚Äî `this * expr` */\n  times(expr: Expr): this {\n    return this.opAndExpr('*', expr);\n  }\n\n  override toAst() {\n    if (!this._op) {\n      throw new Error('BinaryTsDsl: missing operator');\n    }\n    const expr = this.$node(this._expr);\n    if (!expr) {\n      throw new Error('BinaryTsDsl: missing right-hand expression');\n    }\n    const base = this.$node(this._base);\n    const operator =\n      typeof this._op === 'string' ? this.opToToken(this._op) : this._op;\n    return ts.factory.createBinaryExpression(base, operator, expr);\n  }\n\n  /** Sets the binary operator and right-hand operand for this expression. */\n  private opAndExpr(op: Op, expr: Expr): this {\n    this._expr = ref(expr);\n    this._op = op;\n    return this;\n  }\n\n  private opToToken(op: Operator): ts.BinaryOperator | ts.BinaryOperatorToken {\n    const tokenMap: Record<Operator, ts.BinaryOperator> = {\n      '!=': ts.SyntaxKind.ExclamationEqualsToken,\n      '!==': ts.SyntaxKind.ExclamationEqualsEqualsToken,\n      '&&': ts.SyntaxKind.AmpersandAmpersandToken,\n      '*': ts.SyntaxKind.AsteriskToken,\n      '+': ts.SyntaxKind.PlusToken,\n      '-': ts.SyntaxKind.MinusToken,\n      '/': ts.SyntaxKind.SlashToken,\n      '<': ts.SyntaxKind.LessThanToken,\n      '<=': ts.SyntaxKind.LessThanEqualsToken,\n      '=': ts.SyntaxKind.EqualsToken,\n      '==': ts.SyntaxKind.EqualsEqualsToken,\n      '===': ts.SyntaxKind.EqualsEqualsEqualsToken,\n      '>': ts.SyntaxKind.GreaterThanToken,\n      '>=': ts.SyntaxKind.GreaterThanEqualsToken,\n      '??': ts.SyntaxKind.QuestionQuestionToken,\n      '??=': ts.SyntaxKind.QuestionQuestionEqualsToken,\n      '||': ts.SyntaxKind.BarBarToken,\n    };\n    const token = tokenMap[op];\n    if (!token) {\n      throw new Error(`Unsupported operator: ${op}`);\n    }\n    return token;\n  }\n}\n","import type { AnalysisContext, Node, NodeName } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { BinaryTsDsl } from '../expr/binary';\nimport type { BaseCtor, MixinCtor } from './types';\n\ntype Expr = NodeName | MaybeTsDsl<ts.Expression>;\n\nexport interface OperatorMethods extends Node {\n  /** Logical AND ‚Äî `this && expr` */\n  and(expr: Expr): BinaryTsDsl;\n  /** Creates an assignment expression (e.g. `this = expr`). */\n  assign(expr: Expr): BinaryTsDsl;\n  /** Nullish coalescing ‚Äî `this ?? expr` */\n  coalesce(expr: Expr): BinaryTsDsl;\n  /** Division ‚Äî `this / expr` */\n  div(expr: Expr): BinaryTsDsl;\n  /** Strict equality ‚Äî `this === expr` */\n  eq(expr: Expr): BinaryTsDsl;\n  /** Greater than ‚Äî `this > expr` */\n  gt(expr: Expr): BinaryTsDsl;\n  /** Greater than or equal ‚Äî `this >= expr` */\n  gte(expr: Expr): BinaryTsDsl;\n  /** Loose equality ‚Äî `this == expr` */\n  looseEq(expr: Expr): BinaryTsDsl;\n  /** Loose inequality ‚Äî `this != expr` */\n  looseNeq(expr: Expr): BinaryTsDsl;\n  /** Less than ‚Äî `this < expr` */\n  lt(expr: Expr): BinaryTsDsl;\n  /** Less than or equal ‚Äî `this <= expr` */\n  lte(expr: Expr): BinaryTsDsl;\n  /** Subtraction ‚Äî `this - expr` */\n  minus(expr: Expr): BinaryTsDsl;\n  /** Strict inequality ‚Äî `this !== expr` */\n  neq(expr: Expr): BinaryTsDsl;\n  /** Nullish assignment ‚Äî `this ??= expr` */\n  nullishAssign(expr: Expr): BinaryTsDsl;\n  /** Logical OR ‚Äî `this || expr` */\n  or(expr: Expr): BinaryTsDsl;\n  /** Addition ‚Äî `this + expr` */\n  plus(expr: Expr): BinaryTsDsl;\n  /** Multiplication ‚Äî `this * expr` */\n  times(expr: Expr): BinaryTsDsl;\n}\n\nexport function OperatorMixin<\n  T extends ts.Expression,\n  TBase extends BaseCtor<T>,\n>(Base: TBase) {\n  abstract class Operator extends Base {\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected and(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).and(expr);\n    }\n\n    protected assign(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this, '=', expr);\n    }\n\n    protected coalesce(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).coalesce(expr);\n    }\n\n    protected div(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).div(expr);\n    }\n\n    protected eq(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).eq(expr);\n    }\n\n    protected gt(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).gt(expr);\n    }\n\n    protected gte(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).gte(expr);\n    }\n\n    protected looseEq(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).looseEq(expr);\n    }\n\n    protected looseNeq(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).looseNeq(expr);\n    }\n\n    protected lt(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).lt(expr);\n    }\n\n    protected lte(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).lte(expr);\n    }\n\n    protected minus(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).minus(expr);\n    }\n\n    protected neq(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).neq(expr);\n    }\n\n    protected nullishAssign(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).nullishAssign(expr);\n    }\n\n    protected or(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).or(expr);\n    }\n\n    protected plus(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).plus(expr);\n    }\n\n    protected times(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).times(expr);\n    }\n  }\n\n  return Operator as unknown as MixinCtor<TBase, OperatorMethods>;\n}\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { fromRef, isSymbol, ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { OperatorMixin } from '../mixins/operator';\nimport { OptionalMixin } from '../mixins/optional';\nimport { TokenTsDsl } from '../token';\nimport { f } from '../utils/factories';\nimport { regexp } from '../utils/regexp';\nimport { LiteralTsDsl } from './literal';\n\nexport type AttrLeft = NodeName | MaybeTsDsl<ts.Expression>;\nexport type AttrCtor = (left: AttrLeft, right: NodeName) => AttrTsDsl;\n\nconst Mixed = AsMixin(\n  ExprMixin(\n    OperatorMixin(\n      OptionalMixin(\n        TsDsl<ts.PropertyAccessExpression | ts.ElementAccessExpression>,\n      ),\n    ),\n  ),\n);\n\nexport class AttrTsDsl extends Mixed {\n  readonly '~dsl' = 'AttrTsDsl';\n\n  protected left: Ref<AttrLeft>;\n\n  constructor(left: AttrLeft, right: NodeName) {\n    super();\n    this.left = ref(left);\n    this.name.set(right);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.left);\n    ctx.analyze(this.name);\n  }\n\n  override toAst() {\n    const leftNode = this.$node(this.left);\n    regexp.typeScriptIdentifier.lastIndex = 0;\n    const right = fromRef(this.name);\n    if (!regexp.typeScriptIdentifier.test(this.name.toString())) {\n      let value = isSymbol(right) ? right.finalName : right;\n      if (typeof value === 'string') {\n        if (\n          (value.startsWith(\"'\") && value.endsWith(\"'\")) ||\n          (value.startsWith('\"') && value.endsWith('\"'))\n        ) {\n          value = value.slice(1, -1);\n        }\n      }\n      if (this._optional) {\n        return ts.factory.createElementAccessChain(\n          leftNode,\n          this.$node(new TokenTsDsl().questionDot()),\n          this.$node(new LiteralTsDsl(value)),\n        );\n      }\n      return ts.factory.createElementAccessExpression(\n        leftNode,\n        this.$node(new LiteralTsDsl(value)),\n      );\n    }\n    if (this._optional) {\n      return ts.factory.createPropertyAccessChain(\n        leftNode,\n        this.$node(new TokenTsDsl().questionDot()),\n        this.$node(this.name) as ts.MemberName,\n      );\n    }\n    return ts.factory.createPropertyAccessExpression(\n      leftNode,\n      this.$node(this.name) as ts.MemberName,\n    );\n  }\n}\n\nf.attr.set((...args) => new AttrTsDsl(...args));\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { ExprMixin } from '../mixins/expr';\nimport { f } from '../utils/factories';\n\nexport type AwaitExpr = NodeName | MaybeTsDsl<ts.Expression>;\nexport type AwaitCtor = (expr: AwaitExpr) => AwaitTsDsl;\n\nconst Mixed = ExprMixin(TsDsl<ts.AwaitExpression>);\n\nexport class AwaitTsDsl extends Mixed {\n  readonly '~dsl' = 'AwaitTsDsl';\n\n  protected _awaitExpr: Ref<AwaitExpr>;\n\n  constructor(expr: AwaitExpr) {\n    super();\n    this._awaitExpr = ref(expr);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._awaitExpr);\n  }\n\n  override toAst() {\n    return ts.factory.createAwaitExpression(this.$node(this._awaitExpr));\n  }\n}\n\nf.await.set((...args) => new AwaitTsDsl(...args));\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { ArgsMixin } from '../mixins/args';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { TypeArgsMixin } from '../mixins/type-args';\nimport { f } from '../utils/factories';\n\nexport type CallArgs = ReadonlyArray<CallExpr | undefined>;\nexport type CallExpr = NodeName | MaybeTsDsl<ts.Expression>;\nexport type CallCtor = (expr: CallExpr, ...args: CallArgs) => CallTsDsl;\n\nconst Mixed = ArgsMixin(\n  AsMixin(ExprMixin(TypeArgsMixin(TsDsl<ts.CallExpression>))),\n);\n\nexport class CallTsDsl extends Mixed {\n  readonly '~dsl' = 'CallTsDsl';\n\n  protected _callExpr: Ref<CallExpr>;\n\n  constructor(expr: CallExpr, ...args: CallArgs) {\n    super();\n    this._callExpr = ref(expr);\n    this.args(...args);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._callExpr);\n  }\n\n  override toAst() {\n    return ts.factory.createCallExpression(\n      this.$node(this._callExpr),\n      this.$generics(),\n      this.$args(),\n    );\n  }\n}\n\nf.call.set((...args) => new CallTsDsl(...args));\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { isNode, isSymbol, ref } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { OperatorMixin } from '../mixins/operator';\nimport { TypeExprMixin } from '../mixins/type-expr';\n\ntype Id = NodeName | MaybeTsDsl<ts.Expression>;\n\nconst Mixed = AsMixin(\n  ExprMixin(OperatorMixin(TypeExprMixin(TsDsl<ts.Expression>))),\n);\n\nexport class ExprTsDsl extends Mixed {\n  readonly '~dsl' = 'ExprTsDsl';\n\n  protected _exprInput: Ref<Id>;\n\n  constructor(id: Id) {\n    super();\n    this._exprInput = ref(id);\n    if (typeof id === 'string' || isSymbol(id)) {\n      this.name.set(id);\n    } else if (isNode(id)) {\n      this.name.set(id.name);\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._exprInput);\n  }\n\n  override toAst() {\n    return this.$node(this._exprInput);\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeArray } from '../base';\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\nimport { TsDslContext } from '../utils/context';\n\ntype HintMaybeLazy<T> = ((ctx: TsDslContext) => T) | T;\nexport type HintFn = (d: HintTsDsl) => void;\nexport type HintLines = HintMaybeLazy<MaybeArray<string>>;\n\nexport class HintTsDsl extends TsDsl<ts.Node> {\n  readonly '~dsl' = 'HintTsDsl';\n\n  protected _lines: Array<HintLines> = [];\n\n  constructor(lines?: HintLines, fn?: HintFn) {\n    super();\n    if (lines) this.add(lines);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  add(lines: HintLines): this {\n    this._lines.push(lines);\n    return this;\n  }\n\n  apply<T extends ts.Node>(node: T): T {\n    const ctx = new TsDslContext();\n    const lines = this._lines.reduce(\n      (lines: Array<string>, line: HintLines) => {\n        if (typeof line === 'function') line = line(ctx);\n        for (const l of typeof line === 'string' ? [line] : line) {\n          if (l || l === '') lines.push(l);\n        }\n        return lines;\n      },\n      [],\n    );\n    if (!lines.length) return node;\n\n    for (const line of lines) {\n      ts.addSyntheticLeadingComment(\n        node,\n        ts.SyntaxKind.SingleLineCommentTrivia,\n        ` ${line}`,\n        false,\n      );\n    }\n\n    return node;\n  }\n\n  override toAst(): ts.Node {\n    // this class does not build a standalone node;\n    // it modifies other nodes via `apply()`.\n    // Return a dummy comment node for compliance.\n    return this.$node(new IdTsDsl(''));\n  }\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { HintFn, HintLines } from '../layout/hint';\nimport { HintTsDsl } from '../layout/hint';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface HintMethods extends Node {\n  $hint<T extends ts.Node>(node: T): T;\n  hint(lines?: HintLines, fn?: HintFn): this;\n}\n\nexport function HintMixin<T extends ts.Node, TBase extends BaseCtor<T>>(\n  Base: TBase,\n) {\n  abstract class Hint extends Base {\n    private _hint?: HintTsDsl;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected hint(lines?: HintLines, fn?: HintFn): this {\n      this._hint = new HintTsDsl(lines, fn);\n      return this;\n    }\n\n    protected $hint<T extends ts.Node>(node: T): T {\n      return this._hint ? this._hint.apply(node) : node;\n    }\n  }\n\n  return Hint as unknown as MixinCtor<TBase, HintMethods>;\n}\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { GetterTsDsl } from '../decl/getter';\nimport { SetterTsDsl } from '../decl/setter';\nimport { DocMixin } from '../mixins/doc';\nimport { safePropName } from '../utils/name';\nimport { IdTsDsl } from './id';\n\ntype Expr = NodeName | MaybeTsDsl<ts.Expression>;\ntype Stmt = NodeName | MaybeTsDsl<ts.Statement>;\ntype Kind = 'computed' | 'getter' | 'prop' | 'setter' | 'spread';\n\ntype Meta =\n  | { kind: 'computed'; name: string }\n  | { kind: 'getter'; name: string }\n  | { kind: 'prop'; name: string }\n  | { kind: 'setter'; name: string }\n  | { kind: 'spread'; name?: undefined };\n\nconst Mixed = DocMixin(TsDsl<ts.ObjectLiteralElementLike>);\n\nexport class ObjectPropTsDsl extends Mixed {\n  readonly '~dsl' = 'ObjectPropTsDsl';\n\n  protected _value?: Ref<Expr | Stmt>;\n  protected meta: Meta;\n\n  constructor(meta: Meta) {\n    super();\n    this.meta = meta;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._value);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  value(value: Expr | Stmt | ((p: ObjectPropTsDsl) => void)) {\n    if (typeof value === 'function') {\n      value(this);\n    } else {\n      this._value = ref(value);\n    }\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    const node = this.$node(this._value);\n    if (this.meta.kind === 'spread') {\n      if (ts.isStatement(node)) {\n        throw new Error(\n          'Invalid spread: object spread must be an expression, not a statement.',\n        );\n      }\n      const result = ts.factory.createSpreadAssignment(node);\n      return this.$docs(result);\n    }\n    if (this.meta.kind === 'getter') {\n      const getter = new GetterTsDsl(this.meta.name).do(node);\n      const result = this.$node(getter);\n      return this.$docs(result);\n    }\n    if (this.meta.kind === 'setter') {\n      const setter = new SetterTsDsl(this.meta.name).do(node);\n      const result = this.$node(setter);\n      return this.$docs(result);\n    }\n    if (ts.isIdentifier(node) && node.text === this.meta.name) {\n      const result = ts.factory.createShorthandPropertyAssignment(\n        this.meta.name,\n      );\n      return this.$docs(result);\n    }\n    if (ts.isStatement(node)) {\n      throw new Error(\n        'Invalid property: object property value must be an expression, not a statement.',\n      );\n    }\n    const result = ts.factory.createPropertyAssignment(\n      this.meta.kind === 'computed'\n        ? ts.factory.createComputedPropertyName(\n            this.$node(new IdTsDsl(this.meta.name)),\n          )\n        : this.$node(safePropName(this.meta.name)),\n      node,\n    );\n    return this.$docs(result);\n  }\n\n  $validate(): asserts this is this & {\n    _value: Expr | Stmt;\n    kind: Kind;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(\n      `Object property${this.meta.name ? ` \"${this.meta.name}\"` : ''} missing ${missing.join(' and ')}`,\n    );\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._value) missing.push('.value()');\n    return missing;\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { HintMixin } from '../mixins/hint';\nimport { LayoutMixin } from '../mixins/layout';\nimport { ObjectPropTsDsl } from './prop';\n\ntype Expr = NodeName | MaybeTsDsl<ts.Expression>;\ntype Stmt = NodeName | MaybeTsDsl<ts.Statement>;\ntype ExprFn = Expr | ((p: ObjectPropTsDsl) => void);\ntype StmtFn = Stmt | ((p: ObjectPropTsDsl) => void);\n\nconst Mixed = AsMixin(\n  ExprMixin(HintMixin(LayoutMixin(TsDsl<ts.ObjectLiteralExpression>))),\n);\n\nexport class ObjectTsDsl extends Mixed {\n  readonly '~dsl' = 'ObjectTsDsl';\n\n  protected _props: Array<ObjectPropTsDsl> = [];\n\n  constructor(...props: Array<ObjectPropTsDsl>) {\n    super();\n    this.props(...props);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const prop of this._props) {\n      ctx.analyze(prop);\n    }\n  }\n\n  /** Adds a computed property (e.g. `{ [expr]: value }`). */\n  computed(name: string, expr: ExprFn): this {\n    this._props.push(\n      new ObjectPropTsDsl({ kind: 'computed', name }).value(expr),\n    );\n    return this;\n  }\n\n  /** Adds a getter property (e.g. `{ get foo() { ... } }`). */\n  getter(name: string, stmt: StmtFn): this {\n    this._props.push(new ObjectPropTsDsl({ kind: 'getter', name }).value(stmt));\n    return this;\n  }\n\n  /** Returns true if object has at least one property or spread. */\n  hasProps(): boolean {\n    return this._props.length > 0;\n  }\n\n  /** Returns true if object has no properties or spreads. */\n  get isEmpty(): boolean {\n    return this._props.length === 0;\n  }\n\n  /** Adds a property assignment. */\n  prop(name: string, expr: ExprFn): this {\n    this._props.push(new ObjectPropTsDsl({ kind: 'prop', name }).value(expr));\n    return this;\n  }\n\n  /** Adds multiple properties. */\n  props(...props: ReadonlyArray<ObjectPropTsDsl>): this {\n    this._props.push(...props);\n    return this;\n  }\n\n  /** Adds a setter property (e.g. `{ set foo(v) { ... } }`). */\n  setter(name: string, stmt: StmtFn): this {\n    this._props.push(new ObjectPropTsDsl({ kind: 'setter', name }).value(stmt));\n    return this;\n  }\n\n  /** Adds a spread property (e.g. `{ ...options }`). */\n  spread(expr: ExprFn): this {\n    this._props.push(new ObjectPropTsDsl({ kind: 'spread' }).value(expr));\n    return this;\n  }\n\n  override toAst() {\n    const node = ts.factory.createObjectLiteralExpression(\n      this.$node(this._props),\n      this.$multiline(this._props.length),\n    );\n    return this.$hint(node);\n  }\n}\n","import { isNode } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { TsDsl } from '../base';\nimport { ArrayTsDsl } from './array';\nimport { LiteralTsDsl } from './literal';\nimport { ObjectTsDsl } from './object';\n\nexport const fromValue = (\n  input: unknown,\n  options?: {\n    layout?: 'pretty';\n  },\n): TsDsl<ts.Expression> => {\n  if (isNode(input)) {\n    return input as TsDsl<ts.Expression>;\n  }\n\n  if (\n    input === null ||\n    typeof input === 'number' ||\n    typeof input === 'boolean' ||\n    typeof input === 'string' ||\n    typeof input === 'bigint'\n  ) {\n    return new LiteralTsDsl(input);\n  }\n\n  if (input instanceof Array) {\n    const arr = new ArrayTsDsl(...input.map((v) => fromValue(v, options)));\n    if (options?.layout === 'pretty') arr.pretty();\n    return arr;\n  }\n\n  if (typeof input === 'object') {\n    const obj = new ObjectTsDsl();\n    for (const [key, val] of Object.entries(input)) {\n      const expr = fromValue(val, options);\n      obj.prop(key, expr);\n    }\n    if (options?.layout === 'pretty') obj.pretty();\n    return obj;\n  }\n\n  throw new Error(`$.fromValue(): Unsupported input type ${String(input)}`);\n};\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { ArgsMixin } from '../mixins/args';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { TypeArgsMixin } from '../mixins/type-args';\nimport { f } from '../utils/factories';\n\nexport type NewArgs = ReadonlyArray<NewExpr | undefined>;\nexport type NewExpr = NodeName | MaybeTsDsl<ts.Expression>;\nexport type NewCtor = (expr: NewExpr, ...args: NewArgs) => NewTsDsl;\n\nconst Mixed = ArgsMixin(\n  AsMixin(ExprMixin(TypeArgsMixin(TsDsl<ts.NewExpression>))),\n);\n\nexport class NewTsDsl extends Mixed {\n  readonly '~dsl' = 'NewTsDsl';\n\n  protected _newExpr: Ref<NewExpr>;\n\n  constructor(expr: NewExpr, ...args: NewArgs) {\n    super();\n    this._newExpr = ref(expr);\n    this.args(...args);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._newExpr);\n  }\n\n  override toAst() {\n    return ts.factory.createNewExpression(\n      this.$node(this._newExpr),\n      this.$generics(),\n      this.$args(),\n    );\n  }\n}\n\nf.new.set((...args) => new NewTsDsl(...args));\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\n\ntype RegexFlag = 'g' | 'i' | 'm' | 's' | 'u' | 'y';\n\ntype RegexFlags<Avail extends string = RegexFlag> =\n  | ''\n  | {\n      [K in Avail]: `${K}${RegexFlags<Exclude<Avail, K>>}`;\n    }[Avail];\n\nconst Mixed = TsDsl<ts.RegularExpressionLiteral>;\n\nexport class RegExpTsDsl extends Mixed {\n  readonly '~dsl' = 'RegExpTsDsl';\n\n  protected pattern: string;\n  protected flags?: RegexFlags;\n\n  constructor(pattern: string, flags?: RegexFlags) {\n    super();\n    this.pattern = pattern;\n    this.flags = flags;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  override toAst() {\n    const patternContent =\n      this.pattern.startsWith('/') && this.pattern.endsWith('/')\n        ? this.pattern.slice(1, -1)\n        : this.pattern;\n    const escapedPattern = patternContent.replace(/(?<!\\\\)\\//g, '\\\\/');\n    const literal = `/${escapedPattern}/${this.flags ?? ''}`;\n    return ts.factory.createRegularExpressionLiteral(literal);\n  }\n}\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { fromRef, isSymbol, ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nexport type TemplatePart = NodeName | MaybeTsDsl<ts.Expression>;\n\nconst Mixed = TsDsl<ts.TemplateExpression | ts.NoSubstitutionTemplateLiteral>;\n\nexport class TemplateTsDsl extends Mixed {\n  readonly '~dsl' = 'TemplateTsDsl';\n\n  protected parts: Array<Ref<TemplatePart>> = [];\n\n  constructor(value?: TemplatePart) {\n    super();\n    if (value !== undefined) this.add(value);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const part of this.parts) {\n      ctx.analyze(part);\n    }\n  }\n\n  add(value: TemplatePart): this {\n    this.parts.push(ref(value));\n    return this;\n  }\n\n  override toAst() {\n    const parts = this.$node(\n      this.parts.map((p) => {\n        const part = fromRef(p);\n        return isSymbol(part) ? part.finalName : part;\n      }),\n    );\n\n    const normalized: Array<string | ts.Expression> = [];\n    // merge consecutive string parts\n    for (let index = 0; index < parts.length; index++) {\n      const current = parts[index]!;\n      if (typeof current === 'string') {\n        let merged = current;\n        while (\n          index + 1 < parts.length &&\n          typeof parts[index + 1] === 'string'\n        ) {\n          merged += parts[index + 1];\n          index++;\n        }\n        normalized.push(merged);\n      } else if (typeof current === 'number') {\n        normalized.push(String(current));\n      } else {\n        normalized.push(current);\n      }\n    }\n\n    if (normalized.length === 0 || typeof normalized[0] !== 'string') {\n      normalized.unshift('');\n    }\n\n    if (normalized.length === 1 && typeof normalized[0] === 'string') {\n      return ts.factory.createNoSubstitutionTemplateLiteral(normalized[0]);\n    }\n\n    if (\n      normalized.length === 2 &&\n      typeof normalized[0] === 'string' &&\n      typeof normalized[1] !== 'string'\n    ) {\n      return ts.factory.createTemplateExpression(\n        ts.factory.createTemplateHead(normalized[0]),\n        [\n          ts.factory.createTemplateSpan(\n            normalized[1]!,\n            ts.factory.createTemplateTail(''),\n          ),\n        ],\n      );\n    }\n\n    const head = ts.factory.createTemplateHead(normalized.shift() as string);\n    const spans: Array<ts.TemplateSpan> = [];\n\n    while (normalized.length) {\n      const expr = normalized.shift() as ts.Expression;\n      const next =\n        typeof normalized[0] === 'string' ? (normalized.shift() as string) : '';\n      const isLast = normalized.length === 0;\n      spans.push(\n        ts.factory.createTemplateSpan(\n          expr,\n          isLast\n            ? ts.factory.createTemplateTail(next)\n            : ts.factory.createTemplateMiddle(next),\n        ),\n      );\n    }\n\n    return ts.factory.createTemplateExpression(head, spans);\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nconst Mixed = TsDsl<ts.ConditionalExpression>;\n\nexport class TernaryTsDsl extends Mixed {\n  readonly '~dsl' = 'TernaryTsDsl';\n\n  protected _condition?: string | MaybeTsDsl<ts.Expression>;\n  protected _then?: string | MaybeTsDsl<ts.Expression>;\n  protected _else?: string | MaybeTsDsl<ts.Expression>;\n\n  constructor(condition?: string | MaybeTsDsl<ts.Expression>) {\n    super();\n    if (condition) this.condition(condition);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._condition);\n    ctx.analyze(this._then);\n    ctx.analyze(this._else);\n  }\n\n  condition(condition: string | MaybeTsDsl<ts.Expression>) {\n    this._condition = condition;\n    return this;\n  }\n\n  do(expr: string | MaybeTsDsl<ts.Expression>) {\n    this._then = expr;\n    return this;\n  }\n\n  otherwise(expr: string | MaybeTsDsl<ts.Expression>) {\n    this._else = expr;\n    return this;\n  }\n\n  override toAst() {\n    if (!this._condition) throw new Error('Missing condition in ternary');\n    if (!this._then) throw new Error('Missing then expression in ternary');\n    if (!this._else) throw new Error('Missing else expression in ternary');\n\n    return ts.factory.createConditionalExpression(\n      this.$node(this._condition),\n      undefined,\n      this.$node(this._then),\n      undefined,\n      this.$node(this._else),\n    );\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { OperatorMixin } from '../mixins/operator';\nimport { f } from '../utils/factories';\n\nexport type TypeOfExpr = string | MaybeTsDsl<ts.Expression>;\nexport type TypeOfExprCtor = (expr: TypeOfExpr) => TypeOfExprTsDsl;\n\nconst Mixed = OperatorMixin(TsDsl<ts.TypeOfExpression>);\n\nexport class TypeOfExprTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeOfExprTsDsl';\n\n  protected _expr: TypeOfExpr;\n\n  constructor(expr: TypeOfExpr) {\n    super();\n    this._expr = expr;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._expr);\n  }\n\n  override toAst() {\n    return ts.factory.createTypeOfExpression(this.$node(this._expr));\n  }\n}\n\nf.typeofExpr.set((...args) => new TypeOfExprTsDsl(...args));\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeArray } from '../base';\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\nimport { TsDslContext } from '../utils/context';\n\ntype NoteMaybeLazy<T> = ((ctx: TsDslContext) => T) | T;\nexport type NoteFn = (d: NoteTsDsl) => void;\nexport type NoteLines = NoteMaybeLazy<MaybeArray<string>>;\n\nexport class NoteTsDsl extends TsDsl<ts.Node> {\n  readonly '~dsl' = 'NoteTsDsl';\n\n  protected _lines: Array<NoteLines> = [];\n\n  constructor(lines?: NoteLines, fn?: NoteFn) {\n    super();\n    if (lines) this.add(lines);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  add(lines: NoteLines): this {\n    this._lines.push(lines);\n    return this;\n  }\n\n  apply<T extends ts.Node>(node: T): T {\n    const ctx = new TsDslContext();\n    const lines = this._lines.reduce(\n      (lines: Array<string>, line: NoteLines) => {\n        if (typeof line === 'function') line = line(ctx);\n        for (const l of typeof line === 'string' ? [line] : line) {\n          if (l || l === '') lines.push(l);\n        }\n        return lines;\n      },\n      [],\n    );\n    if (!lines.length) return node;\n\n    ts.addSyntheticLeadingComment(\n      node,\n      ts.SyntaxKind.MultiLineCommentTrivia,\n      `\\n${lines.join('\\n')}\\n`,\n      true,\n    );\n\n    return node;\n  }\n\n  override toAst(): ts.Node {\n    // this class does not build a standalone node;\n    // it modifies other nodes via `apply()`.\n    // Return a dummy comment node for compliance.\n    return this.$node(new IdTsDsl(''));\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport type { DoExpr } from '../mixins/do';\nimport { DoMixin } from '../mixins/do';\nimport { BlockTsDsl } from './block';\n\nexport type IfCondition = string | MaybeTsDsl<ts.Expression>;\n\nconst Mixed = DoMixin(TsDsl<ts.IfStatement>);\n\nexport class IfTsDsl extends Mixed {\n  readonly '~dsl' = 'IfTsDsl';\n\n  protected _condition?: IfCondition;\n  protected _else?: Array<DoExpr>;\n\n  constructor(condition?: IfCondition) {\n    super();\n    if (condition) this.condition(condition);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._condition);\n    if (this._else) {\n      ctx.pushScope();\n      try {\n        for (const stmt of this._else) {\n          ctx.analyze(stmt);\n        }\n      } finally {\n        ctx.popScope();\n      }\n    }\n  }\n\n  condition(condition: IfCondition): this {\n    this._condition = condition;\n    return this;\n  }\n\n  otherwise(...items: Array<DoExpr>): this {\n    this._else = items;\n    return this;\n  }\n\n  override toAst() {\n    if (!this._condition) throw new Error('Missing condition in if');\n    if (!this._do) throw new Error('Missing then block in if');\n\n    return ts.factory.createIfStatement(\n      this.$node(this._condition),\n      this.$node(new BlockTsDsl(...this._do).pretty()),\n      this._else\n        ? this.$node(new BlockTsDsl(...this._else).pretty())\n        : undefined,\n    );\n  }\n}\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { f } from '../utils/factories';\n\nexport type ReturnExpr = NodeName | MaybeTsDsl<ts.Expression>;\nexport type ReturnCtor = (expr?: ReturnExpr) => ReturnTsDsl;\n\nconst Mixed = TsDsl<ts.ReturnStatement>;\n\nexport class ReturnTsDsl extends Mixed {\n  readonly '~dsl' = 'ReturnTsDsl';\n\n  protected _returnExpr?: Ref<ReturnExpr>;\n\n  constructor(expr?: ReturnExpr) {\n    super();\n    if (expr) this._returnExpr = ref(expr);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._returnExpr);\n  }\n\n  override toAst() {\n    return ts.factory.createReturnStatement(this.$node(this._returnExpr));\n  }\n}\n\nf.return.set((...args) => new ReturnTsDsl(...args));\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { LiteralTsDsl } from '../expr/literal';\n\nconst Mixed = TsDsl<ts.ThrowStatement>;\n\nexport class ThrowTsDsl extends Mixed {\n  readonly '~dsl' = 'ThrowTsDsl';\n\n  protected error: string | MaybeTsDsl<ts.Expression>;\n  protected msg?: string | MaybeTsDsl<ts.Expression>;\n  protected useNew: boolean;\n\n  constructor(error: string | MaybeTsDsl<ts.Expression>, useNew = true) {\n    super();\n    this.error = error;\n    this.useNew = useNew;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.error);\n    ctx.analyze(this.msg);\n  }\n\n  message(value: string | MaybeTsDsl<ts.Expression>): this {\n    this.msg = value;\n    return this;\n  }\n\n  override toAst() {\n    const errorNode = this.$node(this.error);\n    const messageNode = this.$node(this.msg ? [this.msg] : []).map((expr) =>\n      typeof expr === 'string' ? this.$node(new LiteralTsDsl(expr)) : expr,\n    );\n    if (this.useNew) {\n      return ts.factory.createThrowStatement(\n        ts.factory.createNewExpression(errorNode, undefined, messageNode),\n      );\n    }\n    const args = messageNode.length\n      ? [ts.factory.createCallExpression(errorNode, undefined, messageNode)]\n      : [errorNode];\n    return ts.factory.createThrowStatement(args[0]!);\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport type { DoExpr } from '../mixins/do';\nimport { BlockTsDsl } from './block';\n\nconst Mixed = TsDsl<ts.TryStatement>;\n\nexport class TryTsDsl extends Mixed {\n  readonly '~dsl' = 'TryTsDsl';\n\n  protected _catch?: Array<DoExpr>;\n  protected _catchArg?: NodeName;\n  protected _finally?: Array<DoExpr>;\n  protected _try?: Array<DoExpr>;\n\n  constructor(...tryBlock: Array<DoExpr>) {\n    super();\n    this.try(...tryBlock);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n\n    if (this._try) {\n      ctx.pushScope();\n      try {\n        for (const stmt of this._try) ctx.analyze(stmt);\n      } finally {\n        ctx.popScope();\n      }\n    }\n\n    if (this._catch || this._catchArg) {\n      ctx.pushScope();\n      try {\n        ctx.analyze(this._catchArg);\n        if (this._catch) {\n          for (const stmt of this._catch) ctx.analyze(stmt);\n        }\n      } finally {\n        ctx.popScope();\n      }\n    }\n\n    if (this._finally) {\n      ctx.pushScope();\n      try {\n        for (const stmt of this._finally) ctx.analyze(stmt);\n      } finally {\n        ctx.popScope();\n      }\n    }\n  }\n\n  catch(...items: Array<DoExpr>): this {\n    this._catch = items;\n    return this;\n  }\n\n  catchArg(arg: NodeName): this {\n    this._catchArg = arg;\n    return this;\n  }\n\n  finally(...items: Array<DoExpr>): this {\n    this._finally = items;\n    return this;\n  }\n\n  try(...items: Array<DoExpr>): this {\n    this._try = items;\n    return this;\n  }\n\n  override toAst() {\n    if (!this._try?.length) throw new Error('Missing try block');\n\n    const catchParam = this._catchArg\n      ? (this.$node(this._catchArg) as ts.BindingName)\n      : undefined;\n\n    return ts.factory.createTryStatement(\n      this.$node(new BlockTsDsl(...this._try).pretty()),\n      ts.factory.createCatchClause(\n        catchParam\n          ? ts.factory.createVariableDeclaration(catchParam)\n          : undefined,\n        this.$node(new BlockTsDsl(...(this._catch ?? [])).pretty()),\n      ),\n      this._finally\n        ? this.$node(new BlockTsDsl(...this._finally).pretty())\n        : undefined,\n    );\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport { isSymbol } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl, TypeTsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { HintMixin } from '../mixins/hint';\nimport { DefaultMixin, ExportMixin } from '../mixins/modifiers';\nimport { PatternMixin } from '../mixins/pattern';\nimport { ValueMixin } from '../mixins/value';\nimport { TypeExprTsDsl } from '../type/expr';\nimport { safeRuntimeName } from '../utils/name';\n\nconst Mixed = DefaultMixin(\n  DocMixin(\n    ExportMixin(\n      HintMixin(PatternMixin(ValueMixin(TsDsl<ts.VariableStatement>))),\n    ),\n  ),\n);\n\nexport class VarTsDsl extends Mixed {\n  readonly '~dsl' = 'VarTsDsl';\n  override readonly nameSanitizer = safeRuntimeName;\n\n  protected kind: ts.NodeFlags = ts.NodeFlags.None;\n  protected _type?: TypeTsDsl;\n\n  constructor(name?: NodeName) {\n    super();\n    if (name) this.name.set(name);\n    if (isSymbol(name)) {\n      name.setKind('var');\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n    ctx.analyze(this._type);\n  }\n\n  const(): this {\n    this.kind = ts.NodeFlags.Const;\n    return this;\n  }\n\n  let(): this {\n    this.kind = ts.NodeFlags.Let;\n    return this;\n  }\n\n  /** Sets the variable type. */\n  type(type: string | TypeTsDsl): this {\n    this._type = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n    return this;\n  }\n\n  var(): this {\n    this.kind = ts.NodeFlags.None;\n    return this;\n  }\n\n  override toAst() {\n    const name = this.$pattern() ?? this.$node(this.name);\n    if (!name)\n      throw new Error('Var must have either a name or a destructuring pattern');\n    const node = ts.factory.createVariableStatement(\n      this.modifiers,\n      ts.factory.createVariableDeclarationList(\n        [\n          ts.factory.createVariableDeclaration(\n            name as ts.BindingName,\n            undefined,\n            this.$type(this._type),\n            this.$value(),\n          ),\n        ],\n        this.kind,\n      ),\n    );\n    return this.$docs(this.$hint(node));\n  }\n}\n","import type {\n  AnalysisContext,\n  NodeName,\n  NodeScope,\n} from '@hey-api/codegen-core';\nimport { isSymbol } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { ExportMixin } from '../mixins/modifiers';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { safeTypeName } from '../utils/name';\n\ntype Value = MaybeTsDsl<ts.TypeNode>;\n\nconst Mixed = DocMixin(\n  ExportMixin(TypeParamsMixin(TsDsl<ts.TypeAliasDeclaration>)),\n);\n\nexport class TypeAliasTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeAliasTsDsl';\n  override readonly nameSanitizer = safeTypeName;\n  override scope: NodeScope = 'type';\n\n  protected value?: Value;\n\n  constructor(name: NodeName, fn?: (t: TypeAliasTsDsl) => void) {\n    super();\n    this.name.set(name);\n    if (isSymbol(name)) {\n      name.setKind('type');\n    }\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n    ctx.analyze(this.value);\n  }\n\n  /** Sets the type expression on the right-hand side of `= ...`. */\n  type(node: Value): this {\n    this.value = node;\n    return this;\n  }\n\n  override toAst() {\n    if (!this.value)\n      throw new Error(\n        `Type alias '${this.name.toString()}' is missing a type definition`,\n      );\n    const node = ts.factory.createTypeAliasDeclaration(\n      this.modifiers,\n      this.$node(this.name) as ts.Identifier,\n      this.$generics(),\n      this.$type(this.value),\n    );\n    return this.$docs(node);\n  }\n}\n","import type {\n  AnalysisContext,\n  NodeName,\n  NodeScope,\n  Ref,\n} from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\ntype Type = NodeName | ts.TypeNode | TypeTsDsl;\n\nconst Mixed = TsDsl<ts.IntersectionTypeNode>;\n\nexport class TypeAndTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeAndTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _types: Array<Ref<Type>> = [];\n\n  constructor(...nodes: Array<Type>) {\n    super();\n    this.types(...nodes);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const type of this._types) {\n      ctx.analyze(type);\n    }\n  }\n\n  types(...nodes: Array<Type>): this {\n    this._types.push(...nodes.map((n) => ref(n)));\n    return this;\n  }\n\n  override toAst() {\n    const flat: Array<ts.TypeNode> = [];\n\n    for (const node of this._types) {\n      const type = this.$type(node);\n      if (ts.isIntersectionTypeNode(type)) {\n        flat.push(...type.types);\n      } else {\n        flat.push(type);\n      }\n    }\n\n    return ts.factory.createIntersectionTypeNode(flat);\n  }\n}\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { LiteralTsDsl } from '../expr/literal';\n\nconst Mixed = TsDsl<ts.LiteralTypeNode>;\n\nexport class TypeLiteralTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeLiteralTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected value: string | number | boolean | null;\n\n  constructor(value: string | number | boolean | null) {\n    super();\n    this.value = value;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  override toAst() {\n    return ts.factory.createLiteralTypeNode(\n      this.$node(new LiteralTsDsl(this.value)),\n    );\n  }\n}\n","import type {\n  AnalysisContext,\n  NodeName,\n  NodeScope,\n} from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { ReadonlyMixin } from '../mixins/modifiers';\n\nexport type TypeIdxSigType = string | MaybeTsDsl<ts.TypeNode>;\n\nconst Mixed = DocMixin(ReadonlyMixin(TsDsl<ts.IndexSignatureDeclaration>));\n\nexport class TypeIdxSigTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeIdxSigTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _key?: TypeIdxSigType;\n  protected _type?: TypeIdxSigType;\n\n  constructor(name: NodeName, fn?: (i: TypeIdxSigTsDsl) => void) {\n    super();\n    this.name.set(name);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._key);\n    ctx.analyze(this._type);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Sets the key type: `[name: T]` */\n  key(type: TypeIdxSigType): this {\n    this._key = type;\n    return this;\n  }\n\n  /** Sets the property type. */\n  type(type: TypeIdxSigType): this {\n    this._type = type;\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    const node = ts.factory.createIndexSignature(\n      this.modifiers,\n      [\n        ts.factory.createParameterDeclaration(\n          undefined,\n          undefined,\n          this.$node(this.name) as ts.BindingName,\n          undefined,\n          this.$type(this._key),\n        ),\n      ],\n      this.$type(this._type),\n    );\n    return this.$docs(node);\n  }\n\n  $validate(): asserts this is this & {\n    _key: TypeIdxSigType;\n    _type: TypeIdxSigType;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    const name = this.name.toString();\n    throw new Error(\n      `Index signature${name ? ` \"${name}\"` : ''} missing ${missing.join(' and ')}`,\n    );\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._key) missing.push('.key()');\n    if (!this._type) missing.push('.\\u200Btype()');\n    return missing;\n  }\n}\n","import type {\n  AnalysisContext,\n  NodeName,\n  NodeScope,\n  Ref,\n} from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { ReadonlyMixin } from '../mixins/modifiers';\nimport { OptionalMixin } from '../mixins/optional';\nimport { TokenTsDsl } from '../token';\nimport { safePropName } from '../utils/name';\n\nexport type TypePropType = NodeName | MaybeTsDsl<ts.TypeNode>;\n\nconst Mixed = DocMixin(OptionalMixin(ReadonlyMixin(TsDsl<ts.TypeElement>)));\n\nexport class TypePropTsDsl extends Mixed {\n  readonly '~dsl' = 'TypePropTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _type?: Ref<TypePropType>;\n\n  constructor(name: NodeName, fn: (p: TypePropTsDsl) => void) {\n    super();\n    this.name.set(name);\n    fn(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._type);\n  }\n\n  /** Sets the property type. */\n  type(type: TypePropType): this {\n    this._type = ref(type);\n    return this;\n  }\n\n  override toAst() {\n    const name = this.name.toString();\n    if (!this._type || !name) {\n      throw new Error(`Type not specified for property '${name}'`);\n    }\n    const node = ts.factory.createPropertySignature(\n      this.modifiers,\n      this.$node(safePropName(name)),\n      this._optional ? this.$node(new TokenTsDsl().optional()) : undefined,\n      this.$type(this._type),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { TypeIdxSigTsDsl } from './idx-sig';\nimport { TypePropTsDsl } from './prop';\n\nconst Mixed = TsDsl<ts.TypeNode>;\n\nexport class TypeObjectTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeObjectTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected props: Array<TypePropTsDsl | TypeIdxSigTsDsl> = [];\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const prop of this.props) {\n      ctx.analyze(prop);\n    }\n  }\n\n  /** Returns true if object has at least one property or spread. */\n  hasProps(): boolean {\n    return this.props.length > 0;\n  }\n\n  /** Adds an index signature to the object type. */\n  idxSig(name: string, fn: (i: TypeIdxSigTsDsl) => void): this {\n    const idx = new TypeIdxSigTsDsl(name, fn);\n    this.props.push(idx);\n    return this;\n  }\n\n  /** Returns true if object has no properties or spreads. */\n  get isEmpty(): boolean {\n    return !this.props.length;\n  }\n\n  /** Adds a property signature (returns property builder). */\n  prop(name: string, fn: (p: TypePropTsDsl) => void): this {\n    const prop = new TypePropTsDsl(name, fn);\n    this.props.push(prop);\n    return this;\n  }\n\n  override toAst() {\n    return ts.factory.createTypeLiteralNode(this.$node(this.props));\n  }\n}\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nconst Mixed = TsDsl<ts.TupleTypeNode>;\n\nexport class TypeTupleTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeTupleTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _elements: Array<string | ts.TypeNode | TypeTsDsl> = [];\n\n  constructor(...nodes: Array<string | ts.TypeNode | TypeTsDsl>) {\n    super();\n    this.elements(...nodes);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const type of this._elements) {\n      ctx.analyze(type);\n    }\n  }\n\n  elements(...types: Array<string | ts.TypeNode | TypeTsDsl>): this {\n    this._elements.push(...types);\n    return this;\n  }\n\n  override toAst() {\n    return ts.factory.createTupleTypeNode(\n      this._elements.map((t) => this.$type(t)),\n    );\n  }\n}\n","import { isNode } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { TsDsl } from '../base';\nimport { TypeLiteralTsDsl } from './literal';\nimport { TypeObjectTsDsl } from './object';\nimport { TypeTupleTsDsl } from './tuple';\n\nexport const fromValue = (input: unknown): TsDsl<ts.TypeNode> => {\n  if (isNode(input)) {\n    return input as TsDsl<ts.TypeNode>;\n  }\n\n  if (input === null) {\n    return new TypeLiteralTsDsl(input);\n  }\n\n  if (\n    typeof input === 'number' ||\n    typeof input === 'boolean' ||\n    typeof input === 'string'\n  ) {\n    return new TypeLiteralTsDsl(input);\n  }\n\n  if (input instanceof Array) {\n    const arr = new TypeTupleTsDsl(...input.map((v) => fromValue(v)));\n    return arr;\n  }\n\n  if (typeof input === 'object') {\n    const obj = new TypeObjectTsDsl();\n    for (const [key, val] of Object.entries(input)) {\n      const type = fromValue(val);\n      obj.prop(key, (p) => p.type(type));\n    }\n    return obj;\n  }\n\n  throw new Error(\n    `$.type.fromValue(): Unsupported input type ${String(input)}`,\n  );\n};\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { ParamMixin } from '../mixins/param';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { TypeReturnsMixin } from '../mixins/type-returns';\n\nconst Mixed = DocMixin(\n  ParamMixin(TypeParamsMixin(TypeReturnsMixin(TsDsl<ts.FunctionTypeNode>))),\n);\n\nexport class TypeFuncTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeFuncTsDsl';\n  override scope: NodeScope = 'type';\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  override toAst() {\n    const returns = this.$returns();\n    if (returns === undefined) {\n      throw new Error('Missing return type in function type DSL');\n    }\n    const node = ts.factory.createFunctionTypeNode(\n      this.$generics(),\n      this.$params(),\n      returns,\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { TypeExprMixin } from '../mixins/type-expr';\nimport { f } from '../utils/factories';\n\ntype Base = string | MaybeTsDsl<ts.TypeNode>;\ntype Index = string | number | MaybeTsDsl<ts.TypeNode>;\nexport type TypeIdxCtor = (base: Base, index: Index) => TypeIdxTsDsl;\n\nconst Mixed = TypeExprMixin(TsDsl<ts.IndexedAccessTypeNode>);\n\nexport class TypeIdxTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeIdxTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _base!: Base;\n  protected _index!: Index;\n\n  constructor(base: Base, index: Index) {\n    super();\n    this.base(base);\n    this.index(index);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._base);\n    ctx.analyze(this._index);\n  }\n\n  base(base: Base): this {\n    this._base = base;\n    return this;\n  }\n\n  index(index: Index): this {\n    this._index = index;\n    return this;\n  }\n\n  override toAst() {\n    return ts.factory.createIndexedAccessTypeNode(\n      this.$type(this._base),\n      this.$type(this._index),\n    );\n  }\n}\n\nf.type.idx.set((...args) => new TypeIdxTsDsl(...args));\n","import type {\n  AnalysisContext,\n  NodeName,\n  NodeScope,\n} from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { TokenTsDsl } from '../token';\n\nconst Mixed = TsDsl<ts.MappedTypeNode>;\n\nexport class TypeMappedTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeMappedTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected questionToken?: TokenTsDsl<\n    | ts.SyntaxKind.QuestionToken\n    | ts.SyntaxKind.PlusToken\n    | ts.SyntaxKind.MinusToken\n  >;\n  protected readonlyToken?: TokenTsDsl<\n    | ts.SyntaxKind.ReadonlyKeyword\n    | ts.SyntaxKind.MinusToken\n    | ts.SyntaxKind.PlusToken\n  >;\n  protected _key?: string | MaybeTsDsl<ts.TypeNode>;\n  protected _type?: string | MaybeTsDsl<ts.TypeNode>;\n\n  constructor(name?: NodeName) {\n    super();\n    if (name) this.name.set(name);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.questionToken);\n    ctx.analyze(this.readonlyToken);\n    ctx.analyze(this._key);\n    ctx.analyze(this._type);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Sets the key constraint: `[K in Constraint]` */\n  key(type: string | MaybeTsDsl<ts.TypeNode>): this {\n    this._key = type;\n    return this;\n  }\n\n  /** Removes `readonly` from the mapped members (`[K in X]-readonly`). */\n  mutable(): this {\n    this.readonlyToken = new TokenTsDsl().minus();\n    return this;\n  }\n\n  /** Makes `[K in X]?:` optional. */\n  optional(): this {\n    this.questionToken = new TokenTsDsl().optional();\n    return this;\n  }\n\n  /** Makes `[K in X]` readonly */\n  readonly(): this {\n    this.readonlyToken = new TokenTsDsl().readonly();\n    return this;\n  }\n\n  /** Removes `?` from the mapped members (`[K in X]-?:`). */\n  required(): this {\n    this.questionToken = new TokenTsDsl().minus();\n    return this;\n  }\n\n  /** Sets the mapped value type: `[K in X]: ValueType` */\n  type(type: string | MaybeTsDsl<ts.TypeNode>): this {\n    this._type = type;\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    return ts.factory.createMappedTypeNode(\n      this.$node(this.readonlyToken),\n      ts.factory.createTypeParameterDeclaration(\n        undefined,\n        this.$node(this.name) as ts.Identifier,\n        this.$type(this._key),\n        undefined,\n      ),\n      undefined,\n      this.$node(this.questionToken),\n      this.$type(this._type),\n      undefined,\n    );\n  }\n\n  $validate(): asserts this is this & {\n    _key: string | MaybeTsDsl<ts.TypeNode>;\n    _type: string | MaybeTsDsl<ts.TypeNode>;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    const name = this.name.toString();\n    throw new Error(\n      `Mapped type${name ? ` \"${name}\"` : ''} missing ${missing.join(' and ')}`,\n    );\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._key) missing.push('.key()');\n    if (!this._type) missing.push('.\\u200Btype()');\n    return missing;\n  }\n}\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { f } from '../utils/factories';\n\ntype Op =\n  | ts.SyntaxKind.KeyOfKeyword\n  | ts.SyntaxKind.ReadonlyKeyword\n  | ts.SyntaxKind.UniqueKeyword;\ntype Type = string | MaybeTsDsl<ts.TypeNode>;\nexport type TypeOperatorCtor = () => TypeOperatorTsDsl;\n\nconst Mixed = TsDsl<ts.TypeOperatorNode>;\n\n/**\n * Builds a TypeScript `TypeOperatorNode`, such as:\n *\n * - `keyof T`\n * - `readonly U`\n * - `unique V`\n *\n * This DSL provides both a generic `.operator()` API and convenient\n * shorthand methods (`.keyof()`, `.readonly()`, `.unique()`).\n *\n * The node will throw during render if required fields are missing.\n */\nexport class TypeOperatorTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeOperatorTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _op?: Op;\n  protected _type?: Type;\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._type);\n  }\n\n  /** Shorthand: builds `keyof T`. */\n  keyof(type: Type): this {\n    this.operator(ts.SyntaxKind.KeyOfKeyword);\n    this.type(type);\n    return this;\n  }\n\n  /** Sets the operator explicitly. */\n  operator(op: Op): this {\n    this._op = op;\n    return this;\n  }\n\n  /** Shorthand: builds `readonly T`. */\n  readonly(type: Type): this {\n    this.operator(ts.SyntaxKind.ReadonlyKeyword);\n    this.type(type);\n    return this;\n  }\n\n  /** Sets the target type of the operator. */\n  type(type: Type): this {\n    this._type = type;\n    return this;\n  }\n\n  /** Shorthand: builds `unique T`. */\n  unique(type: Type): this {\n    this.operator(ts.SyntaxKind.UniqueKeyword);\n    this.type(type);\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    return ts.factory.createTypeOperatorNode(this._op, this.$type(this._type));\n  }\n\n  /** Throws if required fields are not set. */\n  $validate(): asserts this is this & {\n    _op: Op;\n    _type: Type;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Type operator missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._op) missing.push('.operator()');\n    if (!this._type) missing.push('.\\u200Btype()');\n    return missing;\n  }\n}\n\nf.type.operator.set((...args) => new TypeOperatorTsDsl(...args));\n","import type {\n  AnalysisContext,\n  NodeName,\n  NodeScope,\n  Ref,\n} from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\ntype Type = NodeName | ts.TypeNode | TypeTsDsl;\n\nconst Mixed = TsDsl<ts.UnionTypeNode>;\n\nexport class TypeOrTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeOrTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _types: Array<Ref<Type>> = [];\n\n  constructor(...nodes: Array<Type>) {\n    super();\n    this.types(...nodes);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const type of this._types) {\n      ctx.analyze(type);\n    }\n  }\n\n  types(...nodes: Array<Type>): this {\n    this._types.push(...nodes.map((n) => ref(n)));\n    return this;\n  }\n\n  override toAst() {\n    const flat: Array<ts.TypeNode> = [];\n\n    for (const node of this._types) {\n      const type = this.$type(node);\n      if (ts.isUnionTypeNode(type)) {\n        flat.push(...type.types);\n      } else {\n        flat.push(type);\n      }\n    }\n\n    return ts.factory.createUnionTypeNode(flat);\n  }\n}\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { TypeExprMixin } from '../mixins/type-expr';\nimport { f } from '../utils/factories';\n\nexport type TypeQueryExpr = string | MaybeTsDsl<TypeTsDsl | ts.Expression>;\nexport type TypeQueryCtor = (expr: TypeQueryExpr) => TypeQueryTsDsl;\n\nconst Mixed = TypeExprMixin(TsDsl<ts.TypeQueryNode>);\n\nexport class TypeQueryTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeQueryTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _expr: TypeQueryExpr;\n\n  constructor(expr: TypeQueryExpr) {\n    super();\n    this._expr = expr;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._expr);\n  }\n\n  override toAst() {\n    const expr = this.$node(this._expr);\n    return ts.factory.createTypeQueryNode(expr as unknown as ts.EntityName);\n  }\n}\n\nf.type.query.set((...args) => new TypeQueryTsDsl(...args));\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nconst Mixed = TsDsl<ts.TemplateLiteralTypeNode>;\n\nexport class TypeTemplateTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeTemplateTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected parts: Array<string | MaybeTsDsl<ts.TypeNode>> = [];\n\n  constructor(value?: string | MaybeTsDsl<ts.TypeNode>) {\n    super();\n    if (value !== undefined) this.add(value);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const part of this.parts) {\n      ctx.analyze(part);\n    }\n  }\n\n  /** Adds a raw string segment or embedded type expression. */\n  add(part: string | MaybeTsDsl<ts.TypeNode>): this {\n    this.parts.push(part);\n    return this;\n  }\n\n  override toAst() {\n    const parts = this.$node(this.parts);\n\n    const normalized: Array<string | ts.TypeNode> = [];\n    // merge consecutive string parts\n    for (let index = 0; index < parts.length; index++) {\n      const current = parts[index]!;\n      if (typeof current === 'string') {\n        let merged = current;\n        while (\n          index + 1 < parts.length &&\n          typeof parts[index + 1] === 'string'\n        ) {\n          merged += parts[index + 1]!;\n          index++;\n        }\n        normalized.push(merged);\n      } else {\n        normalized.push(current);\n      }\n    }\n\n    if (normalized.length === 0 || typeof normalized[0] !== 'string') {\n      normalized.unshift('');\n    }\n\n    if (normalized.length === 1 && typeof normalized[0] === 'string') {\n      return ts.factory.createTemplateLiteralType(\n        ts.factory.createTemplateHead(normalized[0]),\n        [],\n      );\n    }\n\n    if (\n      normalized.length === 2 &&\n      typeof normalized[0] === 'string' &&\n      typeof normalized[1] !== 'string'\n    ) {\n      return ts.factory.createTemplateLiteralType(\n        ts.factory.createTemplateHead(normalized[0]),\n        [\n          ts.factory.createTemplateLiteralTypeSpan(\n            normalized[1]!,\n            ts.factory.createTemplateTail(''),\n          ),\n        ],\n      );\n    }\n\n    const head = ts.factory.createTemplateHead(normalized.shift() as string);\n    const spans: Array<ts.TemplateLiteralTypeSpan> = [];\n\n    while (normalized.length) {\n      const type = normalized.shift() as ts.TypeNode;\n      const next =\n        typeof normalized[0] === 'string' ? (normalized.shift() as string) : '';\n      const isLast = normalized.length === 0;\n      spans.push(\n        ts.factory.createTemplateLiteralTypeSpan(\n          type,\n          isLast\n            ? ts.factory.createTemplateTail(next)\n            : ts.factory.createTemplateMiddle(next),\n        ),\n      );\n    }\n\n    return ts.factory.createTemplateLiteralType(head, spans);\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { TsDslContext } from './context';\n\nexport type LazyThunk<T extends ts.Node> = (ctx: TsDslContext) => TsDsl<T>;\n\nexport class LazyTsDsl<T extends ts.Node = ts.Node> extends TsDsl<T> {\n  readonly '~dsl' = 'LazyTsDsl';\n\n  private _thunk: LazyThunk<T>;\n\n  constructor(thunk: LazyThunk<T>) {\n    super();\n    this._thunk = thunk;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.toResult());\n  }\n\n  toResult(): TsDsl<T> {\n    return this._thunk(new TsDslContext());\n  }\n\n  override toAst(): T {\n    return this.toResult().toAst();\n  }\n}\n","import path from 'node:path';\n\nimport type { ExportModule, File, ImportModule } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nconst printer = ts.createPrinter({\n  newLine: ts.NewLineKind.LineFeed,\n  removeComments: false,\n});\n\nconst blankFile = ts.createSourceFile(\n  '',\n  '',\n  ts.ScriptTarget.ESNext,\n  false,\n  ts.ScriptKind.TS,\n);\n\n/** Print a TypeScript node to a string. */\nexport function astToString(node: ts.Node): string {\n  const result = printer.printNode(ts.EmitHint.Unspecified, node, blankFile);\n\n  try {\n    /**\n     * TypeScript Compiler API escapes unicode characters by default and there\n     * is no way to disable this behavior\n     * {@link https://github.com/microsoft/TypeScript/issues/36174}\n     */\n    return result.replace(/\\\\u([0-9a-fA-F]{4})/g, (_, hex: string) =>\n      String.fromCharCode(Number.parseInt(hex, 16)),\n    );\n  } catch {\n    return result;\n  }\n}\n\nexport const nodeBuiltins = new Set([\n  'buffer',\n  'child_process',\n  'cluster',\n  'console',\n  'constants',\n  'crypto',\n  'dgram',\n  'dns',\n  'domain',\n  'events',\n  'freelist',\n  'fs',\n  'http',\n  'https',\n  'module',\n  'net',\n  'os',\n  'path',\n  'process',\n  'punycode',\n  'querystring',\n  'readline',\n  'repl',\n  'stream',\n  'string_decoder',\n  'timers',\n  'tls',\n  'tty',\n  'url',\n  'util',\n  'v8',\n  'vm',\n  'worker_threads',\n  'zlib',\n]);\n\nexport type SortGroup = number;\nexport type SortDistance = number;\nexport type SortModule = string;\nexport type SortKey = [SortGroup, SortDistance, SortModule];\n\nexport type ModuleExport = Omit<ExportModule, 'from'> & {\n  /** Module specifier for re-exports, e.g. `./foo`. */\n  modulePath: string;\n};\n\nexport type ModuleImport = Omit<ImportModule, 'from'> & {\n  /** Module specifier for imports, e.g. `./foo`. */\n  modulePath: string;\n};\n\nexport const moduleSortKey = ({\n  file,\n  fromFile,\n  preferFileExtension,\n  root,\n}: {\n  file: File;\n  fromFile: File;\n  preferFileExtension: string;\n  root: string;\n}): SortKey => {\n  const filePath = file.finalPath!.split(path.sep).join('/');\n  let modulePath = fromFile.finalPath!.split(path.sep).join('/');\n\n  // built-ins\n  // TODO: based on nodeBuiltins set\n\n  // external\n  if (fromFile.external && !path.isAbsolute(modulePath)) {\n    return [0, 0, modulePath];\n  }\n\n  // outside project root\n  if (!modulePath.startsWith(root.split(path.sep).join('/'))) {\n    return [1, 0, modulePath];\n  }\n\n  // local\n  const rel = path\n    .relative(path.dirname(filePath), path.dirname(modulePath))\n    .split(path.sep)\n    .join('/');\n\n  let parentCount: number;\n  // same folder\n  if (!rel.startsWith('..')) {\n    modulePath = `./${rel ? `${rel}/` : ''}${fromFile.name}${fromFile.extension ?? ''}`;\n    parentCount = 0;\n  } else {\n    modulePath = `${rel}/${fromFile.name}${fromFile.extension ?? ''}`;\n    parentCount = rel\n      .split(path.sep)\n      .filter((segment) => segment === '..').length;\n  }\n\n  if (modulePath.endsWith('.ts')) {\n    modulePath = modulePath.slice(0, -'.ts'.length);\n  }\n  if (preferFileExtension) {\n    modulePath += preferFileExtension;\n  } else if (modulePath.endsWith('/index')) {\n    modulePath = modulePath.slice(0, -'/index'.length);\n  }\n\n  return [2, parentCount, modulePath];\n};\n","import type { RenderContext, Renderer } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { TsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { MaybeArray, MaybeFunc } from '../base';\nimport type {\n  ModuleExport,\n  ModuleImport,\n  SortGroup,\n  SortKey,\n  SortModule,\n} from './render-utils';\nimport { astToString, moduleSortKey } from './render-utils';\n\ntype Exports = ReadonlyArray<ReadonlyArray<ModuleExport>>;\ntype ExportsOptions = {\n  preferExportAll?: boolean;\n};\ntype Header = MaybeArray<string> | null | undefined;\ntype Imports = ReadonlyArray<ReadonlyArray<ModuleImport>>;\n\nfunction headerToLines(header: Header): ReadonlyArray<string> {\n  if (!header) return [];\n  const lines: Array<string> = [];\n  if (typeof header === 'string') {\n    lines.push(...header.split(/\\r?\\n/));\n    return lines;\n  }\n  for (const line of header) {\n    lines.push(...line.split(/\\r?\\n/));\n  }\n  return lines;\n}\n\nexport class TypeScriptRenderer implements Renderer {\n  /**\n   * Function to generate a file header.\n   *\n   * @private\n   */\n  private _header?: MaybeFunc<(ctx: RenderContext<TsDsl>) => Header>;\n  /**\n   * Whether `export * from 'module'` should be used when possible instead of named exports.\n   *\n   * @private\n   */\n  private _preferExportAll: boolean;\n  /**\n   * Controls whether imports/exports include a file extension (e.g., '.ts' or '.js').\n   *\n   * @private\n   */\n  private _preferFileExtension: string;\n  /**\n   * Optional function to transform module specifiers.\n   *\n   * @private\n   */\n  private _resolveModuleName?: (moduleName: string) => string | undefined;\n\n  constructor(\n    args: {\n      header?: MaybeFunc<(ctx: RenderContext<TsDsl>) => Header>;\n      preferExportAll?: boolean;\n      preferFileExtension?: string;\n      resolveModuleName?: (moduleName: string) => string | undefined;\n    } = {},\n  ) {\n    this._header = args.header;\n    this._preferExportAll = args.preferExportAll ?? false;\n    this._preferFileExtension = args.preferFileExtension ?? '';\n    this._resolveModuleName = args.resolveModuleName;\n  }\n\n  render(ctx: RenderContext<TsDsl>): string {\n    const header =\n      typeof this._header === 'function' ? this._header(ctx) : this._header;\n    return TypeScriptRenderer.astToString({\n      exports: this.getExports(ctx),\n      exportsOptions: {\n        preferExportAll: this._preferExportAll,\n      },\n      header,\n      imports: this.getImports(ctx),\n      nodes: ctx.file.nodes,\n    });\n  }\n\n  supports(ctx: RenderContext): boolean {\n    return ctx.file.language === 'typescript';\n  }\n\n  static astToString(args: {\n    exports?: Exports;\n    exportsOptions?: ExportsOptions;\n    header?: Header;\n    imports?: Imports;\n    nodes?: ReadonlyArray<TsDsl>;\n    /**\n     * Whether to include a trailing newline at the end of the file.\n     *\n     * @default true\n     */\n    trailingNewline?: boolean;\n  }): string {\n    let text = '';\n    for (const header of headerToLines(args.header)) {\n      text += `${header}\\n`;\n    }\n\n    let imports = '';\n    for (const group of args.imports ?? []) {\n      if (imports) imports += '\\n';\n      for (const imp of group) {\n        imports += `${astToString(TypeScriptRenderer.toImportAst(imp))}\\n`;\n      }\n    }\n    text = `${text}${text && imports ? '\\n' : ''}${imports}`;\n\n    let nodes = '';\n    for (const node of args.nodes ?? []) {\n      if (nodes) nodes += '\\n';\n      nodes += `${astToString(node.toAst())}\\n`;\n    }\n    text = `${text}${text && nodes ? '\\n' : ''}${nodes}`;\n\n    let exports = '';\n    for (const group of args.exports ?? []) {\n      if ((!exports && nodes) || exports) exports += '\\n';\n      for (const exp of group) {\n        exports += `${astToString(TypeScriptRenderer.toExportAst(exp, args.exportsOptions))}\\n`;\n      }\n    }\n    text = `${text}${text && exports ? '\\n' : ''}${exports}`;\n\n    if (args.trailingNewline === false && text.endsWith('\\n')) {\n      text = text.slice(0, -1);\n    }\n\n    return text;\n  }\n\n  static toExportAst(\n    group: ModuleExport,\n    options?: ExportsOptions,\n  ): ts.ExportDeclaration {\n    const specifiers = group.exports.map((exp) => {\n      const specifier = ts.factory.createExportSpecifier(\n        exp.isTypeOnly,\n        exp.sourceName !== exp.exportedName\n          ? $.id(exp.sourceName).toAst()\n          : undefined,\n        $.id(exp.exportedName).toAst(),\n      );\n      return specifier;\n    });\n    const exportClause = group.namespaceExport\n      ? ts.factory.createNamespaceExport($.id(group.namespaceExport).toAst())\n      : (!group.canExportAll || !options?.preferExportAll) && specifiers.length\n        ? ts.factory.createNamedExports(specifiers)\n        : undefined;\n    return ts.factory.createExportDeclaration(\n      undefined,\n      group.isTypeOnly,\n      exportClause,\n      $.literal(group.modulePath).toAst(),\n    );\n  }\n\n  static toImportAst(group: ModuleImport): ts.ImportDeclaration {\n    const specifiers = group.imports.map((imp) => {\n      const specifier = ts.factory.createImportSpecifier(\n        imp.isTypeOnly,\n        imp.sourceName !== imp.localName\n          ? $.id(imp.sourceName).toAst()\n          : undefined,\n        $.id(imp.localName).toAst(),\n      );\n      return specifier;\n    });\n    const importClause = ts.factory.createImportClause(\n      group.isTypeOnly,\n      group.kind === 'default'\n        ? $.id(group.localName ?? '').toAst()\n        : undefined,\n      group.kind === 'namespace'\n        ? ts.factory.createNamespaceImport($.id(group.localName ?? '').toAst())\n        : specifiers.length > 0\n          ? ts.factory.createNamedImports(specifiers)\n          : undefined,\n    );\n    return ts.factory.createImportDeclaration(\n      undefined,\n      importClause,\n      $.literal(group.modulePath).toAst(),\n    );\n  }\n\n  private getExports(ctx: RenderContext): Exports {\n    type ModuleEntry = {\n      group: ModuleExport;\n      sortKey: SortKey;\n    };\n\n    const groups = new Map<SortGroup, Map<SortModule, ModuleEntry>>();\n\n    for (const exp of ctx.file.exports) {\n      const sortKey = moduleSortKey({\n        file: ctx.file,\n        fromFile: exp.from,\n        preferFileExtension: this._preferFileExtension,\n        root: ctx.project.root,\n      });\n      const modulePath = this._resolveModuleName?.(sortKey[2]) ?? sortKey[2];\n      const [groupIndex] = sortKey;\n\n      if (!groups.has(groupIndex)) groups.set(groupIndex, new Map());\n      const moduleMap = groups.get(groupIndex)!;\n\n      if (!moduleMap.has(modulePath)) {\n        moduleMap.set(modulePath, {\n          group: {\n            canExportAll: exp.canExportAll,\n            exports: exp.exports,\n            isTypeOnly: exp.isTypeOnly,\n            modulePath,\n            namespaceExport: exp.namespaceExport,\n          },\n          sortKey,\n        });\n      }\n    }\n\n    const exports: Array<Array<ModuleExport>> = Array.from(groups.entries())\n      .sort((a, b) => a[0] - b[0])\n      .map(([, moduleMap]) => {\n        const entries = Array.from(moduleMap.values());\n\n        entries.sort((a, b) => {\n          const d = a.sortKey[1] - b.sortKey[1];\n          return d !== 0\n            ? d\n            : a.group.modulePath.localeCompare(b.group.modulePath);\n        });\n\n        return entries.map((e) => {\n          const group = e.group;\n          if (group.namespaceExport) {\n            group.exports = [];\n          } else {\n            const isTypeOnly = !group.exports.find((exp) => !exp.isTypeOnly);\n            if (isTypeOnly) {\n              group.isTypeOnly = true;\n              for (const exp of group.exports) {\n                exp.isTypeOnly = false;\n              }\n            }\n            group.exports.sort((a, b) =>\n              a.exportedName.localeCompare(b.exportedName),\n            );\n          }\n          return group;\n        });\n      });\n\n    return exports;\n  }\n\n  private getImports(ctx: RenderContext): Imports {\n    type ModuleEntry = {\n      group: ModuleImport;\n      sortKey: SortKey;\n    };\n\n    const groups = new Map<SortGroup, Map<SortModule, ModuleEntry>>();\n\n    for (const imp of ctx.file.imports) {\n      const sortKey = moduleSortKey({\n        file: ctx.file,\n        fromFile: imp.from,\n        preferFileExtension: this._preferFileExtension,\n        root: ctx.project.root,\n      });\n      const modulePath = this._resolveModuleName?.(sortKey[2]) ?? sortKey[2];\n      const [groupIndex] = sortKey;\n\n      if (!groups.has(groupIndex)) groups.set(groupIndex, new Map());\n      const moduleMap = groups.get(groupIndex)!;\n\n      if (!moduleMap.has(modulePath)) {\n        moduleMap.set(modulePath, {\n          group: {\n            imports: [],\n            isTypeOnly: false,\n            kind: imp.kind,\n            modulePath,\n          },\n          sortKey,\n        });\n      }\n\n      const entry = moduleMap.get(modulePath)!;\n      const group = entry.group;\n\n      if (imp.kind !== 'named') {\n        group.isTypeOnly = imp.isTypeOnly;\n        group.kind = imp.kind;\n        group.localName = imp.localName;\n      } else {\n        group.imports.push(...imp.imports);\n      }\n    }\n\n    const imports: Array<Array<ModuleImport>> = Array.from(groups.entries())\n      .sort((a, b) => a[0] - b[0])\n      .map(([, moduleMap]) => {\n        const entries = Array.from(moduleMap.values());\n\n        entries.sort((a, b) => {\n          const d = a.sortKey[1] - b.sortKey[1];\n          return d !== 0\n            ? d\n            : a.group.modulePath.localeCompare(b.group.modulePath);\n        });\n\n        return entries.map((e) => {\n          const group = e.group;\n          if (group.kind === 'namespace') {\n            group.imports = [];\n          } else {\n            const isTypeOnly = !group.imports.find((imp) => !imp.isTypeOnly);\n            if (isTypeOnly) {\n              group.isTypeOnly = true;\n              for (const imp of group.imports) {\n                imp.isTypeOnly = false;\n              }\n            }\n            group.imports.sort((a, b) =>\n              a.localName.localeCompare(b.localName),\n            );\n          }\n          return group;\n        });\n      });\n\n    return imports;\n  }\n}\n","import type ts from 'typescript';\n\nimport { ClassTsDsl } from './decl/class';\nimport { DecoratorTsDsl } from './decl/decorator';\nimport { EnumTsDsl } from './decl/enum';\nimport { FieldTsDsl } from './decl/field';\nimport { FuncTsDsl } from './decl/func';\nimport { GetterTsDsl } from './decl/getter';\nimport { InitTsDsl } from './decl/init';\nimport { EnumMemberTsDsl } from './decl/member';\nimport { MethodTsDsl } from './decl/method';\nimport { ParamTsDsl } from './decl/param';\nimport { PatternTsDsl } from './decl/pattern';\nimport { SetterTsDsl } from './decl/setter';\nimport { ArrayTsDsl } from './expr/array';\nimport { AsTsDsl } from './expr/as';\nimport { AttrTsDsl } from './expr/attr';\nimport { AwaitTsDsl } from './expr/await';\nimport { BinaryTsDsl } from './expr/binary';\nimport { CallTsDsl } from './expr/call';\nimport { ExprTsDsl } from './expr/expr';\nimport { fromValue as exprValue } from './expr/fromValue';\nimport { IdTsDsl } from './expr/id';\nimport { LiteralTsDsl } from './expr/literal';\nimport { NewTsDsl } from './expr/new';\nimport { ObjectTsDsl } from './expr/object';\nimport { PrefixTsDsl } from './expr/prefix';\nimport { ObjectPropTsDsl } from './expr/prop';\nimport { RegExpTsDsl } from './expr/regexp';\nimport { TemplateTsDsl } from './expr/template';\nimport { TernaryTsDsl } from './expr/ternary';\nimport { TypeOfExprTsDsl } from './expr/typeof';\nimport { DocTsDsl } from './layout/doc';\nimport { HintTsDsl } from './layout/hint';\nimport { NewlineTsDsl } from './layout/newline';\nimport { NoteTsDsl } from './layout/note';\nimport { BlockTsDsl } from './stmt/block';\nimport { IfTsDsl } from './stmt/if';\nimport { ReturnTsDsl } from './stmt/return';\nimport { StmtTsDsl } from './stmt/stmt';\nimport { ThrowTsDsl } from './stmt/throw';\nimport { TryTsDsl } from './stmt/try';\nimport { VarTsDsl } from './stmt/var';\nimport { TokenTsDsl } from './token';\nimport { TypeAliasTsDsl } from './type/alias';\nimport { TypeAndTsDsl } from './type/and';\nimport { TypeAttrTsDsl } from './type/attr';\nimport { TypeExprTsDsl } from './type/expr';\nimport { fromValue as typeValue } from './type/fromValue';\nimport { TypeFuncTsDsl } from './type/func';\nimport { TypeIdxTsDsl } from './type/idx';\nimport { TypeLiteralTsDsl } from './type/literal';\nimport { TypeMappedTsDsl } from './type/mapped';\nimport { TypeObjectTsDsl } from './type/object';\nimport { TypeOperatorTsDsl } from './type/operator';\nimport { TypeOrTsDsl } from './type/or';\nimport { TypeParamTsDsl } from './type/param';\nimport { TypeQueryTsDsl } from './type/query';\nimport { TypeTemplateTsDsl } from './type/template';\nimport { TypeTupleTsDsl } from './type/tuple';\nimport { LazyTsDsl } from './utils/lazy';\n\nconst tsDsl = {\n  /** Creates an array literal expression (e.g. `[1, 2, 3]`). */\n  array: (...args: ConstructorParameters<typeof ArrayTsDsl>) =>\n    new ArrayTsDsl(...args),\n\n  /** Creates an `as` type assertion expression (e.g. `value as Type`). */\n  as: (...args: ConstructorParameters<typeof AsTsDsl>) => new AsTsDsl(...args),\n\n  /** Creates a property access expression (e.g. `obj.foo`). */\n  attr: (...args: ConstructorParameters<typeof AttrTsDsl>) =>\n    new AttrTsDsl(...args),\n\n  /** Creates an await expression (e.g. `await promise`). */\n  await: (...args: ConstructorParameters<typeof AwaitTsDsl>) =>\n    new AwaitTsDsl(...args),\n\n  /** Creates a binary expression (e.g. `a + b`). */\n  binary: (...args: ConstructorParameters<typeof BinaryTsDsl>) =>\n    new BinaryTsDsl(...args),\n\n  /** Creates a statement block (`{ ... }`). */\n  block: (...args: ConstructorParameters<typeof BlockTsDsl>) =>\n    new BlockTsDsl(...args),\n\n  /** Creates a function or method call expression (e.g. `fn(arg)`). */\n  call: (...args: ConstructorParameters<typeof CallTsDsl>) =>\n    new CallTsDsl(...args),\n\n  /** Creates a class declaration or expression. */\n  class: (...args: ConstructorParameters<typeof ClassTsDsl>) =>\n    new ClassTsDsl(...args),\n\n  /** Creates a constant variable declaration (`const`). */\n  const: (...args: ConstructorParameters<typeof VarTsDsl>) =>\n    new VarTsDsl(...args).const(),\n\n  /** Creates a decorator expression (e.g. `@decorator`). */\n  decorator: (...args: ConstructorParameters<typeof DecoratorTsDsl>) =>\n    new DecoratorTsDsl(...args),\n\n  /** Creates a JSDoc documentation block. */\n  doc: (...args: ConstructorParameters<typeof DocTsDsl>) =>\n    new DocTsDsl(...args),\n\n  /** Creates an enum declaration. */\n  enum: (...args: ConstructorParameters<typeof EnumTsDsl>) =>\n    new EnumTsDsl(...args),\n\n  /** Creates a general expression node. */\n  expr: (...args: ConstructorParameters<typeof ExprTsDsl>) =>\n    new ExprTsDsl(...args),\n\n  /** Creates a field declaration in a class or object. */\n  field: (...args: ConstructorParameters<typeof FieldTsDsl>) =>\n    new FieldTsDsl(...args),\n\n  /** Converts a runtime value into a corresponding expression node. */\n  fromValue: (...args: Parameters<typeof exprValue>) => exprValue(...args),\n\n  /** Creates a function expression or declaration. */\n  func: ((nameOrFn?: any, fn?: any) => {\n    if (nameOrFn === undefined) return new FuncTsDsl();\n    if (typeof nameOrFn !== 'string') return new FuncTsDsl(nameOrFn);\n    if (fn === undefined) return new FuncTsDsl(nameOrFn);\n    return new FuncTsDsl(nameOrFn, fn);\n  }) as {\n    (): FuncTsDsl<'arrow'>;\n    (fn: (f: FuncTsDsl<'arrow'>) => void): FuncTsDsl<'arrow'>;\n    (name: string): FuncTsDsl<'decl'>;\n    (name: string, fn: (f: FuncTsDsl<'decl'>) => void): FuncTsDsl<'decl'>;\n    (\n      name?: string,\n      fn?: (f: FuncTsDsl<'decl'>) => void,\n    ): FuncTsDsl<'arrow'> | FuncTsDsl<'decl'>;\n  },\n\n  /** Creates a getter method declaration. */\n  getter: (...args: ConstructorParameters<typeof GetterTsDsl>) =>\n    new GetterTsDsl(...args),\n\n  /** Creates a single-line comment (//). */\n  hint: (...args: ConstructorParameters<typeof HintTsDsl>) =>\n    new HintTsDsl(...args),\n\n  /** Creates an identifier (e.g. `foo`). */\n  id: (...args: ConstructorParameters<typeof IdTsDsl>) => new IdTsDsl(...args),\n\n  /** Creates an if statement. */\n  if: (...args: ConstructorParameters<typeof IfTsDsl>) => new IfTsDsl(...args),\n\n  /** Creates an initialization block or statement. */\n  init: (...args: ConstructorParameters<typeof InitTsDsl>) =>\n    new InitTsDsl(...args),\n\n  /** Creates a lazy, context-aware node with deferred evaluation. */\n  lazy: <T extends ts.Node>(\n    ...args: ConstructorParameters<typeof LazyTsDsl<T>>\n  ) => new LazyTsDsl<T>(...args),\n\n  /** Creates a let variable declaration (`let`). */\n  let: (...args: ConstructorParameters<typeof VarTsDsl>) =>\n    new VarTsDsl(...args).let(),\n\n  /** Creates a literal value (e.g. string, number, boolean). */\n  literal: (...args: ConstructorParameters<typeof LiteralTsDsl>) =>\n    new LiteralTsDsl(...args),\n\n  /** Creates an enum member declaration. */\n  member: (...args: ConstructorParameters<typeof EnumMemberTsDsl>) =>\n    new EnumMemberTsDsl(...args),\n\n  /** Creates a method declaration inside a class or object. */\n  method: (...args: ConstructorParameters<typeof MethodTsDsl>) =>\n    new MethodTsDsl(...args),\n\n  /** Creates a negation expression (`-x`). */\n  neg: (...args: ConstructorParameters<typeof PrefixTsDsl>) =>\n    new PrefixTsDsl(...args).neg(),\n\n  /** Creates a new expression (e.g. `new ClassName()`). */\n  new: (...args: ConstructorParameters<typeof NewTsDsl>) =>\n    new NewTsDsl(...args),\n\n  /** Creates a newline (for formatting purposes). */\n  newline: (...args: ConstructorParameters<typeof NewlineTsDsl>) =>\n    new NewlineTsDsl(...args),\n\n  /** Creates a logical NOT expression (`!x`). */\n  not: (...args: ConstructorParameters<typeof PrefixTsDsl>) =>\n    new PrefixTsDsl(...args).not(),\n\n  /** Creates a block comment (/* ... *\\/). */\n  note: (...args: ConstructorParameters<typeof NoteTsDsl>) =>\n    new NoteTsDsl(...args),\n\n  /** Creates an object literal expression. */\n  object: (...args: ConstructorParameters<typeof ObjectTsDsl>) =>\n    new ObjectTsDsl(...args),\n\n  /** Creates a parameter declaration for functions or methods. */\n  param: (...args: ConstructorParameters<typeof ParamTsDsl>) =>\n    new ParamTsDsl(...args),\n\n  /** Creates a pattern for destructuring or matching. */\n  pattern: (...args: ConstructorParameters<typeof PatternTsDsl>) =>\n    new PatternTsDsl(...args),\n\n  /** Creates a prefix unary expression (e.g. `-x`, `!x`, `~x`). */\n  prefix: (...args: ConstructorParameters<typeof PrefixTsDsl>) =>\n    new PrefixTsDsl(...args),\n\n  /** Creates an object literal property (e.g. `{ foo: bar }`). */\n  prop: (...args: ConstructorParameters<typeof ObjectPropTsDsl>) =>\n    new ObjectPropTsDsl(...args),\n\n  /** Creates a regular expression literal (e.g. `/foo/gi`). */\n  regexp: (...args: ConstructorParameters<typeof RegExpTsDsl>) =>\n    new RegExpTsDsl(...args),\n\n  /** Creates a return statement. */\n  return: (...args: ConstructorParameters<typeof ReturnTsDsl>) =>\n    new ReturnTsDsl(...args),\n\n  /** Creates a setter method declaration. */\n  setter: (...args: ConstructorParameters<typeof SetterTsDsl>) =>\n    new SetterTsDsl(...args),\n\n  /** Wraps an expression or statement-like value into a `StmtTsDsl`. */\n  stmt: (...args: ConstructorParameters<typeof StmtTsDsl>) =>\n    new StmtTsDsl(...args),\n\n  /** Creates a template literal expression. */\n  template: (...args: ConstructorParameters<typeof TemplateTsDsl>) =>\n    new TemplateTsDsl(...args),\n\n  /** Creates a ternary conditional expression (if ? then : else). */\n  ternary: (...args: ConstructorParameters<typeof TernaryTsDsl>) =>\n    new TernaryTsDsl(...args),\n\n  /** Creates a throw statement. */\n  throw: (...args: ConstructorParameters<typeof ThrowTsDsl>) =>\n    new ThrowTsDsl(...args),\n\n  /** Creates a syntax token (e.g. `?`, `readonly`, `+`, `-`). */\n  token: (...args: ConstructorParameters<typeof TokenTsDsl>) =>\n    new TokenTsDsl(...args),\n\n  /** Creates a try/catch/finally statement. */\n  try: (...args: ConstructorParameters<typeof TryTsDsl>) =>\n    new TryTsDsl(...args),\n\n  /** Creates a basic type reference or type expression (e.g. Foo or Foo<T>). */\n  type: Object.assign(\n    (...args: ConstructorParameters<typeof TypeExprTsDsl>) =>\n      new TypeExprTsDsl(...args),\n    {\n      /** Creates a type alias declaration (e.g. `type Foo = Bar`). */\n      alias: (...args: ConstructorParameters<typeof TypeAliasTsDsl>) =>\n        new TypeAliasTsDsl(...args),\n\n      /** Creates an intersection type (e.g. `A & B`). */\n      and: (...args: ConstructorParameters<typeof TypeAndTsDsl>) =>\n        new TypeAndTsDsl(...args),\n\n      /** Creates a qualified type reference (e.g. Foo.Bar). */\n      attr: (...args: ConstructorParameters<typeof TypeAttrTsDsl>) =>\n        new TypeAttrTsDsl(...args),\n\n      /** Creates a basic type reference or type expression (e.g. Foo or Foo<T>). */\n      expr: (...args: ConstructorParameters<typeof TypeExprTsDsl>) =>\n        new TypeExprTsDsl(...args),\n\n      /** Converts a runtime value into a corresponding type expression node. */\n      fromValue: (...args: Parameters<typeof typeValue>) => typeValue(...args),\n\n      /** Creates a function type node (e.g. `(a: string) => number`). */\n      func: (...args: ConstructorParameters<typeof TypeFuncTsDsl>) =>\n        new TypeFuncTsDsl(...args),\n\n      /** Creates an indexed-access type (e.g. `Foo<T>[K]`). */\n      idx: (...args: ConstructorParameters<typeof TypeIdxTsDsl>) =>\n        new TypeIdxTsDsl(...args),\n\n      /** Creates a literal type node (e.g. 'foo', 42, or true). */\n      literal: (...args: ConstructorParameters<typeof TypeLiteralTsDsl>) =>\n        new TypeLiteralTsDsl(...args),\n\n      /** Creates a mapped type (e.g. `{ [K in keyof T]: U }`). */\n      mapped: (...args: ConstructorParameters<typeof TypeMappedTsDsl>) =>\n        new TypeMappedTsDsl(...args),\n\n      /** Creates a type literal node (e.g. { foo: string }). */\n      object: (...args: ConstructorParameters<typeof TypeObjectTsDsl>) =>\n        new TypeObjectTsDsl(...args),\n\n      /** Creates a type operator node (e.g. `readonly T`, `keyof T`, `unique T`). */\n      operator: (...args: ConstructorParameters<typeof TypeOperatorTsDsl>) =>\n        new TypeOperatorTsDsl(...args),\n\n      /** Represents a union type (e.g. `A | B | C`). */\n      or: (...args: ConstructorParameters<typeof TypeOrTsDsl>) =>\n        new TypeOrTsDsl(...args),\n\n      /** Creates a type parameter (e.g. `<T>`). */\n      param: (...args: ConstructorParameters<typeof TypeParamTsDsl>) =>\n        new TypeParamTsDsl(...args),\n\n      /** Creates a type query node (e.g. `typeof Foo`). */\n      query: (...args: ConstructorParameters<typeof TypeQueryTsDsl>) =>\n        new TypeQueryTsDsl(...args),\n\n      /** Builds a TypeScript template literal *type* (e.g. `${Foo}-${Bar}` as a type). */\n      template: (...args: ConstructorParameters<typeof TypeTemplateTsDsl>) =>\n        new TypeTemplateTsDsl(...args),\n\n      /** Creates a tuple type (e.g. [A, B, C]). */\n      tuple: (...args: ConstructorParameters<typeof TypeTupleTsDsl>) =>\n        new TypeTupleTsDsl(...args),\n    },\n  ),\n\n  /** Creates a `typeof` expression (e.g. `typeof value`). */\n  typeofExpr: (...args: ConstructorParameters<typeof TypeOfExprTsDsl>) =>\n    new TypeOfExprTsDsl(...args),\n\n  /** Creates a variable declaration (`var`). */\n  var: (...args: ConstructorParameters<typeof VarTsDsl>) =>\n    new VarTsDsl(...args),\n};\n\nexport const $ = Object.assign(\n  (...args: ConstructorParameters<typeof ExprTsDsl>) => new ExprTsDsl(...args),\n  tsDsl,\n);\n\nexport type DollarTsDsl = {\n  /**\n   * Entry point to the TypeScript DSL.\n   *\n   * `$` creates a general expression node by default, but also exposes\n   * builders for all other constructs such as `.type()`, `.call()`,\n   * `.object()`, `.func()`, etc.\n   *\n   * Example:\n   * ```ts\n   * const node = $('console').attr('log').call($.literal('Hello'));\n   * ```\n   *\n   * Returns:\n   * - A new `ExprTsDsl` instance when called directly.\n   * - The `tsDsl` object for constructing more specific nodes.\n   */\n  $: typeof $;\n};\n\nexport type { MaybeTsDsl, TypeTsDsl } from './base';\nexport { TsDsl } from './base';\nexport { TsDslContext } from './utils/context';\nexport { keywords } from './utils/keywords';\nexport { regexp } from './utils/regexp';\nexport { TypeScriptRenderer } from './utils/render';\nexport { reserved } from './utils/reserved';\n","import type { Casing, NamingConfig, NamingRule } from './types';\n\nconst uppercaseRegExp = /[\\p{Lu}]/u;\nconst lowercaseRegExp = /[\\p{Ll}]/u;\nconst identifierRegExp = /([\\p{Alpha}\\p{N}_]|$)/u;\nconst separatorsRegExp = /[_.$+:\\- `\\\\[\\](){}\\\\/]+/;\n\nconst leadingSeparatorsRegExp = new RegExp(`^${separatorsRegExp.source}`);\nconst separatorsAndIdentifierRegExp = new RegExp(\n  `${separatorsRegExp.source}${identifierRegExp.source}`,\n  'gu',\n);\nconst numbersAndIdentifierRegExp = new RegExp(\n  `\\\\d+${identifierRegExp.source}`,\n  'gu',\n);\n\nconst preserveCase = (value: string, casing: Casing) => {\n  let isLastCharLower = false;\n  let isLastCharUpper = false;\n  let isLastLastCharUpper = false;\n  let isLastLastCharPreserved = false;\n\n  const separator =\n    casing === 'snake_case' || casing === 'SCREAMING_SNAKE_CASE' ? '_' : '-';\n\n  for (let index = 0; index < value.length; index++) {\n    const character = value[index]!;\n    isLastLastCharPreserved = index > 2 ? value[index - 3] === separator : true;\n\n    let nextIndex = index + 1;\n    let nextCharacter = value[nextIndex];\n    separatorsRegExp.lastIndex = 0;\n    while (nextCharacter && separatorsRegExp.test(nextCharacter)) {\n      nextIndex += 1;\n      nextCharacter = value[nextIndex];\n    }\n    const isSeparatorBeforeNextCharacter = nextIndex !== index + 1;\n\n    lowercaseRegExp.lastIndex = 0;\n    uppercaseRegExp.lastIndex = 0;\n    if (\n      uppercaseRegExp.test(character) &&\n      (isLastCharLower ||\n        (nextCharacter &&\n          !isSeparatorBeforeNextCharacter &&\n          nextCharacter !== 's' &&\n          lowercaseRegExp.test(nextCharacter)))\n    ) {\n      // insert separator behind character\n      value = `${value.slice(0, index)}${separator}${value.slice(index)}`;\n      index++;\n      isLastLastCharUpper = isLastCharUpper;\n      isLastCharLower = false;\n      isLastCharUpper = true;\n    } else if (\n      isLastCharUpper &&\n      isLastLastCharUpper &&\n      lowercaseRegExp.test(character) &&\n      !isLastLastCharPreserved &&\n      // naive detection of plurals\n      !(\n        character === 's' &&\n        (!nextCharacter || nextCharacter.toLocaleLowerCase() !== nextCharacter)\n      )\n    ) {\n      // insert separator 2 characters behind\n      value = `${value.slice(0, index - 1)}${separator}${value.slice(index - 1)}`;\n      isLastLastCharUpper = isLastCharUpper;\n      isLastCharLower = true;\n      isLastCharUpper = false;\n    } else {\n      const characterLower = character.toLocaleLowerCase();\n      const characterUpper = character.toLocaleUpperCase();\n      isLastLastCharUpper = isLastCharUpper;\n      isLastCharLower =\n        characterLower === character && characterUpper !== character;\n      isLastCharUpper =\n        characterUpper === character && characterLower !== character;\n    }\n  }\n\n  return value;\n};\n\n/**\n * Convert a string to the specified casing.\n *\n * @param value - The string to convert\n * @param casing - The target casing\n * @param options - Additional options\n * @returns The converted string\n */\nexport const toCase = (\n  value: string,\n  casing: Casing | undefined,\n  options: {\n    /**\n     * If leading separators have a semantic meaning, we might not want to\n     * remove them.\n     */\n    stripLeadingSeparators?: boolean;\n  } = {},\n) => {\n  const stripLeadingSeparators = options.stripLeadingSeparators ?? true;\n\n  let result = value.trim();\n\n  if (!result.length || !casing || casing === 'preserve') {\n    return result;\n  }\n\n  if (result.length === 1) {\n    separatorsRegExp.lastIndex = 0;\n    if (separatorsRegExp.test(result)) {\n      return '';\n    }\n\n    return casing === 'PascalCase' || casing === 'SCREAMING_SNAKE_CASE'\n      ? result.toLocaleUpperCase()\n      : result.toLocaleLowerCase();\n  }\n\n  const hasUpperCase = result !== result.toLocaleLowerCase();\n\n  if (hasUpperCase) {\n    result = preserveCase(result, casing);\n  }\n\n  if (stripLeadingSeparators || result[0] !== value[0]) {\n    result = result.replace(leadingSeparatorsRegExp, '');\n  }\n\n  result =\n    casing === 'SCREAMING_SNAKE_CASE'\n      ? result.toLocaleUpperCase()\n      : result.toLocaleLowerCase();\n\n  if (casing === 'PascalCase') {\n    result = `${result.charAt(0).toLocaleUpperCase()}${result.slice(1)}`;\n  }\n\n  if (casing === 'snake_case' || casing === 'SCREAMING_SNAKE_CASE') {\n    result = result.replaceAll(\n      separatorsAndIdentifierRegExp,\n      (match, identifier, offset) => {\n        if (offset === 0 && !stripLeadingSeparators) {\n          return match;\n        }\n        return `_${identifier}`;\n      },\n    );\n\n    if (result[result.length - 1] === '_') {\n      // strip trailing underscore\n      result = result.slice(0, result.length - 1);\n    }\n  } else {\n    separatorsAndIdentifierRegExp.lastIndex = 0;\n    numbersAndIdentifierRegExp.lastIndex = 0;\n\n    result = result.replaceAll(\n      numbersAndIdentifierRegExp,\n      (match, _, offset) => {\n        if (['_', '-', '.'].includes(result.charAt(offset + match.length))) {\n          return match;\n        }\n\n        return match.toLocaleUpperCase();\n      },\n    );\n\n    result = result.replaceAll(\n      separatorsAndIdentifierRegExp,\n      (match, identifier, offset) => {\n        if (\n          offset === 0 &&\n          !stripLeadingSeparators &&\n          match[0] &&\n          value.startsWith(match[0])\n        ) {\n          return match;\n        }\n        return identifier.toLocaleUpperCase();\n      },\n    );\n  }\n\n  return result;\n};\n\n/**\n * Normalize a NamingRule to NamingConfig.\n */\nexport function resolveNaming(rule: NamingRule | undefined): NamingConfig {\n  if (!rule) {\n    return {};\n  }\n  if (typeof rule === 'string' || typeof rule === 'function') {\n    return { name: rule };\n  }\n  return rule;\n}\n\n/**\n * Apply naming configuration to a value.\n *\n * Casing is applied first, then transformation.\n */\nexport function applyNaming(value: string, config: NamingConfig): string {\n  let result = value;\n\n  const casing = config.casing ?? config.case;\n\n  if (config.name) {\n    if (typeof config.name === 'function') {\n      result = config.name(result);\n    } else {\n      // TODO: refactor so there's no need for separators?\n      const separator = !casing || casing === 'preserve' ? '' : '-';\n      result = config.name.replace(\n        '{{name}}',\n        `${separator}${result}${separator}`,\n      );\n    }\n  }\n\n  // TODO: apply case before name?\n  return toCase(result, casing);\n}\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport { $ } from '~/ts-dsl';\n\nimport type { HeyApiSdkPlugin } from '../types';\n\nexport const createRegistryClass = ({\n  plugin,\n  sdkSymbol,\n  symbol,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n  sdkSymbol: Symbol;\n  symbol: Symbol;\n}): ReturnType<typeof $.class> => {\n  const symbolDefaultKey = plugin.symbol('defaultKey');\n  const symbolInstances = plugin.symbol('instances');\n  return $.class(symbol)\n    .generic('T')\n    .field(symbolDefaultKey, (f) =>\n      f.private().readonly().assign($.literal('default')),\n    )\n    .newline()\n    .field(symbolInstances, (f) =>\n      f\n        .private()\n        .readonly()\n        .type($.type('Map').generics('string', 'T'))\n        .assign($.new('Map')),\n    )\n    .newline()\n    .method('get', (m) =>\n      m\n        .returns('T')\n        .param('key', (p) => p.type('string').optional())\n        .do(\n          $.const('instance').assign(\n            $('this')\n              .attr(symbolInstances)\n              .attr('get')\n              .call($('key').coalesce($('this').attr(symbolDefaultKey))),\n          ),\n          $.if($.not('instance')).do(\n            $.throw('Error').message(\n              $.template('No SDK client found. Create one with \"new ')\n                .add(sdkSymbol)\n                .add('()\" to fix this error.'),\n            ),\n          ),\n          $.return('instance'),\n        ),\n    )\n    .newline()\n    .method('set', (m) =>\n      m\n        .returns('void')\n        .param('value', (p) => p.type('T'))\n        .param('key', (p) => p.type('string').optional())\n        .do(\n          $('this')\n            .attr(symbolInstances)\n            .attr('set')\n            .call($('key').coalesce($('this').attr(symbolDefaultKey)), 'value'),\n        ),\n    );\n};\n\nexport const createClientClass = ({\n  plugin,\n  symbol,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n  symbol: Symbol;\n}): ReturnType<typeof $.class> => {\n  const symClient = plugin.getSymbol({ category: 'client' });\n  const optionalClient = Boolean(plugin.config.client && symClient);\n  const symbolClient = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'client.Client',\n  });\n  return $.class(symbol)\n    .field('client', (f) => f.protected().type(symbolClient))\n    .newline()\n    .init((i) =>\n      i\n        .param('args', (p) =>\n          p\n            .optional(optionalClient)\n            .type(\n              $.type\n                .object()\n                .prop('client', (p) =>\n                  p.optional(optionalClient).type(symbolClient),\n                ),\n            ),\n        )\n        .do(\n          $('this')\n            .attr('client')\n            .assign(\n              $('args')\n                .attr('client')\n                .optional(optionalClient)\n                .$if(optionalClient, (a) => a.coalesce(symClient!)),\n            ),\n        ),\n    );\n};\n","export const nuxtTypeComposable = 'TComposable';\nexport const nuxtTypeDefault = 'DefaultT';\nexport const nuxtTypeResponse = 'ResT';\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\n\nimport type { Auth } from '../../client-core/bundle/auth';\nimport type { HeyApiSdkPlugin } from '../types';\n\n// TODO: parser - handle more security types\nconst securitySchemeObjectToAuthObject = ({\n  securitySchemeObject,\n}: {\n  securitySchemeObject: IR.SecurityObject;\n}): Auth | undefined => {\n  if (securitySchemeObject.type === 'openIdConnect') {\n    return {\n      scheme: 'bearer',\n      type: 'http',\n    };\n  }\n\n  if (securitySchemeObject.type === 'oauth2') {\n    if (\n      securitySchemeObject.flows.password ||\n      securitySchemeObject.flows.authorizationCode ||\n      securitySchemeObject.flows.clientCredentials ||\n      securitySchemeObject.flows.implicit\n    ) {\n      return {\n        scheme: 'bearer',\n        type: 'http',\n      };\n    }\n\n    return;\n  }\n\n  if (securitySchemeObject.type === 'apiKey') {\n    if (securitySchemeObject.in === 'header') {\n      return {\n        name: securitySchemeObject.name,\n        type: 'apiKey',\n      };\n    }\n\n    if (\n      securitySchemeObject.in === 'query' ||\n      securitySchemeObject.in == 'cookie'\n    ) {\n      return {\n        in: securitySchemeObject.in,\n        name: securitySchemeObject.name,\n        type: 'apiKey',\n      };\n    }\n\n    return;\n  }\n\n  if (securitySchemeObject.type === 'http') {\n    const scheme = securitySchemeObject.scheme.toLowerCase();\n    if (scheme === 'bearer' || scheme === 'basic') {\n      return {\n        scheme: scheme as 'bearer' | 'basic',\n        type: 'http',\n      };\n    }\n\n    return;\n  }\n\n  return;\n};\n\nexport const operationAuth = ({\n  operation,\n  plugin,\n}: {\n  context: Context;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): Array<Auth> => {\n  if (!operation.security || !plugin.config.auth) {\n    return [];\n  }\n\n  const auth: Array<Auth> = [];\n\n  for (const securitySchemeObject of operation.security) {\n    const authObject = securitySchemeObjectToAuthObject({\n      securitySchemeObject,\n    });\n    if (authObject) {\n      auth.push(authObject);\n    } else {\n      console.warn(\n        `‚ùóÔ∏è SDK warning: unsupported security scheme. Please open an issue if you'd like it added https://github.com/hey-api/openapi-ts/issues\\n${JSON.stringify(securitySchemeObject, null, 2)}`,\n      );\n    }\n  }\n\n  return auth;\n};\n","const jsonPointerSlash = /~1/g;\nconst jsonPointerTilde = /~0/g;\n\n/**\n * Returns the reusable component name from `$ref`.\n */\nexport const refToName = ($ref: string): string => {\n  const path = jsonPointerToPath($ref);\n  const name = path[path.length - 1]!;\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  return decodeURI(name);\n};\n\n/**\n * Encodes a path segment for use in a JSON Pointer (RFC 6901).\n *\n * - Replaces all '~' with '~0'.\n * - Replaces all '/' with '~1'.\n *\n * This ensures that path segments containing these characters are safely\n * represented in JSON Pointer strings.\n *\n * @param segment - The path segment (string or number) to encode.\n * @returns The encoded segment as a string.\n */\nexport const encodeJsonPointerSegment = (segment: string | number): string =>\n  String(segment).replace(/~/g, '~0').replace(/\\//g, '~1');\n\n/**\n * Converts a JSON Pointer string (RFC 6901) to an array of path segments.\n *\n * - Removes the leading '#' if present.\n * - Splits the pointer on '/'.\n * - Decodes '~1' to '/' and '~0' to '~' in each segment.\n * - Returns an empty array for the root pointer ('#' or '').\n *\n * @param pointer - The JSON Pointer string to convert (e.g., '#/components/schemas/Foo').\n * @returns An array of decoded path segments.\n */\nexport const jsonPointerToPath = (pointer: string): ReadonlyArray<string> => {\n  let clean = pointer.trim();\n  if (clean.startsWith('#')) {\n    clean = clean.slice(1);\n  }\n  if (clean.startsWith('/')) {\n    clean = clean.slice(1);\n  }\n  if (!clean) {\n    return [];\n  }\n  return clean\n    .split('/')\n    .map((part) =>\n      part.replace(jsonPointerSlash, '/').replace(jsonPointerTilde, '~'),\n    );\n};\n\n/**\n * Normalizes a JSON Pointer string to a canonical form.\n *\n * - Ensures the pointer starts with '#'.\n * - Removes trailing slashes (except for root).\n * - Collapses multiple consecutive slashes into one.\n * - Trims whitespace from the input.\n *\n * @param pointer - The JSON Pointer string to normalize.\n * @returns The normalized JSON Pointer string.\n */\nexport const normalizeJsonPointer = (pointer: string): string => {\n  let normalized = pointer.trim();\n  if (!normalized.startsWith('#')) {\n    normalized = `#${normalized}`;\n  }\n  // Remove trailing slashes (except for root)\n  if (normalized.length > 1 && normalized.endsWith('/')) {\n    normalized = normalized.slice(0, -1);\n  }\n  // Collapse multiple slashes\n  normalized = normalized.replace(/\\/+/g, '/');\n  return normalized;\n};\n\n/**\n * Encode path as JSON Pointer (RFC 6901).\n *\n * @param path\n * @returns\n */\nexport const pathToJsonPointer = (\n  path: ReadonlyArray<string | number>,\n): string => {\n  const segments = path.map(encodeJsonPointerSegment).join('/');\n  return '#' + (segments ? `/${segments}` : '');\n};\n\nexport const resolveRef = <T>({\n  $ref,\n  spec,\n}: {\n  $ref: string;\n  spec: Record<string, any>;\n}): T => {\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  const path = jsonPointerToPath(decodeURI($ref));\n\n  let current = spec;\n\n  for (const part of path) {\n    const segment = part as keyof typeof current;\n    if (current[segment] === undefined) {\n      throw new Error(`Reference not found: ${$ref}`);\n    }\n    current = current[segment];\n  }\n\n  return current as T;\n};\n","import type { IR } from '~/ir/types';\nimport type { PluginInstance } from '~/plugins/shared/utils/instance';\nimport { toCase } from '~/utils/naming';\nimport { refToName } from '~/utils/ref';\n\nimport type { Field } from '../../client-core/bundle/params';\n\ntype Location = keyof IR.ParametersObject | 'body';\n\ntype SignatureParameter = {\n  /**\n   * Is this parameter required in the SDK method signature?\n   */\n  isRequired: boolean;\n  /**\n   * Parameter name in the SDK method signature.\n   */\n  name: string;\n  /**\n   * If the name was modified due to conflicts, this holds the original name.\n   */\n  originalName?: string;\n  /**\n   * Parameter schema object.\n   */\n  schema: IR.SchemaObject;\n};\n\ntype SignatureParameters = Record<string, SignatureParameter>;\n\ntype Signature = {\n  fields: ReadonlyArray<Field>;\n  parameters: SignatureParameters;\n};\n\n/**\n * Collects and resolves all operation parameters for flattened SDK signatures.\n * - Prefixes all conflicting names with their location (e.g. path_foo, query_foo)\n * - Returns a flat map of resolved parameter names to their metadata\n */\nexport const getSignatureParameters = ({\n  operation,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): Signature | undefined => {\n  // TODO: add cookies\n  const locations = [\n    'header',\n    'path',\n    'query',\n  ] as const satisfies ReadonlyArray<Location>;\n  const nameToLocations: Record<string, Set<Location>> = {};\n\n  const addParameter = (name: string, location: Location): void => {\n    if (!nameToLocations[name]) {\n      nameToLocations[name] = new Set();\n    }\n    nameToLocations[name].add(location);\n  };\n\n  for (const location of locations) {\n    const parameters = operation.parameters?.[location];\n    if (parameters) {\n      for (const key in parameters) {\n        const parameter = parameters[key]!;\n        addParameter(parameter.name, location);\n      }\n    }\n  }\n\n  if (operation.body) {\n    // spread body if there's only a single object\n    if (\n      !operation.body.schema.logicalOperator &&\n      operation.body.schema.type === 'object' &&\n      operation.body.schema.properties\n    ) {\n      const properties = operation.body.schema.properties;\n      for (const key in properties) {\n        addParameter(key, 'body');\n      }\n    } else if (operation.body.schema.$ref) {\n      // alias body for more ergonomic naming, e.g. user if the type is User\n      const name = refToName(operation.body.schema.$ref);\n      const key = toCase(name, 'camelCase');\n      addParameter(key, 'body');\n    } else {\n      addParameter('body', 'body');\n    }\n  }\n\n  const conflicts = new Set<string>();\n  for (const name in nameToLocations) {\n    if (nameToLocations[name]!.size > 1) {\n      conflicts.add(name);\n    }\n  }\n\n  const signatureParameters: SignatureParameters = {};\n  const fields: Array<Field> = [];\n\n  for (const location of locations) {\n    const parameters = operation.parameters?.[location];\n    if (parameters) {\n      for (const key in parameters) {\n        const parameter = parameters[key]!;\n        const originalName = parameter.name;\n        const name = conflicts.has(originalName)\n          ? `${location}_${originalName}`\n          : originalName;\n        const signatureParameter: SignatureParameter = {\n          isRequired: parameter.required ?? false,\n          name,\n          schema: parameter.schema,\n        };\n        if (name !== originalName) {\n          signatureParameter.originalName = originalName;\n        }\n        signatureParameters[name] = signatureParameter;\n        fields.push({\n          in: location === 'header' ? 'headers' : location,\n          key: name,\n          ...(name !== originalName ? { map: originalName } : {}),\n        });\n      }\n    }\n  }\n\n  if (operation.body) {\n    const location = 'body';\n    if (\n      !operation.body.schema.logicalOperator &&\n      operation.body.schema.type === 'object' &&\n      operation.body.schema.properties\n    ) {\n      const properties = operation.body.schema.properties;\n      for (const originalName in properties) {\n        const property = properties[originalName]!;\n        const name = conflicts.has(originalName)\n          ? `${location}_${originalName}`\n          : originalName;\n        const signatureParameter: SignatureParameter = {\n          isRequired: property.required?.includes(originalName) ?? false,\n          name,\n          schema: property,\n        };\n        if (name !== originalName) {\n          signatureParameter.originalName = originalName;\n        }\n        signatureParameters[name] = signatureParameter;\n        fields.push({\n          in: location,\n          key: name,\n          ...(name !== originalName ? { map: originalName } : {}),\n        });\n      }\n    } else if (operation.body.schema.$ref) {\n      const value = refToName(operation.body.schema.$ref);\n      const originalName = toCase(value, 'camelCase');\n      const name = conflicts.has(originalName)\n        ? `${location}_${originalName}`\n        : originalName;\n      const signatureParameter: SignatureParameter = {\n        isRequired: operation.body.required ?? false,\n        name,\n        schema: operation.body.schema,\n      };\n      if (name !== originalName) {\n        signatureParameter.originalName = originalName;\n      }\n      signatureParameters[name] = signatureParameter;\n      fields.push({\n        key: name,\n        map: 'body',\n      });\n    } else {\n      // never alias body\n      signatureParameters.body = {\n        isRequired: operation.body.required ?? false,\n        name: 'body',\n        schema: operation.body.schema,\n      };\n      fields.push({ in: 'body' });\n    }\n  }\n\n  if (!Object.keys(signatureParameters).length) {\n    return;\n  }\n\n  return { fields, parameters: signatureParameters };\n};\n","import type { IR } from '~/ir/types';\nimport type { $ } from '~/ts-dsl';\n\nimport type { HeyApiSdkPlugin } from '../types';\n\ninterface ValidatorProps {\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}\n\nexport const createRequestValidator = ({\n  operation,\n  plugin,\n}: ValidatorProps): ReturnType<typeof $.func> | undefined => {\n  if (!plugin.config.validator.request) return;\n\n  const validator = plugin.getPluginOrThrow(plugin.config.validator.request);\n  if (!validator.api.createRequestValidator) return;\n\n  return validator.api.createRequestValidator({\n    operation,\n    // @ts-expect-error\n    plugin: validator,\n  });\n};\n\nexport const createResponseValidator = ({\n  operation,\n  plugin,\n}: ValidatorProps): ReturnType<typeof $.func> | undefined => {\n  if (!plugin.config.validator.response) return;\n\n  const validator = plugin.getPluginOrThrow(plugin.config.validator.response);\n  if (!validator.api.createResponseValidator) return;\n\n  return validator.api.createResponseValidator({\n    operation,\n    // @ts-expect-error\n    plugin: validator,\n  });\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport { refs } from '@hey-api/codegen-core';\n\nimport { statusCodeToGroup } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { $ } from '~/ts-dsl';\n\nimport type { Field, Fields } from '../../client-core/bundle/params';\nimport type { HeyApiSdkPlugin } from '../types';\nimport { isInstance } from '../v1/node';\nimport { operationAuth } from './auth';\nimport { nuxtTypeComposable, nuxtTypeDefault } from './constants';\nimport { getSignatureParameters } from './signature';\nimport { createRequestValidator, createResponseValidator } from './validator';\n\n/** TODO: needs complete refactor */\nexport const operationOptionsType = ({\n  isDataAllowed = true,\n  operation,\n  plugin,\n  throwOnError,\n}: {\n  isDataAllowed?: boolean;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n  throwOnError?: string;\n}): ReturnType<typeof $.type> => {\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const symbolDataType = isDataAllowed\n    ? plugin.querySymbol({\n        category: 'type',\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'data',\n        tool: 'typescript',\n      })\n    : undefined;\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n\n  if (isNuxtClient) {\n    const symbolResponseType = plugin.querySymbol({\n      category: 'type',\n      resource: 'operation',\n      resourceId: operation.id,\n      role: 'response',\n    });\n    return $.type(symbolOptions)\n      .generic(nuxtTypeComposable)\n      .generic(isDataAllowed ? (symbolDataType ?? 'unknown') : 'never')\n      .generic(symbolResponseType ?? 'unknown')\n      .generic(nuxtTypeDefault);\n  }\n\n  // TODO: refactor this to be more generic, works for now\n  if (throwOnError) {\n    return $.type(symbolOptions)\n      .generic(isDataAllowed ? (symbolDataType ?? 'unknown') : 'never')\n      .generic(throwOnError);\n  }\n  return $.type(symbolOptions).$if(!isDataAllowed || symbolDataType, (t) =>\n    t.generic(isDataAllowed ? symbolDataType! : 'never'),\n  );\n};\n\ntype OperationParameters = {\n  argNames: Array<string>;\n  fields: Array<Field | Fields>;\n  parameters: Array<ReturnType<typeof $.param>>;\n};\n\nexport const operationParameters = ({\n  isRequiredOptions,\n  operation,\n  plugin,\n}: {\n  isRequiredOptions: boolean;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): OperationParameters => {\n  const result: OperationParameters = {\n    argNames: [],\n    fields: [],\n    parameters: [],\n  };\n\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  if (plugin.config.paramsStructure === 'flat') {\n    const signature = getSignatureParameters({ operation, plugin });\n    const flatParams = $.type.object();\n\n    if (signature) {\n      let isParametersRequired = false;\n\n      for (const key in signature.parameters) {\n        const parameter = signature.parameters[key]!;\n        if (parameter.isRequired) {\n          isParametersRequired = true;\n        }\n        flatParams.prop(parameter.name, (p) =>\n          p.required(parameter.isRequired).type(\n            pluginTypeScript.api.schemaToType({\n              plugin: pluginTypeScript,\n              schema: parameter.schema,\n              state: refs({\n                path: [],\n              }),\n            }),\n          ),\n        );\n      }\n\n      result.argNames.push('parameters');\n      for (const field of signature.fields) {\n        result.fields.push(field);\n      }\n\n      result.parameters.push(\n        $.param('parameters', (p) =>\n          p.required(isParametersRequired).type(flatParams),\n        ),\n      );\n    }\n  }\n\n  result.parameters.push(\n    $.param('options', (p) =>\n      p.required(isRequiredOptions).type(\n        operationOptionsType({\n          isDataAllowed: plugin.config.paramsStructure === 'grouped',\n          operation,\n          plugin,\n          throwOnError: isNuxtClient ? undefined : 'ThrowOnError',\n        }),\n      ),\n    ),\n  );\n\n  return result;\n};\n\n/**\n * Infers `responseType` value from provided response content type. This is\n * an adapted version of `getParseAs()` from the Fetch API client.\n *\n * From Axios documentation:\n * `responseType` indicates the type of data that the server will respond with\n * options are: 'arraybuffer', 'document', 'json', 'text', 'stream'\n * browser only: 'blob'\n */\nconst getResponseType = (\n  contentType: string | null | undefined,\n):\n  | 'arraybuffer'\n  | 'blob'\n  | 'document'\n  | 'json'\n  | 'stream'\n  | 'text'\n  | undefined => {\n  if (!contentType) {\n    return;\n  }\n\n  const cleanContent = contentType.split(';')[0]?.trim();\n\n  if (!cleanContent) {\n    return;\n  }\n\n  if (\n    cleanContent.startsWith('application/json') ||\n    cleanContent.endsWith('+json')\n  ) {\n    return 'json';\n  }\n\n  // Axios does not handle form data out of the box\n  // if (cleanContent === 'multipart/form-data') {\n  //   return 'formData';\n  // }\n\n  if (\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\n      cleanContent.startsWith(type),\n    )\n  ) {\n    return 'blob';\n  }\n\n  if (cleanContent.startsWith('text/')) {\n    return 'text';\n  }\n\n  return;\n};\n\nexport const operationStatements = ({\n  isRequiredOptions,\n  opParameters,\n  operation,\n  plugin,\n}: {\n  isRequiredOptions: boolean;\n  opParameters: OperationParameters;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): Array<ReturnType<typeof $.return | typeof $.const>> => {\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: isNuxtClient ? 'response' : 'responses',\n  });\n\n  const symbolErrorType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: isNuxtClient ? 'error' : 'errors',\n  });\n\n  // TODO: transform parameters\n  // const query = {\n  //   BarBaz: options.query.bar_baz,\n  //   qux_quux: options.query.qux_quux,\n  //   fooBar: options.query.foo_bar,\n  // };\n\n  // if (operation.parameters) {\n  //   for (const name in operation.parameters.query) {\n  //     const parameter = operation.parameters.query[name]\n  //     if (parameter.name !== fieldName({ context, name: parameter.name })) {\n  //       console.warn(parameter.name)\n  //     }\n  //   }\n  // }\n\n  const reqOptions = $.object();\n\n  if (operation.body) {\n    switch (operation.body.type) {\n      case 'form-data': {\n        const symbol = plugin.referenceSymbol({\n          category: 'external',\n          resource: 'client.formDataBodySerializer',\n        });\n        reqOptions.spread(symbol);\n        break;\n      }\n      case 'json':\n        // jsonBodySerializer is the default, no need to specify\n        break;\n      case 'text':\n      case 'octet-stream':\n        // ensure we don't use any serializer by default\n        reqOptions.prop('bodySerializer', $.literal(null));\n        break;\n      case 'url-search-params': {\n        const symbol = plugin.referenceSymbol({\n          category: 'external',\n          resource: 'client.urlSearchParamsBodySerializer',\n        });\n        reqOptions.spread(symbol);\n        break;\n      }\n    }\n  }\n\n  // TODO: parser - set parseAs to skip inference if every response has the same\n  // content type. currently impossible because successes do not contain\n  // header information\n\n  const paramSerializers = $.object();\n\n  for (const name in operation.parameters?.query) {\n    const parameter = operation.parameters.query[name]!;\n\n    if (\n      parameter.schema.type === 'array' ||\n      parameter.schema.type === 'tuple'\n    ) {\n      if (parameter.style !== 'form' || !parameter.explode) {\n        // override the default settings for array serialization\n        paramSerializers.prop(\n          parameter.name,\n          $.object().prop(\n            'array',\n            $.object()\n              .$if(parameter.explode === false, (o) =>\n                o.prop('explode', $.literal(parameter.explode)),\n              )\n              .$if(parameter.style !== 'form', (o) =>\n                o.prop('style', $.literal(parameter.style)),\n              ),\n          ),\n        );\n      }\n    } else if (parameter.schema.type === 'object') {\n      if (parameter.style !== 'deepObject' || !parameter.explode) {\n        // override the default settings for object serialization\n        paramSerializers.prop(\n          parameter.name,\n          $.object().prop(\n            'object',\n            $.object()\n              .$if(parameter.explode === false, (o) =>\n                o.prop('explode', $.literal(parameter.explode)),\n              )\n              .$if(parameter.style !== 'deepObject', (o) =>\n                o.prop('style', $.literal(parameter.style)),\n              ),\n          ),\n        );\n      }\n    }\n  }\n\n  if (paramSerializers.hasProps()) {\n    // TODO: if all parameters have the same serialization,\n    // apply it globally to reduce output size\n    reqOptions.prop(\n      'querySerializer',\n      $.object().prop('parameters', paramSerializers),\n    );\n  }\n\n  const requestValidator = createRequestValidator({ operation, plugin });\n  const responseValidator = createResponseValidator({ operation, plugin });\n  if (requestValidator) {\n    reqOptions.prop('requestValidator', requestValidator.arrow());\n  }\n\n  if (plugin.config.transformer) {\n    const query: SymbolMeta = {\n      category: 'transform',\n      resource: 'operation',\n      resourceId: operation.id,\n      role: 'response',\n    };\n    if (plugin.isSymbolRegistered(query)) {\n      const ref = plugin.referenceSymbol(query);\n      reqOptions.prop('responseTransformer', $(ref));\n    }\n  }\n\n  let hasServerSentEvents = false;\n  let responseTypeValue: ReturnType<typeof getResponseType> | undefined;\n\n  for (const statusCode in operation.responses) {\n    const response = operation.responses[statusCode]!;\n\n    // try to infer `responseType` option for Axios. We don't need this in\n    // Fetch API client because it automatically detects the correct response\n    // during runtime.\n    if (!responseTypeValue && client.name === '@hey-api/client-axios') {\n      // this doesn't handle default status code for now\n      if (statusCodeToGroup({ statusCode }) === '2XX') {\n        responseTypeValue = getResponseType(response.mediaType);\n        if (responseTypeValue) {\n          reqOptions.prop('responseType', $.literal(responseTypeValue));\n        }\n      }\n    }\n\n    if (response.mediaType === 'text/event-stream') {\n      hasServerSentEvents = true;\n    }\n  }\n\n  if (responseValidator) {\n    reqOptions.prop('responseValidator', responseValidator.arrow());\n  }\n\n  if (plugin.config.responseStyle === 'data') {\n    reqOptions.prop('responseStyle', $.literal(plugin.config.responseStyle));\n  }\n\n  const auth = operationAuth({ context: plugin.context, operation, plugin });\n  if (auth.length) {\n    reqOptions.prop('security', $.fromValue(auth));\n  }\n\n  reqOptions.prop('url', $.literal(operation.path));\n\n  // options must go last to allow overriding parameters above\n  reqOptions.spread('options');\n\n  const statements: Array<ReturnType<typeof $.return | typeof $.const>> = [];\n  const hasParams = opParameters.argNames.length;\n\n  if (hasParams) {\n    const args: Array<ReturnType<typeof $.expr>> = [];\n    const config: Array<ReturnType<typeof $.object>> = [];\n    for (const argName of opParameters.argNames) {\n      args.push($(argName));\n    }\n    for (const field of opParameters.fields) {\n      const shape = $.object();\n      if ('in' in field) {\n        shape.prop('in', $.literal(field.in));\n      }\n      if ('key' in field) {\n        if (field.key) {\n          shape.prop('key', $.literal(field.key));\n        }\n        if (field.map) {\n          shape.prop('map', $.literal(field.map));\n        }\n      }\n      config.push(shape);\n    }\n    const symbol = plugin.referenceSymbol({\n      category: 'external',\n      resource: 'client.buildClientParams',\n    });\n    statements.push(\n      $.const('params').assign(\n        $(symbol).call(\n          $.array(...args),\n          $.array($.object().prop('args', $.array(...config))),\n        ),\n      ),\n    );\n    reqOptions.spread('params');\n  }\n\n  if (operation.body) {\n    const parameterContentType = operation.parameters?.header?.['content-type'];\n    const hasRequiredContentType = Boolean(parameterContentType?.required);\n    // spreading required Content-Type on generated header would throw a TypeScript error\n    if (!hasRequiredContentType) {\n      const headers = $.object()\n        .pretty()\n        // form-data does not need Content-Type header, browser will set it automatically\n        .prop(\n          parameterContentType?.name ?? 'Content-Type',\n          $.literal(\n            operation.body.type === 'form-data'\n              ? null\n              : operation.body.mediaType,\n          ),\n        )\n        .spread($('options').attr('headers').required(isRequiredOptions));\n      if (hasParams) {\n        headers.spread($('params').attr('headers'));\n      }\n      reqOptions.prop('headers', headers);\n    }\n  }\n\n  const symbolClient = plugin.config.client\n    ? plugin.getSymbol({\n        category: 'client',\n      })\n    : undefined;\n\n  let clientExpression: ReturnType<typeof $.attr | typeof $.binary>;\n  const optionsClient = $('options').attr('client').required(isRequiredOptions);\n  if (isInstance(plugin)) {\n    clientExpression = optionsClient.coalesce($('this').attr('client'));\n  } else if (symbolClient) {\n    clientExpression = optionsClient.coalesce(symbolClient);\n  } else {\n    clientExpression = optionsClient;\n  }\n\n  let functionName = hasServerSentEvents\n    ? clientExpression.attr('sse')\n    : clientExpression;\n  functionName = functionName.attr(operation.method);\n\n  statements.push(\n    $.return(\n      functionName\n        .call(reqOptions)\n        .$if(\n          isNuxtClient,\n          (f) =>\n            f\n              .generic(nuxtTypeComposable)\n              .generic(\n                $.type.or(symbolResponseType ?? 'unknown', nuxtTypeDefault),\n              )\n              .generic(symbolErrorType ?? 'unknown')\n              .generic(nuxtTypeDefault),\n          (f) =>\n            f\n              .generic(symbolResponseType ?? 'unknown')\n              .generic(symbolErrorType ?? 'unknown')\n              .generic('ThrowOnError'),\n        )\n        .$if(plugin.config.responseStyle === 'data', (f) =>\n          f.generic($.type.literal(plugin.config.responseStyle)),\n        ),\n    ),\n  );\n\n  return statements;\n};\n","import type {\n  StructureItem,\n  StructureNode,\n  StructureShell,\n  Symbol,\n  SymbolMeta,\n} from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming, toCase } from '~/utils/naming';\n\nimport { createClientClass, createRegistryClass } from '../shared/class';\nimport { nuxtTypeComposable, nuxtTypeDefault } from '../shared/constants';\nimport { operationParameters, operationStatements } from '../shared/operation';\nimport type { HeyApiSdkPlugin } from '../types';\n\nexport interface OperationItem {\n  operation: IR.OperationObject;\n  path: ReadonlyArray<string | number>;\n  tags: ReadonlyArray<string> | undefined;\n}\n\nexport const source = globalThis.Symbol('@hey-api/sdk');\n\nexport function isInstance(plugin: HeyApiSdkPlugin['Instance']): boolean {\n  const config = plugin.config.operations;\n  return (\n    config.container === 'class' &&\n    config.methods === 'instance' &&\n    config.strategy !== 'flat'\n  );\n}\n\nfunction attachComment<\n  T extends ReturnType<typeof $.var | typeof $.method>,\n>(args: { node: T; operation: IR.OperationObject }): T {\n  const { node, operation } = args;\n  return node.$if(createOperationComment(operation), (n, v) => n.doc(v)) as T;\n}\n\nfunction createShellMeta(node: StructureNode): SymbolMeta {\n  return {\n    category: 'utility',\n    resource: 'class',\n    resourceId: node.getPath().join('.'),\n    tool: 'sdk',\n  };\n}\n\nfunction createFnSymbol(\n  plugin: HeyApiSdkPlugin['Instance'],\n  item: StructureItem & { data: OperationItem },\n): Symbol {\n  const { operation, path, tags } = item.data;\n  const name = item.location[item.location.length - 1]!;\n  return plugin.symbol(applyNaming(name, plugin.config.operations.methodName), {\n    meta: {\n      category: 'sdk',\n      path,\n      resource: 'operation',\n      resourceId: operation.id,\n      tags,\n      tool: 'sdk',\n    },\n  });\n}\n\nfunction childToNode(\n  resource: StructureNode,\n  plugin: HeyApiSdkPlugin['Instance'],\n): ReadonlyArray<ReturnType<typeof $.field | typeof $.getter>> {\n  const refChild = plugin.referenceSymbol(createShellMeta(resource));\n  const memberNameStr = toCase(\n    refChild.name,\n    plugin.config.operations.methodName.casing ?? 'camelCase',\n  );\n  const memberName = plugin.symbol(memberNameStr);\n  if (isInstance(plugin)) {\n    const privateName = plugin.symbol(`_${memberNameStr}`);\n    return [\n      $.field(privateName, (f) => f.private().optional().type(refChild)),\n      $.getter(memberName, (g) =>\n        g.returns(refChild).do(\n          $('this')\n            .attr(privateName)\n            .nullishAssign(\n              $.new(refChild).args(\n                $.object().prop('client', $('this').attr('client')),\n              ),\n            )\n            .return(),\n        ),\n      ),\n    ];\n  }\n  if (plugin.isSymbolRegistered(refChild.id)) {\n    return [$.field(memberName, (f) => f.static().assign($(refChild)))];\n  }\n  return [\n    $.getter(memberName, (g) => g.public().static().do($.return(refChild))),\n  ];\n}\n\nexport function createShell(\n  plugin: HeyApiSdkPlugin['Instance'],\n): StructureShell {\n  const client = getClientPlugin(plugin.context.config);\n  const isAngularClient = client.name === '@hey-api/client-angular';\n  return {\n    define: (node) => {\n      const symbol = plugin.symbol(\n        applyNaming(\n          node.name,\n          node.isRoot\n            ? plugin.config.operations.containerName\n            : plugin.config.operations.segmentName,\n        ),\n        {\n          meta: createShellMeta(node),\n        },\n      );\n\n      // if (plugin.config.operations.container === 'object') {\n      //   const o = $.const(symbol).export().assign($.object());\n      //   return { dependencies: [], node: o };\n      // }\n\n      const c = $.class(symbol)\n        .export()\n        .$if(isInstance(plugin), (c) =>\n          c.extends(\n            plugin.referenceSymbol({\n              category: 'utility',\n              resource: 'class',\n              resourceId: 'HeyApiClient',\n              tool: 'sdk',\n            }),\n          ),\n        )\n        .$if(isAngularClient && node.isRoot, (c) =>\n          c.decorator(\n            plugin.external('@angular/core.Injectable'),\n            $.object().prop('providedIn', $.literal('root')),\n          ),\n        );\n\n      const dependencies: Array<ReturnType<typeof $.class>> = [];\n\n      if (node.isRoot && isInstance(plugin)) {\n        enrichRootClass({\n          dependencies,\n          node: c,\n          plugin,\n          symbol,\n        });\n      }\n\n      return { dependencies, node: c };\n    },\n  };\n}\n\nfunction enrichRootClass(args: {\n  dependencies: Array<ReturnType<typeof $.class>>;\n  node: ReturnType<typeof $.class>;\n  plugin: HeyApiSdkPlugin['Instance'];\n  symbol: Symbol;\n}): void {\n  const { dependencies, node, plugin, symbol } = args;\n  const symbolClient = plugin.symbol('HeyApiClient', {\n    meta: {\n      category: 'utility',\n      resource: 'class',\n      resourceId: 'HeyApiClient',\n      tool: 'sdk',\n    },\n  });\n  dependencies.push(createClientClass({ plugin, symbol: symbolClient }));\n  const symbolRegistry = plugin.symbol('HeyApiRegistry', {\n    meta: {\n      category: 'utility',\n      resource: 'class',\n      resourceId: 'HeyApiRegistry',\n      tool: 'sdk',\n    },\n  });\n  dependencies.push(\n    createRegistryClass({\n      plugin,\n      sdkSymbol: symbol,\n      symbol: symbolRegistry,\n    }),\n  );\n  const isClientRequired =\n    !plugin.config.client || !plugin.getSymbol({ category: 'client' });\n  const registry = plugin.symbol('__registry');\n  node.toAccessNode = (node, options) => {\n    if (options.context) return;\n    return $(node.name).attr(registry).attr('get').call();\n  };\n  node.do(\n    $.field(registry, (f) =>\n      f\n        .public()\n        .static()\n        .readonly()\n        .assign($.new(symbolRegistry).generic(symbol)),\n    ),\n    $.newline(),\n    $.init((i) =>\n      i\n        .param('args', (p) =>\n          p.required(isClientRequired).type(\n            $.type\n              .object()\n              .prop('client', (p) =>\n                p\n                  .required(isClientRequired)\n                  .type(plugin.external('client.Client')),\n              )\n              .prop('key', (p) => p.optional().type('string')),\n          ),\n        )\n        .do(\n          $('super').call('args'),\n          $(symbol)\n            .attr(registry)\n            .attr('set')\n            .call('this', $('args').attr('key').required(isClientRequired)),\n        ),\n    ),\n  );\n}\n\nfunction implementFn<\n  T extends ReturnType<typeof $.func | typeof $.method>,\n>(args: {\n  node: T;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): T {\n  const { node, operation, plugin } = args;\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n  const opParameters = operationParameters({\n    isRequiredOptions,\n    operation,\n    plugin,\n  });\n  const statements = operationStatements({\n    isRequiredOptions,\n    opParameters,\n    operation,\n    plugin,\n  });\n  return node\n    .$if(\n      isNuxtClient,\n      (m) =>\n        m\n          .generic(nuxtTypeComposable, (t) =>\n            t\n              .extends(plugin.external('client.Composable'))\n              .default($.type.literal('$fetch')),\n          )\n          .generic(nuxtTypeDefault, (t) =>\n            t.$if(\n              plugin.querySymbol({\n                category: 'type',\n                resource: 'operation',\n                resourceId: operation.id,\n                role: 'response',\n              }),\n              (t, s) => t.extends(s).default(s),\n              (t) => t.default('undefined'),\n            ),\n          ),\n      (m) =>\n        m.generic('ThrowOnError', (t) =>\n          t\n            .extends('boolean')\n            .default(\n              ('throwOnError' in client.config\n                ? client.config.throwOnError\n                : false) ?? false,\n            ),\n        ),\n    )\n    .params(...opParameters.parameters)\n    .do(...statements) as T;\n}\n\nexport function toNode(\n  model: StructureNode,\n  plugin: HeyApiSdkPlugin['Instance'],\n): {\n  dependencies?: Array<ReturnType<typeof $.class | typeof $.var>>;\n  nodes: ReadonlyArray<ReturnType<typeof $.class | typeof $.var>>;\n} {\n  if (model.virtual) {\n    const nodes: Array<ReturnType<typeof $.var>> = [];\n    for (const item of model.itemsFrom<OperationItem>(source)) {\n      const { operation } = item.data;\n      let node = $.const(createFnSymbol(plugin, item))\n        .export()\n        .assign(\n          implementFn({\n            node: $.func(),\n            operation,\n            plugin,\n          }),\n        );\n      node = attachComment({ node, operation });\n      nodes.push(node);\n    }\n    return { nodes };\n  }\n\n  if (!model.shell) {\n    return { nodes: [] };\n  }\n\n  const nodes: Array<ReturnType<typeof $.class | typeof $.var>> = [];\n\n  const client = getClientPlugin(plugin.context.config);\n  const isAngularClient = client.name === '@hey-api/client-angular';\n\n  const shell = model.shell.define(model);\n  const node = shell.node as ReturnType<typeof $.class | typeof $.var>;\n\n  let index = 0;\n  for (const item of model.itemsFrom<OperationItem>(source)) {\n    const { operation } = item.data;\n    if (node['~dsl'] === 'VarTsDsl') {\n      // TODO: object\n    } else {\n      if (index > 0 || node.hasBody) node.newline();\n      node.do(\n        implementFn({\n          node: $.method(createFnSymbol(plugin, item), (m) =>\n            attachComment({\n              node: m,\n              operation,\n            })\n              .public()\n              .static(!isAngularClient && !isInstance(plugin)),\n          ),\n          operation,\n          plugin,\n        }),\n      );\n    }\n    index += 1;\n  }\n\n  for (const child of model.children.values()) {\n    if (node['~dsl'] === 'VarTsDsl') {\n      // TODO: object\n    } else {\n      if (node.hasBody) node.newline();\n      node.do(...childToNode(child, plugin));\n    }\n  }\n\n  nodes.push(node);\n\n  return {\n    dependencies: shell.dependencies as Array<\n      ReturnType<typeof $.class | typeof $.var>\n    >,\n    nodes,\n  };\n}\n","import { EOL } from 'node:os';\n\nexport const escapeComment = (value: string) =>\n  value\n    .replace(/\\*\\//g, '*')\n    .replace(/\\/\\*/g, '*')\n    .replace(/\\r?\\n(.*)/g, (_l, w) => EOL + w.trim());\n","import type { Context } from '~/ir/context';\nimport { hasOperationDataRequired } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport type { HeyApiSdkPlugin } from '~/plugins/@hey-api/sdk';\nimport { isInstance } from '~/plugins/@hey-api/sdk/v1/node';\nimport { escapeComment } from '~/utils/escape';\n\nexport const createOperationComment = (\n  operation: IR.OperationObject,\n): ReadonlyArray<string> | undefined => {\n  const comments: Array<string> = [];\n\n  if (operation.summary) {\n    comments.push(escapeComment(operation.summary));\n  }\n\n  if (operation.description) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line between summary and description\n    }\n\n    comments.push(escapeComment(operation.description));\n  }\n\n  if (operation.deprecated) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line before deprecated\n    }\n\n    comments.push('@deprecated');\n  }\n\n  return comments.length ? comments : undefined;\n};\n\n/**\n * TODO: replace with plugin logic...\n *\n * @deprecated this needs to be refactored\n */\nexport const isOperationOptionsRequired = ({\n  context,\n  operation,\n}: {\n  context: Context;\n  operation: IR.OperationObject;\n}): boolean => {\n  const client = getClientPlugin(context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const plugin = context.config.plugins['@hey-api/sdk'];\n  if (plugin) {\n    if (\n      !plugin.config.client &&\n      !isInstance(plugin as unknown as HeyApiSdkPlugin['Instance'])\n    ) {\n      return true;\n    }\n    if (plugin.config.paramsStructure === 'flat') {\n      return false;\n    }\n  }\n  return isNuxtClient || hasOperationDataRequired(operation);\n};\n\nexport const hasOperationSse = ({\n  operation,\n}: {\n  operation: IR.OperationObject;\n}): boolean => {\n  for (const statusCode in operation.responses) {\n    const response = operation.responses[statusCode]!;\n    if (response.mediaType === 'text/event-stream') {\n      return true;\n    }\n  }\n  return false;\n};\n","import type {\n  StructureItem,\n  StructureNode,\n  StructureShell,\n  Symbol,\n  SymbolMeta,\n} from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming, toCase } from '~/utils/naming';\n\nimport type { AngularCommonPlugin } from '../types';\n\nexport interface OperationItem {\n  operation: IR.OperationObject;\n}\n\nexport const source = globalThis.Symbol('@angular/common');\n\nfunction attachComment<\n  T extends ReturnType<typeof $.var | typeof $.method>,\n>(args: { node: T; operation: IR.OperationObject }): T {\n  const { node, operation } = args;\n  return node.$if(createOperationComment(operation), (n, v) => n.doc(v)) as T;\n}\n\nfunction createHttpRequestFnMeta(operation: IR.OperationObject): SymbolMeta {\n  return {\n    category: 'utility',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'request',\n    tool: 'angular',\n  };\n}\n\nfunction createHttpRequestShellMeta(node: StructureNode): SymbolMeta {\n  return {\n    category: 'utility',\n    resource: 'shell',\n    resourceId: node.getPath().join('.'),\n    role: 'request',\n    tool: 'angular',\n  };\n}\n\nfunction createHttpResourceFnMeta(operation: IR.OperationObject): SymbolMeta {\n  return {\n    category: 'utility',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'resource',\n    tool: 'angular',\n  };\n}\n\nfunction createHttpResourceShellMeta(node: StructureNode): SymbolMeta {\n  return {\n    category: 'utility',\n    resource: 'shell',\n    resourceId: node.getPath().join('.'),\n    role: 'resource',\n    tool: 'angular',\n  };\n}\n\nfunction createHttpRequestFnSymbol(\n  plugin: AngularCommonPlugin['Instance'],\n  item: StructureItem & { data: OperationItem },\n): Symbol {\n  const { operation } = item.data;\n  const name = item.location[item.location.length - 1]!;\n  return plugin.symbol(\n    applyNaming(name, plugin.config.httpRequests.methodName),\n    {\n      meta: createHttpRequestFnMeta(operation),\n    },\n  );\n}\n\nfunction createHttpResourceFnSymbol(\n  plugin: AngularCommonPlugin['Instance'],\n  item: StructureItem & { data: OperationItem },\n): Symbol {\n  const { operation } = item.data;\n  const name = item.location[item.location.length - 1]!;\n  return plugin.symbol(\n    applyNaming(name, plugin.config.httpResources.methodName),\n    {\n      meta: createHttpResourceFnMeta(operation),\n    },\n  );\n}\n\nfunction childToHttpRequestNode(\n  resource: StructureNode,\n  plugin: AngularCommonPlugin['Instance'],\n): ReadonlyArray<ReturnType<typeof $.field | typeof $.getter>> {\n  const refChild = plugin.referenceSymbol(createHttpRequestShellMeta(resource));\n  const memberNameStr = toCase(refChild.name, 'camelCase');\n  const memberName = plugin.symbol(memberNameStr);\n  const privateName = plugin.symbol(`_${memberNameStr}`);\n  return [\n    $.field(privateName, (f) => f.private().optional().type(refChild)),\n    $.getter(memberName, (g) =>\n      g\n        .returns(refChild)\n        .do(\n          $('this')\n            .attr(privateName)\n            .nullishAssign($.new(refChild).args())\n            .return(),\n        ),\n    ),\n  ];\n}\n\nfunction childToHttpResourceNode(\n  resource: StructureNode,\n  plugin: AngularCommonPlugin['Instance'],\n): ReadonlyArray<ReturnType<typeof $.field | typeof $.getter>> {\n  const refChild = plugin.referenceSymbol(\n    createHttpResourceShellMeta(resource),\n  );\n  const memberNameStr = toCase(refChild.name, 'camelCase');\n  const memberName = plugin.symbol(memberNameStr);\n  const privateName = plugin.symbol(`_${memberNameStr}`);\n  return [\n    $.field(privateName, (f) => f.private().optional().type(refChild)),\n    $.getter(memberName, (g) =>\n      g\n        .returns(refChild)\n        .do(\n          $('this')\n            .attr(privateName)\n            .nullishAssign($.new(refChild).args())\n            .return(),\n        ),\n    ),\n  ];\n}\n\nexport function createHttpRequestShell(\n  plugin: AngularCommonPlugin['Instance'],\n): StructureShell {\n  const client = getClientPlugin(plugin.context.config);\n  const isAngularClient = client.name === '@hey-api/client-angular';\n\n  const symbolInjectable = plugin.external('@angular/core.Injectable');\n\n  return {\n    define: (node) => {\n      const symbol = plugin.symbol(\n        applyNaming(\n          node.name,\n          node.isRoot\n            ? plugin.config.httpRequests.containerName\n            : plugin.config.httpRequests.segmentName,\n        ),\n        {\n          meta: createHttpRequestShellMeta(node),\n        },\n      );\n\n      const c = $.class(symbol)\n        .export()\n        .$if(isAngularClient && node.isRoot, (c) =>\n          c.decorator(\n            symbolInjectable,\n            $.object().prop('providedIn', $.literal('root')),\n          ),\n        );\n\n      return { dependencies: [], node: c };\n    },\n  };\n}\n\nexport function createHttpResourceShell(\n  plugin: AngularCommonPlugin['Instance'],\n): StructureShell {\n  const client = getClientPlugin(plugin.context.config);\n  const isAngularClient = client.name === '@hey-api/client-angular';\n\n  const symbolInjectable = plugin.external('@angular/core.Injectable');\n\n  return {\n    define: (node) => {\n      const symbol = plugin.symbol(\n        applyNaming(\n          node.name,\n          node.isRoot\n            ? plugin.config.httpResources.containerName\n            : plugin.config.httpResources.segmentName,\n        ),\n        {\n          meta: createHttpResourceShellMeta(node),\n        },\n      );\n\n      const c = $.class(symbol)\n        .export()\n        .$if(isAngularClient && node.isRoot, (c) =>\n          c.decorator(\n            symbolInjectable,\n            $.object().prop('providedIn', $.literal('root')),\n          ),\n        );\n\n      return { dependencies: [], node: c };\n    },\n  };\n}\n\nfunction implementHttpRequestFn<\n  T extends ReturnType<typeof $.func | typeof $.method>,\n>(args: {\n  node: T;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}): T {\n  const { node, operation, plugin } = args;\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n\n  const symbolHttpRequest = plugin.external('@angular/common/http.HttpRequest');\n  const symbolClient = plugin.getSymbol({ category: 'client' });\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolDataType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'typescript',\n  });\n\n  return node\n    .param('options', (p) =>\n      p.required(isRequiredOptions).type(\n        $.type(symbolOptions)\n          .generic(symbolDataType ?? 'unknown')\n          .generic('ThrowOnError'),\n      ),\n    )\n    .generic('ThrowOnError', (g) => g.extends('boolean').default(false))\n    .returns($.type(symbolHttpRequest).generic('unknown'))\n    .do(\n      $.return(\n        $('options')\n          .attr('client')\n          .optional()\n          .$if(symbolClient, (c, s) => c.coalesce(s))\n          .attr('requestOptions')\n          .call(\n            $.object()\n              .prop('responseStyle', $.literal('data'))\n              .prop('method', $.literal(operation.method.toUpperCase()))\n              .prop('url', $.literal(operation.path))\n              .spread('options'),\n          ),\n      ),\n    ) as T;\n}\n\nfunction implementHttpResourceFn<\n  T extends ReturnType<typeof $.func | typeof $.method>,\n>(args: {\n  node: T;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}): T {\n  const { node, operation, plugin } = args;\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n\n  const symbolHttpResource = plugin.external(\n    '@angular/common/http.httpResource',\n  );\n  const symbolInject = plugin.external('@angular/core.inject');\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolDataType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'typescript',\n  });\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'response',\n  });\n\n  return node\n    .param('options', (p) =>\n      p.required(isRequiredOptions).type(\n        $.type.func().returns(\n          $.type.or(\n            $.type(symbolOptions)\n              .generic(symbolDataType ?? 'unknown')\n              .generic('ThrowOnError'),\n            $.type('undefined'),\n          ),\n        ),\n      ),\n    )\n    .generic('ThrowOnError', (g) => g.extends('boolean').default(false))\n    .do(\n      $.return(\n        $(symbolHttpResource)\n          .call(\n            $.func().do(\n              $.const('opts').assign(\n                $.ternary('options')\n                  .do($('options').call())\n                  .otherwise($.id('undefined')),\n              ),\n              $.return(\n                $.ternary('opts')\n                  .do(\n                    $.lazy((ctx) =>\n                      ctx\n                        .access(\n                          plugin.referenceSymbol(\n                            createHttpRequestFnMeta(operation),\n                          ),\n                          {\n                            transform: (node, index) =>\n                              index === 0\n                                ? node['~dsl'] === 'ClassTsDsl'\n                                  ? $(symbolInject).call($(node.name))\n                                  : $(node.name)\n                                : node,\n                          },\n                        )\n                        .call('opts'),\n                    ),\n                  )\n                  .otherwise($.id('undefined')),\n              ),\n            ),\n          )\n          .generic(symbolResponseType ?? 'unknown'),\n      ),\n    ) as T;\n}\n\nexport function toHttpRequestNode(\n  model: StructureNode,\n  plugin: AngularCommonPlugin['Instance'],\n): {\n  dependencies?: Array<ReturnType<typeof $.class | typeof $.var>>;\n  nodes: ReadonlyArray<ReturnType<typeof $.class | typeof $.var>>;\n} {\n  if (model.virtual) {\n    const nodes: Array<ReturnType<typeof $.var>> = [];\n    for (const item of model.itemsFrom<OperationItem>(source)) {\n      const { operation } = item.data;\n      let node = $.const(createHttpRequestFnSymbol(plugin, item))\n        .export()\n        .assign(\n          implementHttpRequestFn({\n            node: $.func(),\n            operation,\n            plugin,\n          }),\n        );\n      node = attachComment({ node, operation });\n      nodes.push(node);\n    }\n    return { nodes };\n  }\n\n  if (!model.shell) {\n    return { nodes: [] };\n  }\n\n  const nodes: Array<ReturnType<typeof $.class>> = [];\n\n  const shell = model.shell.define(model);\n  const node = shell.node as ReturnType<typeof $.class>;\n\n  let index = 0;\n  for (const item of model.itemsFrom<OperationItem>(source)) {\n    const { operation } = item.data;\n    if (index > 0 || node.hasBody) node.newline();\n    node.do(\n      implementHttpRequestFn({\n        node: $.method(createHttpRequestFnSymbol(plugin, item), (m) =>\n          attachComment({\n            node: m,\n            operation,\n          }).public(),\n        ),\n        operation,\n        plugin,\n      }),\n    );\n    index += 1;\n  }\n\n  for (const child of model.children.values()) {\n    if (node.hasBody) node.newline();\n    node.do(...childToHttpRequestNode(child, plugin));\n  }\n\n  nodes.push(node);\n\n  return {\n    dependencies: shell.dependencies as Array<ReturnType<typeof $.class>>,\n    nodes,\n  };\n}\n\nexport function toHttpResourceNode(\n  model: StructureNode,\n  plugin: AngularCommonPlugin['Instance'],\n): {\n  dependencies?: Array<ReturnType<typeof $.class | typeof $.var>>;\n  nodes: ReadonlyArray<ReturnType<typeof $.class | typeof $.var>>;\n} {\n  if (model.virtual) {\n    const nodes: Array<ReturnType<typeof $.var>> = [];\n    for (const item of model.itemsFrom<OperationItem>(source)) {\n      const { operation } = item.data;\n      let node = $.const(createHttpResourceFnSymbol(plugin, item))\n        .export()\n        .assign(\n          implementHttpResourceFn({\n            node: $.func(),\n            operation,\n            plugin,\n          }),\n        );\n      node = attachComment({ node, operation });\n      nodes.push(node);\n    }\n    return { nodes };\n  }\n\n  if (!model.shell) {\n    return { nodes: [] };\n  }\n\n  const nodes: Array<ReturnType<typeof $.class>> = [];\n\n  const shell = model.shell.define(model);\n  const node = shell.node as ReturnType<typeof $.class>;\n\n  let index = 0;\n  for (const item of model.itemsFrom<OperationItem>(source)) {\n    const { operation } = item.data;\n    if (index > 0 || node.hasBody) node.newline();\n    node.do(\n      implementHttpResourceFn({\n        node: $.method(createHttpResourceFnSymbol(plugin, item), (m) =>\n          attachComment({\n            node: m,\n            operation,\n          }).public(),\n        ),\n        operation,\n        plugin,\n      }),\n    );\n    index += 1;\n  }\n\n  for (const child of model.children.values()) {\n    if (node.hasBody) node.newline();\n    node.do(...childToHttpResourceNode(child, plugin));\n  }\n\n  nodes.push(node);\n\n  return {\n    dependencies: shell.dependencies as Array<ReturnType<typeof $.class>>,\n    nodes,\n  };\n}\n","import { StructureModel } from '@hey-api/codegen-core';\n\nimport type { $ } from '~/ts-dsl';\n\nimport { resolveHttpRequestsStrategy } from './httpRequests';\nimport { resolveHttpResourcesStrategy } from './httpResources';\nimport type { OperationItem } from './shared/node';\nimport {\n  createHttpRequestShell,\n  createHttpResourceShell,\n  source,\n  toHttpRequestNode,\n  toHttpResourceNode,\n} from './shared/node';\nimport type { AngularCommonPlugin } from './types';\n\nexport const handler: AngularCommonPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('HttpRequest', {\n    external: '@angular/common/http',\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: '@angular/common/http.HttpRequest',\n    },\n  });\n  plugin.symbol('inject', {\n    external: '@angular/core',\n    meta: {\n      category: 'external',\n      resource: '@angular/core.inject',\n    },\n  });\n  plugin.symbol('Injectable', {\n    external: '@angular/core',\n    meta: {\n      category: 'external',\n      resource: '@angular/core.Injectable',\n    },\n  });\n  plugin.symbol('httpResource', {\n    external: '@angular/common/http',\n    meta: {\n      category: 'external',\n      resource: '@angular/common/http.httpResource',\n    },\n  });\n\n  const httpRequestStructure = new StructureModel();\n  const httpResourceStructure = new StructureModel();\n\n  if (plugin.config.httpRequests.enabled) {\n    const shell = createHttpRequestShell(plugin);\n    const strategy = resolveHttpRequestsStrategy(plugin);\n\n    plugin.forEach(\n      'operation',\n      ({ operation }) => {\n        httpRequestStructure.insert({\n          data: {\n            operation,\n          } satisfies OperationItem,\n          locations: strategy(operation).map((path) => ({ path, shell })),\n          source,\n        });\n      },\n      { order: 'declarations' },\n    );\n  }\n\n  if (plugin.config.httpResources.enabled) {\n    const shell = createHttpResourceShell(plugin);\n    const strategy = resolveHttpResourcesStrategy(plugin);\n\n    plugin.forEach(\n      'operation',\n      ({ operation }) => {\n        httpResourceStructure.insert({\n          data: {\n            operation,\n          } satisfies OperationItem,\n          locations: strategy(operation).map((path) => ({ path, shell })),\n          source,\n        });\n      },\n      { order: 'declarations' },\n    );\n  }\n\n  const allDependencies: Array<ReturnType<typeof $.class | typeof $.var>> = [];\n  const allNodes: Array<ReturnType<typeof $.class | typeof $.var>> = [];\n\n  for (const node of httpRequestStructure.walk()) {\n    const { dependencies, nodes } = toHttpRequestNode(node, plugin);\n    allDependencies.push(...(dependencies ?? []));\n    allNodes.push(...nodes);\n  }\n  for (const node of httpResourceStructure.walk()) {\n    const { dependencies, nodes } = toHttpResourceNode(node, plugin);\n    allDependencies.push(...(dependencies ?? []));\n    allNodes.push(...nodes);\n  }\n\n  const uniqueDependencies = new Map<\n    number,\n    ReturnType<typeof $.class | typeof $.var>\n  >();\n  for (const dep of allDependencies) {\n    if (dep.symbol) uniqueDependencies.set(dep.symbol.id, dep);\n  }\n  for (const dep of uniqueDependencies.values()) {\n    plugin.node(dep);\n  }\n\n  for (const node of allNodes) {\n    plugin.node(node);\n  }\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { resolveHttpRequests } from './httpRequests';\nimport { resolveHttpResources } from './httpResources';\nimport { handler } from './plugin';\nimport type { AngularCommonPlugin } from './types';\n\nexport const defaultConfig: AngularCommonPlugin['Config'] = {\n  config: {\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/client-angular', '@hey-api/sdk'],\n  handler,\n  name: '@angular/common',\n  resolveConfig: (plugin, context) => {\n    plugin.config.httpRequests = resolveHttpRequests(plugin.config, context);\n    plugin.config.httpResources = resolveHttpResources(plugin.config, context);\n  },\n};\n\n/**\n * Type helper for `@angular/common` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","export const clientDefaultConfig = {\n  baseUrl: true,\n  bundle: true,\n  exportFromIndex: false,\n} as const;\n\nexport const clientDefaultMeta = {\n  dependencies: ['@hey-api/typescript'],\n  tags: ['client'],\n} as const;\n","import fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nimport type { IProject, ProjectRenderMeta } from '@hey-api/codegen-core';\n\nimport type { DefinePlugin } from '~/plugins';\nimport type { Client } from '~/plugins/@hey-api/client-core/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport type { Config } from '~/types/config';\n\nimport { ensureDirSync } from './utils';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n/**\n * Returns absolute path to the client folder. This is hard-coded for now.\n */\nexport const clientFolderAbsolutePath = (config: Config): string => {\n  const client = getClientPlugin(config);\n\n  if ('bundle' in client.config && client.config.bundle) {\n    // not proud of this one\n    const renamed: Map<string, string> | undefined =\n      // @ts-expect-error\n      config._FRAGILE_CLIENT_BUNDLE_RENAMED;\n    return path.resolve(\n      config.output.path,\n      'client',\n      `${renamed?.get('index') ?? 'index'}.ts`,\n    );\n  }\n\n  return client.name;\n};\n\n/**\n * Recursively copies files and directories.\n * This is a PnP-compatible alternative to fs.cpSync that works with Yarn PnP's\n * virtualized filesystem.\n */\nconst copyRecursivePnP = (src: string, dest: string) => {\n  const stat = fs.statSync(src);\n\n  if (stat.isDirectory()) {\n    if (!fs.existsSync(dest)) {\n      fs.mkdirSync(dest, { recursive: true });\n    }\n\n    const files = fs.readdirSync(src);\n    for (const file of files) {\n      copyRecursivePnP(path.join(src, file), path.join(dest, file));\n    }\n  } else {\n    const content = fs.readFileSync(src);\n    fs.writeFileSync(dest, content);\n  }\n};\n\nconst renameFile = ({\n  filePath,\n  project,\n  renamed,\n}: {\n  filePath: string;\n  project: IProject;\n  renamed: Map<string, string>;\n}) => {\n  const extension = path.extname(filePath);\n  const name = path.basename(filePath, extension);\n  const renamedName = project.fileName?.(name) || name;\n  if (renamedName !== name) {\n    const outputPath = path.dirname(filePath);\n    fs.renameSync(\n      filePath,\n      path.resolve(outputPath, `${renamedName}${extension}`),\n    );\n    renamed.set(name, renamedName);\n  }\n};\n\nconst replaceImports = ({\n  filePath,\n  meta,\n  renamed,\n}: {\n  filePath: string;\n  meta: ProjectRenderMeta;\n  renamed: Map<string, string>;\n}) => {\n  let content = fs.readFileSync(filePath, 'utf8');\n\n  content = content.replace(\n    /from\\s+['\"](\\.\\.?\\/[^'\"]*?)['\"]/g,\n    (match, importPath) => {\n      const importIndex = match.indexOf(importPath);\n      const extension = path.extname(importPath);\n      const fileName = path.basename(importPath, extension);\n      const importDir = path.dirname(importPath);\n      const replacedName =\n        (renamed.get(fileName) ?? fileName) +\n        (meta.importFileExtension ? meta.importFileExtension : extension);\n      const replacedMatch =\n        match.slice(0, importIndex) +\n        [importDir, replacedName].filter(Boolean).join('/') +\n        match.slice(importIndex + importPath.length);\n      return replacedMatch;\n    },\n  );\n\n  const header = '// This file is auto-generated by @hey-api/openapi-ts\\n\\n';\n\n  content = `${header}${content}`;\n\n  fs.writeFileSync(filePath, content, 'utf8');\n};\n\n/**\n * Creates a `client` folder containing the same modules as the client package.\n */\nexport const generateClientBundle = ({\n  meta,\n  outputPath,\n  plugin,\n  project,\n}: {\n  meta: ProjectRenderMeta;\n  outputPath: string;\n  plugin: DefinePlugin<Client.Config & { name: string }>['Config'];\n  project?: IProject;\n}): Map<string, string> | undefined => {\n  const renamed = new Map<string, string>();\n\n  // copy Hey API clients to output\n  const isHeyApiClientPlugin = plugin.name.startsWith('@hey-api/client-');\n  if (isHeyApiClientPlugin) {\n    // copy client core\n    const coreOutputPath = path.resolve(outputPath, 'core');\n    ensureDirSync(coreOutputPath);\n    const coreDistPath = path.resolve(__dirname, 'clients', 'core');\n    copyRecursivePnP(coreDistPath, coreOutputPath);\n\n    // copy client bundle\n    const clientOutputPath = path.resolve(outputPath, 'client');\n    ensureDirSync(clientOutputPath);\n    const clientDistFolderName = plugin.name.slice('@hey-api/client-'.length);\n    const clientDistPath = path.resolve(\n      __dirname,\n      'clients',\n      clientDistFolderName,\n    );\n    copyRecursivePnP(clientDistPath, clientOutputPath);\n\n    if (project) {\n      const copiedCoreFiles = fs.readdirSync(coreOutputPath);\n      for (const file of copiedCoreFiles) {\n        renameFile({\n          filePath: path.resolve(coreOutputPath, file),\n          project,\n          renamed,\n        });\n      }\n\n      const copiedClientFiles = fs.readdirSync(clientOutputPath);\n      for (const file of copiedClientFiles) {\n        renameFile({\n          filePath: path.resolve(clientOutputPath, file),\n          project,\n          renamed,\n        });\n      }\n    }\n\n    const coreFiles = fs.readdirSync(coreOutputPath);\n    for (const file of coreFiles) {\n      replaceImports({\n        filePath: path.resolve(coreOutputPath, file),\n        meta,\n        renamed,\n      });\n    }\n\n    const clientFiles = fs.readdirSync(clientOutputPath);\n    for (const file of clientFiles) {\n      replaceImports({\n        filePath: path.resolve(clientOutputPath, file),\n        meta,\n        renamed,\n      });\n    }\n    return renamed;\n  }\n\n  const clientSrcPath = path.isAbsolute(plugin.name)\n    ? path.dirname(plugin.name)\n    : undefined;\n\n  // copy custom local client to output\n  if (clientSrcPath) {\n    const dirPath = path.resolve(outputPath, 'client');\n    ensureDirSync(dirPath);\n    copyRecursivePnP(clientSrcPath, dirPath);\n    return;\n  }\n\n  // copy third-party client to output\n  const clientModulePath = path.normalize(require.resolve(plugin.name));\n  const clientModulePathComponents = clientModulePath.split(path.sep);\n  const clientDistPath = clientModulePathComponents\n    .slice(0, clientModulePathComponents.indexOf('dist') + 1)\n    .join(path.sep);\n\n  const indexJsFile =\n    clientModulePathComponents[clientModulePathComponents.length - 1];\n  const distFiles = [indexJsFile!, 'index.d.mts', 'index.d.cts'];\n  const dirPath = path.resolve(outputPath, 'client');\n  ensureDirSync(dirPath);\n  for (const file of distFiles) {\n    fs.copyFileSync(\n      path.resolve(clientDistPath, file),\n      path.resolve(dirPath, file),\n    );\n  }\n\n  return;\n};\n","const parseUrlRegExp =\n  /^(([^:/?#]+):)?((\\/\\/)?([^:/?#]*)(:?([^/?#]*)))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\ninterface Url {\n  host: string;\n  path: string;\n  port: string;\n  protocol: string;\n}\n\nexport const parseUrl = (value: string): Url => {\n  const errorResponse: Url = {\n    host: '',\n    path: '',\n    port: '',\n    protocol: '',\n  };\n\n  parseUrlRegExp.lastIndex = 0;\n  const match = value.match(parseUrlRegExp);\n\n  if (!match) {\n    return errorResponse;\n  }\n\n  const host = match[5] || '';\n\n  // value is a relative file system path\n  if (host === '.' || host === '..') {\n    return errorResponse;\n  }\n\n  const path = match[8] || '';\n  const protocol = match[2] || '';\n\n  // value is probably a Windows file system path\n  if (protocol.length === 1) {\n    return errorResponse;\n  }\n\n  return {\n    host,\n    path: path === '/' ? '' : path,\n    port: match[7] || '',\n    protocol,\n  };\n};\n","import { clientFolderAbsolutePath } from '~/generate/client';\nimport { $ } from '~/ts-dsl';\nimport { parseUrl } from '~/utils/url';\n\nimport type { PluginHandler } from './types';\nimport { getClientBaseUrlKey } from './utils';\n\nconst resolveBaseUrlString = ({\n  plugin,\n}: Parameters<PluginHandler>[0]): string | undefined => {\n  const { baseUrl } = plugin.config;\n\n  if (baseUrl === false) {\n    return;\n  }\n\n  if (typeof baseUrl === 'string') {\n    return baseUrl;\n  }\n\n  const { servers } = plugin.context.ir;\n\n  if (!servers) {\n    return;\n  }\n\n  return servers[typeof baseUrl === 'number' ? baseUrl : 0]?.url;\n};\n\nexport const createClient: PluginHandler = ({ plugin }) => {\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const symbolCreateClient = plugin.symbol('createClient', {\n    external: clientModule,\n  });\n  const symbolCreateConfig = plugin.symbol('createConfig', {\n    external: clientModule,\n  });\n  const symbolClientOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client',\n    role: 'options',\n  });\n\n  const { runtimeConfigPath } = plugin.config;\n  const symbolCreateClientConfig = runtimeConfigPath\n    ? plugin.symbol('createClientConfig', {\n        external: runtimeConfigPath,\n      })\n    : undefined;\n\n  const defaultVals = $.object();\n\n  const resolvedBaseUrl = resolveBaseUrlString({\n    plugin: plugin as any,\n  });\n  if (resolvedBaseUrl) {\n    const url = parseUrl(resolvedBaseUrl);\n    if (url.protocol && url.host && !resolvedBaseUrl.includes('{')) {\n      defaultVals.prop(\n        getClientBaseUrlKey(plugin.context.config),\n        $.literal(resolvedBaseUrl),\n      );\n    } else if (resolvedBaseUrl !== '/' && resolvedBaseUrl.startsWith('/')) {\n      const baseUrl = resolvedBaseUrl.endsWith('/')\n        ? resolvedBaseUrl.slice(0, -1)\n        : resolvedBaseUrl;\n      defaultVals.prop(\n        getClientBaseUrlKey(plugin.context.config),\n        $.literal(baseUrl),\n      );\n    }\n  }\n\n  if ('throwOnError' in plugin.config && plugin.config.throwOnError) {\n    defaultVals.prop('throwOnError', $.literal(true));\n  }\n\n  const createConfigParameters = [\n    $(symbolCreateConfig)\n      .call(defaultVals.hasProps() ? defaultVals : undefined)\n      .generic(symbolClientOptions),\n  ];\n\n  const symbolClient = plugin.symbol('client', {\n    meta: {\n      category: 'client',\n    },\n  });\n  const statement = $.const(symbolClient)\n    .export()\n    .assign(\n      $(symbolCreateClient).$if(\n        symbolCreateClientConfig,\n        (c, s) => c.call($(s).call(...createConfigParameters)),\n        (c) => c.call(...createConfigParameters),\n      ),\n    );\n  plugin.node(statement);\n};\n","import { clientFolderAbsolutePath } from '~/generate/client';\nimport { $ } from '~/ts-dsl';\n\nimport type { PluginHandler } from './types';\n\nexport const createClientConfigType = ({\n  plugin,\n}: Parameters<PluginHandler>[0]) => {\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const symbolClientOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client',\n    role: 'options',\n  });\n  const symbolConfig = plugin.symbol('Config', {\n    external: clientModule,\n    kind: 'type',\n  });\n  const symbolDefaultClientOptions = plugin.symbol('ClientOptions', {\n    external: clientModule,\n    kind: 'type',\n  });\n  const symbolCreateClientConfig = plugin.symbol('CreateClientConfig');\n\n  const typeCreateClientConfig = $.type\n    .alias(symbolCreateClientConfig)\n    .export()\n    .doc([\n      'The `createClientConfig()` function will be called on client initialization',\n      \"and the returned object will become the client's initial configuration.\",\n      '',\n      'You may want to initialize your client this way instead of calling',\n      \"`setConfig()`. This is useful for example if you're using Next.js\",\n      'to ensure your client always has the correct values.',\n    ])\n    .generic('T', (g) =>\n      g.extends(symbolDefaultClientOptions).default(symbolClientOptions),\n    )\n    .type(\n      $.type\n        .func()\n        .param('override', (p) =>\n          p\n            .optional()\n            .type(\n              $.type(symbolConfig).generic(\n                $.type.and(symbolDefaultClientOptions, 'T'),\n              ),\n            ),\n        )\n        .returns(\n          $.type(symbolConfig).generic(\n            $.type.and(\n              $.type('Required').generic(symbolDefaultClientOptions),\n              'T',\n            ),\n          ),\n        ),\n    );\n  plugin.node(typeCreateClientConfig);\n};\n","import { createClient } from './client';\nimport { createClientConfigType } from './createClientConfig';\nimport type { PluginHandler } from './types';\n\nexport const clientPluginHandler = ({\n  plugin,\n}: Parameters<PluginHandler>[0]) => {\n  createClientConfigType({ plugin });\n  createClient({ plugin });\n};\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientAngularPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientAngularPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-angular',\n};\n\n/**\n * Type helper for `@hey-api/client-angular` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientAxiosPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientAxiosPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-axios',\n};\n\n/**\n * Type helper for `@hey-api/client-axios` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientFetchPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientFetchPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-fetch',\n};\n\n/**\n * Type helper for `@hey-api/client-fetch` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientKyPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientKyPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-ky',\n};\n\n/**\n * Type helper for `@hey-api/client-ky` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientNextPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientNextPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-next',\n};\n\n/**\n * Type helper for `@hey-api/client-next` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientNuxtPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientNuxtPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: clientDefaultConfig,\n  handler: clientPluginHandler,\n  name: '@hey-api/client-nuxt',\n};\n\n/**\n * Type helper for `@hey-api/client-nuxt` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '~/plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '~/plugins/@hey-api/client-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { HeyApiClientOfetchPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientOfetchPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-ofetch',\n};\n\n/**\n * Type helper for `@hey-api/client-ofetch` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { RangeOptions, SemVer } from 'semver';\nimport * as semver from 'semver';\n\nexport type Package = {\n  /**\n   * Get the installed version of a package.\n   * @param name The name of the package to get the version for.\n   * @returns A SemVer object containing version information, or undefined if the package is not installed\n   *         or the version string is invalid.\n   */\n  getVersion: (name: string) => SemVer | undefined;\n  /**\n   * Check if a given package is installed in the project.\n   * @param name The name of the package to check.\n   */\n  isInstalled: (name: string) => boolean;\n  /**\n   * Check if the installed version of a package or a given SemVer object satisfies a semver range.\n   * @param nameOrVersion The name of the package to check, or a SemVer object.\n   * @param range The semver range to check against.\n   * @returns True if the version satisfies the range, false otherwise.\n   */\n  satisfies: (\n    nameOrVersion: string | SemVer,\n    range: string,\n    optionsOrLoose?: boolean | RangeOptions,\n  ) => boolean;\n};\n\nexport const satisfies: typeof semver.satisfies = (...args) =>\n  semver.satisfies(...args);\n\nexport const packageFactory = (\n  dependencies: Record<string, string>,\n): Package => ({\n  getVersion: (name) => {\n    const version = dependencies[name];\n    if (!version) return;\n    try {\n      let parsed = semver.parse(version);\n      if (parsed) return parsed;\n\n      const min = semver.minVersion(version);\n      if (min) return min;\n\n      parsed = semver.coerce(version);\n      if (parsed) return parsed;\n    } catch {\n      // noop\n    }\n    return;\n  },\n  isInstalled: (name) => Boolean(dependencies[name]),\n  satisfies: (nameOrVersion, range, optionsOrLoose) => {\n    const version =\n      typeof nameOrVersion === 'string'\n        ? dependencies[nameOrVersion]\n        : nameOrVersion;\n    return version ? satisfies(version, range, optionsOrLoose) : false;\n  },\n});\n","import { satisfies } from '~/config/utils/package';\nimport type { Context } from '~/ir/context';\nimport type { OpenApiV2_0_XTypes } from '~/openApi/2.0.x';\nimport type { OpenApiV3_0_XTypes } from '~/openApi/3.0.x';\nimport type { OpenApiV3_1_XTypes } from '~/openApi/3.1.x';\nimport type { OpenApi } from '~/openApi/types';\nimport { $ } from '~/ts-dsl';\n\nimport type { HeyApiSchemasPlugin } from './types';\n\nconst stripSchema = ({\n  plugin,\n  schema,\n}: {\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema:\n    | OpenApiV2_0_XTypes['SchemaObject']\n    | OpenApiV3_0_XTypes['SchemaObject']\n    | OpenApiV3_1_XTypes['SchemaObject'];\n}) => {\n  if (plugin.config.type === 'form') {\n    if (schema.description) {\n      delete schema.description;\n    }\n\n    if (schema['x-enum-descriptions']) {\n      delete schema['x-enum-descriptions'];\n    }\n\n    if (schema['x-enum-varnames']) {\n      delete schema['x-enum-varnames'];\n    }\n\n    if (schema['x-enumNames']) {\n      delete schema['x-enumNames'];\n    }\n\n    if (schema.title) {\n      delete schema.title;\n    }\n  }\n};\n\nconst schemaToJsonSchemaDraft_04 = ({\n  context,\n  plugin,\n  schema: _schema,\n}: {\n  context: Context;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema: OpenApiV2_0_XTypes['SchemaObject'];\n}): OpenApiV2_0_XTypes['SchemaObject'] => {\n  if (Array.isArray(_schema)) {\n    return _schema.map((item) =>\n      schemaToJsonSchemaDraft_04({\n        context,\n        plugin,\n        schema: item,\n      }),\n    ) as unknown as OpenApiV2_0_XTypes['SchemaObject'];\n  }\n\n  const schema = structuredClone(_schema);\n\n  if (schema.$ref) {\n    // refs using unicode characters become encoded, didn't investigate why\n    // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n    schema.$ref = decodeURI(schema.$ref);\n    return schema;\n  }\n\n  stripSchema({ plugin, schema });\n\n  if (\n    schema.additionalProperties &&\n    typeof schema.additionalProperties !== 'boolean'\n  ) {\n    schema.additionalProperties = schemaToJsonSchemaDraft_04({\n      context,\n      plugin,\n      schema: schema.additionalProperties,\n    });\n  }\n\n  if (schema.allOf) {\n    schema.allOf = schema.allOf.map((item) =>\n      schemaToJsonSchemaDraft_04({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.items) {\n    schema.items = schemaToJsonSchemaDraft_04({\n      context,\n      plugin,\n      schema: schema.items as OpenApiV2_0_XTypes['SchemaObject'],\n    });\n  }\n\n  if (schema.properties) {\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        schema.properties[name] = schemaToJsonSchemaDraft_04({\n          context,\n          plugin,\n          schema: property,\n        });\n      }\n    }\n  }\n\n  return schema;\n};\n\nconst schemaToJsonSchemaDraft_05 = ({\n  context,\n  plugin,\n  schema: _schema,\n}: {\n  context: Context;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema:\n    | OpenApiV3_0_XTypes['SchemaObject']\n    | OpenApiV3_0_XTypes['ReferenceObject'];\n}):\n  | OpenApiV3_0_XTypes['SchemaObject']\n  | OpenApiV3_0_XTypes['ReferenceObject'] => {\n  if (Array.isArray(_schema)) {\n    return _schema.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    ) as unknown as\n      | OpenApiV3_0_XTypes['SchemaObject']\n      | OpenApiV3_0_XTypes['ReferenceObject'];\n  }\n\n  const schema = structuredClone(_schema);\n\n  if ('$ref' in schema) {\n    // refs using unicode characters become encoded, didn't investigate why\n    // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n    schema.$ref = decodeURI(schema.$ref);\n    return schema;\n  }\n\n  stripSchema({ plugin, schema });\n\n  if (\n    schema.additionalProperties &&\n    typeof schema.additionalProperties !== 'boolean'\n  ) {\n    schema.additionalProperties = schemaToJsonSchemaDraft_05({\n      context,\n      plugin,\n      schema: schema.additionalProperties,\n    });\n  }\n\n  if (schema.allOf) {\n    schema.allOf = schema.allOf.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.anyOf) {\n    schema.anyOf = schema.anyOf.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.items) {\n    schema.items = schemaToJsonSchemaDraft_05({\n      context,\n      plugin,\n      schema: schema.items,\n    });\n  }\n\n  if (schema.oneOf) {\n    schema.oneOf = schema.oneOf.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.properties) {\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        schema.properties[name] = schemaToJsonSchemaDraft_05({\n          context,\n          plugin,\n          schema: property,\n        });\n      }\n    }\n  }\n\n  return schema;\n};\n\nconst schemaToJsonSchema2020_12 = ({\n  context,\n  plugin,\n  schema: _schema,\n}: {\n  context: Context;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema: OpenApiV3_1_XTypes['SchemaObject'];\n}): OpenApiV3_1_XTypes['SchemaObject'] => {\n  if (Array.isArray(_schema)) {\n    return _schema.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    ) as unknown as OpenApiV3_1_XTypes['SchemaObject'];\n  }\n\n  const schema = structuredClone(_schema);\n\n  stripSchema({ plugin, schema });\n\n  if (schema.$ref) {\n    // refs using unicode characters become encoded, didn't investigate why\n    // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n    schema.$ref = decodeURI(schema.$ref);\n  }\n\n  if (\n    schema.additionalProperties &&\n    typeof schema.additionalProperties !== 'boolean'\n  ) {\n    schema.additionalProperties = schemaToJsonSchema2020_12({\n      context,\n      plugin,\n      schema: schema.additionalProperties,\n    });\n  }\n\n  if (schema.allOf) {\n    schema.allOf = schema.allOf.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.anyOf) {\n    schema.anyOf = schema.anyOf.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.items) {\n    schema.items = schemaToJsonSchema2020_12({\n      context,\n      plugin,\n      schema: schema.items,\n    });\n  }\n\n  if (schema.oneOf) {\n    schema.oneOf = schema.oneOf.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.prefixItems) {\n    schema.prefixItems = schema.prefixItems.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.properties) {\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        schema.properties[name] = schemaToJsonSchema2020_12({\n          context,\n          plugin,\n          schema: property,\n        });\n      }\n    }\n  }\n\n  return schema;\n};\n\nconst schemaName = ({\n  name,\n  plugin,\n  schema,\n}: {\n  name: string;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema:\n    | OpenApiV2_0_XTypes['SchemaObject']\n    | OpenApiV3_0_XTypes['ReferenceObject']\n    | OpenApiV3_0_XTypes['SchemaObject']\n    | OpenApiV3_1_XTypes['SchemaObject'];\n}): string => {\n  let customName = '';\n\n  if (plugin.config.nameBuilder) {\n    if (typeof plugin.config.nameBuilder === 'function') {\n      customName = plugin.config.nameBuilder(name, schema);\n    } else {\n      customName = plugin.config.nameBuilder.replace('{{name}}', name);\n    }\n  }\n\n  if (!customName) {\n    customName = `${name}Schema`;\n  }\n\n  return customName;\n};\n\nconst schemasV2_0_X = ({\n  context,\n  plugin,\n}: {\n  context: Context<OpenApi.V2_0_X>;\n  plugin: HeyApiSchemasPlugin['Instance'];\n}) => {\n  if (!context.spec.definitions) {\n    return;\n  }\n\n  for (const name in context.spec.definitions) {\n    const schema = context.spec.definitions[name]!;\n    const symbol = plugin.symbol(schemaName({ name, plugin, schema }), {\n      meta: {\n        category: 'schema',\n        resource: 'definition',\n        resourceId: name,\n        tool: 'json-schema',\n      },\n    });\n    const obj = schemaToJsonSchemaDraft_04({\n      context,\n      plugin,\n      schema,\n    });\n    const statement = $.const(symbol)\n      .export()\n      .assign(\n        $(\n          $.fromValue(obj, {\n            layout: 'pretty',\n          }),\n        ).as('const'),\n      );\n    plugin.node(statement);\n  }\n};\n\nconst schemasV3_0_X = ({\n  context,\n  plugin,\n}: {\n  context: Context<OpenApi.V3_0_X>;\n  plugin: HeyApiSchemasPlugin['Instance'];\n}) => {\n  if (!context.spec.components) {\n    return;\n  }\n\n  for (const name in context.spec.components.schemas) {\n    const schema = context.spec.components.schemas[name]!;\n    const symbol = plugin.symbol(schemaName({ name, plugin, schema }), {\n      meta: {\n        category: 'schema',\n        resource: 'definition',\n        resourceId: name,\n        tool: 'json-schema',\n      },\n    });\n    const obj = schemaToJsonSchemaDraft_05({\n      context,\n      plugin,\n      schema,\n    });\n    const statement = $.const(symbol)\n      .export()\n      .assign(\n        $(\n          $.fromValue(obj, {\n            layout: 'pretty',\n          }),\n        ).as('const'),\n      );\n    plugin.node(statement);\n  }\n};\n\nconst schemasV3_1_X = ({\n  context,\n  plugin,\n}: {\n  context: Context<OpenApi.V3_1_X>;\n  plugin: HeyApiSchemasPlugin['Instance'];\n}) => {\n  if (!context.spec.components) {\n    return;\n  }\n\n  for (const name in context.spec.components.schemas) {\n    const schema = context.spec.components.schemas[name]!;\n    const symbol = plugin.symbol(schemaName({ name, plugin, schema }), {\n      meta: {\n        category: 'schema',\n        resource: 'definition',\n        resourceId: name,\n        tool: 'json-schema',\n      },\n    });\n    const obj = schemaToJsonSchema2020_12({\n      context,\n      plugin,\n      schema,\n    });\n    const statement = $.const(symbol)\n      .export()\n      .assign(\n        $(\n          $.fromValue(obj, {\n            layout: 'pretty',\n          }),\n        ).as('const'),\n      );\n    plugin.node(statement);\n  }\n};\n\nexport const handler: HeyApiSchemasPlugin['Handler'] = ({ plugin }) => {\n  if ('swagger' in plugin.context.spec) {\n    schemasV2_0_X({\n      context: plugin.context as Context<OpenApi.V2_0_X>,\n      plugin,\n    });\n    return;\n  }\n\n  if (satisfies(plugin.context.spec.openapi, '>=3.0.0 <3.1.0')) {\n    schemasV3_0_X({\n      context: plugin.context as Context<OpenApi.V3_0_X>,\n      plugin,\n    });\n    return;\n  }\n\n  if (satisfies(plugin.context.spec.openapi, '>=3.1.0')) {\n    schemasV3_1_X({\n      context: plugin.context as Context<OpenApi.V3_1_X>,\n      plugin,\n    });\n    return;\n  }\n\n  throw new Error('Unsupported OpenAPI specification');\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { handler } from './plugin';\nimport type { HeyApiSchemasPlugin } from './types';\n\nexport const defaultConfig: HeyApiSchemasPlugin['Config'] = {\n  config: {\n    exportFromIndex: false,\n    nameBuilder: (name) => `${name}Schema`,\n    type: 'json',\n  },\n  handler,\n  name: '@hey-api/schemas',\n};\n\n/**\n * Type helper for `@hey-api/schemas` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { log } from '@hey-api/codegen-core';\n\nimport type { OperationsStrategy } from '~/openApi/shared/locations';\nimport type { PluginContext } from '~/plugins/types';\n\nimport type { UserConfig } from '../types';\nimport type { OperationsConfig, UserOperationsConfig } from './types';\n\ntype Config = Omit<UserConfig, 'name'>;\n\nexport function resolveOperations(\n  config: Config,\n  context: PluginContext,\n): OperationsConfig {\n  if (config.asClass !== undefined) {\n    log.warnDeprecated({\n      context: '@hey-api/sdk',\n      field: 'asClass',\n      replacement: [\n        'operations: { strategy: \"byTags\" }',\n        'operations: { strategy: \"single\" }',\n      ],\n    });\n  }\n\n  if (config.classNameBuilder !== undefined) {\n    log.warnDeprecated({\n      context: '@hey-api/sdk',\n      field: 'classNameBuilder',\n      replacement: 'operations: { containerName: \"...\" }',\n    });\n  }\n\n  if (config.classStructure !== undefined) {\n    log.warnDeprecated({\n      context: '@hey-api/sdk',\n      field: 'classStructure',\n      replacement: [\n        'operations: { nesting: \"operationId\" }',\n        'operations: { nesting: \"id\" }',\n      ],\n    });\n  }\n\n  if (config.instance !== undefined) {\n    log.warnDeprecated({\n      context: '@hey-api/sdk',\n      field: 'instance',\n      replacement: `operations: { strategy: \"single\", containerName: \"${config.instance || 'Name'}\", methods: \"instance\" }`,\n    });\n  }\n\n  if (config.methodNameBuilder !== undefined) {\n    log.warnDeprecated({\n      context: '@hey-api/sdk',\n      field: 'methodNameBuilder',\n      replacement: 'operations: { methodName: \"...\" }',\n    });\n  }\n\n  if (config.operationId !== undefined) {\n    log.warnDeprecated({\n      context: '@hey-api/sdk',\n      field: 'operationId',\n      replacement: [\n        'operations: { nesting: \"operationId\" }',\n        'operations: { nesting: \"id\" }',\n      ],\n    });\n  }\n\n  const legacy = mapLegacyToConfig(config);\n  return normalizeConfig(config.operations, legacy, context);\n}\n\nfunction normalizeConfig(\n  input: OperationsStrategy | UserOperationsConfig | undefined,\n  legacy: Partial<OperationsConfig>,\n  context: PluginContext,\n): OperationsConfig {\n  if (!input || typeof input === 'string' || typeof input === 'function') {\n    input = { strategy: input };\n  }\n\n  const strategy = legacy.strategy ?? input.strategy ?? 'flat';\n  const methods: OperationsConfig['methods'] =\n    strategy === 'single' ? 'instance' : 'static';\n\n  return context.valueToObject({\n    defaultValue: {\n      container: 'class',\n      methods,\n      nesting: 'operationId',\n      nestingDelimiters: /[./]/,\n      strategy,\n      strategyDefaultTag: 'default',\n    },\n    mappers: {\n      object(value) {\n        value.containerName = context.valueToObject({\n          defaultValue:\n            strategy === 'single'\n              ? { casing: 'PascalCase', name: 'Sdk' }\n              : { casing: 'PascalCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.containerName,\n        });\n        value.methodName = context.valueToObject({\n          defaultValue: { casing: 'camelCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.methodName,\n        });\n        value.segmentName = context.valueToObject({\n          defaultValue: { casing: 'PascalCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.segmentName,\n        });\n        return value;\n      },\n    },\n    value: {\n      ...legacy,\n      ...input,\n    } as UserOperationsConfig,\n  }) as OperationsConfig;\n}\n\nfunction mapLegacyToConfig(config: Config): Partial<OperationsConfig> {\n  let strategy: OperationsConfig['strategy'] | undefined;\n  if (config.instance) {\n    strategy = 'single';\n  } else if (config.asClass) {\n    strategy = 'byTags';\n  } else if (config.instance === false || config.asClass === false) {\n    strategy = 'flat';\n  }\n\n  let containerName: OperationsConfig['containerName'] | undefined;\n  let segmentName: OperationsConfig['segmentName'] | undefined;\n  if (config.instance) {\n    let name = typeof config.instance === 'string' ? config.instance : 'Sdk';\n    segmentName = { casing: 'PascalCase' };\n    if (config.classNameBuilder) {\n      segmentName.name = config.classNameBuilder;\n      if (typeof config.classNameBuilder === 'string') {\n        name = config.classNameBuilder.replace('{{name}}', name);\n      } else {\n        name = config.classNameBuilder(name);\n      }\n    }\n    containerName = { casing: 'PascalCase', name };\n  } else if (config.classNameBuilder) {\n    containerName = {\n      casing: 'PascalCase',\n      name: config.classNameBuilder,\n    };\n    segmentName = { ...containerName };\n  } else if (config.asClass) {\n    containerName = { casing: 'PascalCase' };\n    segmentName = { ...containerName };\n  }\n\n  let methods: OperationsConfig['methods'] | undefined;\n  if (config.instance) {\n    methods = 'instance';\n  } else if (config.asClass) {\n    methods = 'static';\n  }\n\n  let nesting: OperationsConfig['nesting'] | undefined;\n  if (config.classStructure === 'off' || config.operationId === false) {\n    nesting = 'id';\n  } else if (config.classStructure === 'auto') {\n    nesting = 'operationId';\n  }\n\n  let methodName: OperationsConfig['methodName'] | undefined;\n  if (config.methodNameBuilder) {\n    methodName = {\n      casing: 'camelCase',\n      name: config.methodNameBuilder,\n    };\n  }\n\n  return {\n    containerName,\n    methodName,\n    methods,\n    nesting,\n    segmentName,\n    strategy,\n  };\n}\n","import type {\n  OperationPathStrategy,\n  OperationStructureStrategy,\n} from '~/openApi/shared/locations';\nimport { OperationPath, OperationStrategy } from '~/openApi/shared/locations';\n\nimport type { HeyApiSdkPlugin } from '../types';\n\nfunction resolvePath(\n  plugin: HeyApiSdkPlugin['Instance'],\n): OperationPathStrategy {\n  if (plugin.config.operations.nesting === 'id') {\n    return OperationPath.id();\n  }\n\n  if (plugin.config.operations.nesting === 'operationId') {\n    return OperationPath.fromOperationId({\n      delimiters: plugin.config.operations.nestingDelimiters,\n      fallback: OperationPath.id(),\n    });\n  }\n\n  return plugin.config.operations.nesting;\n}\n\nexport function resolveStrategy(\n  plugin: HeyApiSdkPlugin['Instance'],\n): OperationStructureStrategy {\n  if (plugin.config.operations.strategy === 'flat') {\n    return OperationStrategy.flat({\n      path: (operation) => [resolvePath(plugin)(operation).join('.')],\n    });\n  }\n\n  if (plugin.config.operations.strategy === 'single') {\n    const root = plugin.config.operations.containerName;\n    return OperationStrategy.single({\n      path: resolvePath(plugin),\n      root: typeof root.name === 'string' ? root.name : (root.name?.('') ?? ''),\n    });\n  }\n\n  if (plugin.config.operations.strategy === 'byTags') {\n    return OperationStrategy.byTags({\n      fallback: plugin.config.operations.strategyDefaultTag,\n      path: resolvePath(plugin),\n    });\n  }\n\n  return plugin.config.operations.strategy;\n}\n","import { clientFolderAbsolutePath } from '~/generate/client';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { $ } from '~/ts-dsl';\n\nimport type { HeyApiSdkPlugin } from '../types';\nimport { isInstance } from '../v1/node';\nimport { nuxtTypeDefault, nuxtTypeResponse } from './constants';\n\nexport const createTypeOptions = ({\n  plugin,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n}) => {\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const symbolTDataShape = plugin.symbol('TDataShape', {\n    external: clientModule,\n    kind: 'type',\n  });\n  const symbolClient = plugin.symbol('Client', {\n    external: clientModule,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: 'client.Client',\n      tool: client.name,\n    },\n  });\n  const symbolClientOptions = plugin.symbol('Options', {\n    external: clientModule,\n    kind: 'type',\n  });\n  const symbolOptions = plugin.symbol('Options', {\n    meta: {\n      category: 'type',\n      resource: 'client-options',\n      tool: 'sdk',\n    },\n  });\n\n  const typeOptions = $.type\n    .alias(symbolOptions)\n    .export()\n    .$if(\n      isNuxtClient,\n      (t) =>\n        t\n          .generic('TComposable', (g) =>\n            g\n              .extends(\n                plugin.referenceSymbol({\n                  category: 'external',\n                  resource: 'client.Composable',\n                }),\n              )\n              .default($.type.literal('$fetch')),\n          )\n          .generic('TData', (g) =>\n            g.extends(symbolTDataShape).default(symbolTDataShape),\n          )\n          .generic(nuxtTypeResponse, (g) => g.default('unknown'))\n          .generic(nuxtTypeDefault, (g) => g.default('undefined')),\n      (t) =>\n        t\n          .generic('TData', (g) =>\n            g.extends(symbolTDataShape).default(symbolTDataShape),\n          )\n          .generic('ThrowOnError', (g) =>\n            g.extends('boolean').default('boolean'),\n          ),\n    )\n    .type(\n      $.type.and(\n        $.type(symbolClientOptions).$if(\n          isNuxtClient,\n          (t) =>\n            t\n              .generic('TComposable')\n              .generic('TData')\n              .generic(nuxtTypeResponse)\n              .generic(nuxtTypeDefault),\n          (t) => t.generic('TData').generic('ThrowOnError'),\n        ),\n        $.type\n          .object()\n          .prop('client', (p) =>\n            p\n              .doc([\n                'You can provide a client instance returned by `createClient()` instead of',\n                'individual options. This might be also useful if you want to implement a',\n                'custom client.',\n              ])\n              .required(!plugin.config.client && !isInstance(plugin))\n              .type(symbolClient),\n          )\n          .prop('meta', (p) =>\n            p\n              .doc([\n                'You can pass arbitrary values through the `meta` object. This can be',\n                \"used to access values that aren't defined as part of the SDK function.\",\n              ])\n              .optional()\n              .type($.type('Record').generics('string', 'unknown')),\n          ),\n      ),\n    );\n  plugin.node(typeOptions);\n};\n","import { StructureModel } from '@hey-api/codegen-core';\n\nimport { clientFolderAbsolutePath } from '~/generate/client';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport type { $ } from '~/ts-dsl';\n\nimport { resolveStrategy } from '../operations';\nimport { createTypeOptions } from '../shared/typeOptions';\nimport type { HeyApiSdkPlugin } from '../types';\nimport type { OperationItem } from './node';\nimport { createShell, source, toNode } from './node';\n\nexport const handlerV1: HeyApiSdkPlugin['Handler'] = ({ plugin }) => {\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const client = getClientPlugin(plugin.context.config);\n  const isAngularClient = client.name === '@hey-api/client-angular';\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  plugin.symbol('formDataBodySerializer', {\n    external: clientModule,\n    meta: {\n      category: 'external',\n      resource: 'client.formDataBodySerializer',\n      tool: client.name,\n    },\n  });\n  plugin.symbol('urlSearchParamsBodySerializer', {\n    external: clientModule,\n    meta: {\n      category: 'external',\n      resource: 'client.urlSearchParamsBodySerializer',\n      tool: client.name,\n    },\n  });\n  plugin.symbol('buildClientParams', {\n    external: clientModule,\n    meta: {\n      category: 'external',\n      resource: 'client.buildClientParams',\n      tool: client.name,\n    },\n  });\n  if (isNuxtClient) {\n    plugin.symbol('Composable', {\n      external: clientModule,\n      kind: 'type',\n      meta: {\n        category: 'external',\n        resource: 'client.Composable',\n        tool: client.name,\n      },\n    });\n  }\n  if (isAngularClient) {\n    plugin.symbol('Injectable', {\n      external: '@angular/core',\n      meta: {\n        category: 'external',\n        resource: '@angular/core.Injectable',\n      },\n    });\n  }\n\n  createTypeOptions({ plugin });\n\n  const structure = new StructureModel();\n  const shell = createShell(plugin);\n  const strategy = resolveStrategy(plugin);\n\n  plugin.forEach(\n    'operation',\n    (event) => {\n      structure.insert({\n        data: {\n          operation: event.operation,\n          path: event._path,\n          tags: event.tags,\n        } satisfies OperationItem,\n        locations: strategy(event.operation).map((path) => ({ path, shell })),\n        source,\n      });\n    },\n    { order: 'declarations' },\n  );\n\n  const allDependencies: Array<ReturnType<typeof $.class | typeof $.var>> = [];\n  const allNodes: Array<ReturnType<typeof $.class | typeof $.var>> = [];\n\n  for (const node of structure.walk()) {\n    const { dependencies, nodes } = toNode(node, plugin);\n    allDependencies.push(...(dependencies ?? []));\n    allNodes.push(...nodes);\n  }\n\n  const uniqueDependencies = new Map<\n    number,\n    ReturnType<typeof $.class | typeof $.var>\n  >();\n  for (const dep of allDependencies) {\n    if (dep.symbol) uniqueDependencies.set(dep.symbol.id, dep);\n  }\n  for (const dep of uniqueDependencies.values()) {\n    plugin.node(dep);\n  }\n\n  for (const node of allNodes) {\n    plugin.node(node);\n  }\n};\n","import type { HeyApiSdkPlugin } from './types';\nimport { handlerV1 } from './v1/plugin';\n\nexport const handler: HeyApiSdkPlugin['Handler'] = (args) => handlerV1(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { resolveOperations } from './operations';\nimport { handler } from './plugin';\nimport type { HeyApiSdkPlugin } from './types';\n\nexport const defaultConfig: HeyApiSdkPlugin['Config'] = {\n  config: {\n    auth: true,\n    client: true,\n    exportFromIndex: true,\n    paramsStructure: 'grouped',\n    responseStyle: 'fields',\n    transformer: false,\n    validator: false,\n\n    // Deprecated - kept for backward compatibility\n    // eslint-disable-next-line sort-keys-fix/sort-keys-fix\n    response: 'body',\n  },\n  dependencies: ['@hey-api/typescript'],\n  handler,\n  name: '@hey-api/sdk',\n  resolveConfig: (plugin, context) => {\n    if (plugin.config.client) {\n      if (typeof plugin.config.client === 'boolean') {\n        plugin.config.client = context.pluginByTag('client', {\n          defaultPlugin: '@hey-api/client-fetch',\n        });\n      }\n\n      plugin.dependencies.add(plugin.config.client!);\n    } else {\n      plugin.config.client = false;\n    }\n\n    if (plugin.config.transformer) {\n      if (typeof plugin.config.transformer === 'boolean') {\n        plugin.config.transformer = context.pluginByTag('transformer');\n      }\n\n      plugin.dependencies.add(plugin.config.transformer!);\n    } else {\n      plugin.config.transformer = false;\n    }\n\n    if (typeof plugin.config.validator !== 'object') {\n      plugin.config.validator = {\n        request: plugin.config.validator,\n        response: plugin.config.validator,\n      };\n    }\n\n    if (plugin.config.validator.request) {\n      if (typeof plugin.config.validator.request === 'boolean') {\n        plugin.config.validator.request = context.pluginByTag('validator');\n      }\n\n      plugin.dependencies.add(plugin.config.validator.request!);\n    } else {\n      plugin.config.validator.request = false;\n    }\n\n    if (plugin.config.validator.response) {\n      if (typeof plugin.config.validator.response === 'boolean') {\n        plugin.config.validator.response = context.pluginByTag('validator');\n      }\n\n      plugin.dependencies.add(plugin.config.validator.response!);\n    } else {\n      plugin.config.validator.response = false;\n    }\n\n    plugin.config.operations = resolveOperations(plugin.config, context);\n  },\n};\n\n/**\n * Type helper for `@hey-api/sdk` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type ts from 'typescript';\n\nimport type { IR } from '~/ir/types';\nimport { $ } from '~/ts-dsl';\n\nimport type { UserConfig } from './types';\n\nexport type ExpressionTransformer = ({\n  config,\n  dataExpression,\n  schema,\n}: {\n  config: Omit<UserConfig, 'name'>;\n  dataExpression?:\n    | ts.Expression\n    | ReturnType<typeof $.expr | typeof $.attr>\n    | string;\n  schema: IR.SchemaObject;\n}) => Array<ReturnType<typeof $.fromValue>> | undefined;\n\nexport const bigIntExpressions: ExpressionTransformer = ({\n  dataExpression,\n  schema,\n}) => {\n  if (schema.type !== 'integer' || schema.format !== 'int64') {\n    return;\n  }\n\n  const bigIntCallExpression =\n    dataExpression !== undefined\n      ? $('BigInt').call($.expr(dataExpression).attr('toString').call())\n      : undefined;\n\n  if (bigIntCallExpression) {\n    if (typeof dataExpression === 'string') {\n      return [bigIntCallExpression];\n    }\n\n    if (dataExpression) {\n      return [$.expr(dataExpression).assign(bigIntCallExpression)];\n    }\n  }\n\n  return;\n};\n\nexport const dateExpressions: ExpressionTransformer = ({\n  dataExpression,\n  schema,\n}) => {\n  if (\n    schema.type !== 'string' ||\n    !(schema.format === 'date' || schema.format === 'date-time')\n  ) {\n    return;\n  }\n\n  if (typeof dataExpression === 'string') {\n    return [$.new('Date').arg(dataExpression)];\n  }\n\n  if (dataExpression) {\n    return [$.expr(dataExpression).assign($.new('Date').arg(dataExpression))];\n  }\n\n  return;\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { createOperationKey, operationResponsesMap } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\nimport { refToName } from '~/utils/ref';\n\nimport type { HeyApiTransformersPlugin } from './types';\n\nconst dataVariableName = 'data';\n\n// Track symbols that are currently being built so recursive references\n// can emit calls to transformers that will be implemented later.\nconst buildingSymbols = new Set<number>();\n\ntype Expr = ReturnType<typeof $.fromValue | typeof $.return | typeof $.if>;\n\nconst isNodeReturnStatement = (node: Expr) => node['~dsl'] === 'ReturnTsDsl';\n\nconst schemaResponseTransformerNodes = ({\n  plugin,\n  schema,\n}: {\n  plugin: HeyApiTransformersPlugin['Instance'];\n  schema: IR.SchemaObject;\n}): Array<ts.Expression | ts.Statement | Expr> => {\n  const nodes = processSchemaType({\n    dataExpression: $(dataVariableName),\n    plugin,\n    schema,\n  });\n  // append return statement if one does not already exist\n  if (nodes.length) {\n    const last = nodes[nodes.length - 1]!;\n    if (!isNodeReturnStatement(last)) {\n      nodes.push($.return(dataVariableName));\n    }\n  }\n  return nodes;\n};\n\nconst processSchemaType = ({\n  dataExpression,\n  plugin,\n  schema,\n}: {\n  dataExpression?:\n    | ts.Expression\n    | string\n    | ReturnType<typeof $.attr | typeof $.expr>;\n  plugin: HeyApiTransformersPlugin['Instance'];\n  schema: IR.SchemaObject;\n}): Array<Expr> => {\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'transform',\n      resource: 'definition',\n      resourceId: schema.$ref,\n    };\n    const symbol =\n      plugin.getSymbol(query) ??\n      plugin.symbol(\n        applyNaming(refToName(schema.$ref), {\n          case: 'camelCase',\n          name: '{{name}}SchemaResponseTransformer',\n        }),\n        {\n          meta: query,\n        },\n      );\n\n    // Only compute the implementation if the symbol isn't already being built.\n    // This prevents infinite recursion on self-referential schemas. We still\n    // allow emitting a call when the symbol is currently being built so\n    // parent nodes can reference the transformer that will be emitted later.\n    if (!symbol.node && !buildingSymbols.has(symbol.id)) {\n      buildingSymbols.add(symbol.id);\n      try {\n        const refSchema = plugin.context.resolveIrRef<IR.SchemaObject>(\n          schema.$ref,\n        );\n        const nodes = schemaResponseTransformerNodes({\n          plugin,\n          schema: refSchema,\n        });\n\n        if (nodes.length) {\n          const node = $.const(symbol).assign(\n            // TODO: parser - add types, generate types without transforms\n            $.func()\n              .param(dataVariableName, (p) => p.type('any'))\n              .do(...nodes),\n          );\n          plugin.node(node);\n        }\n      } finally {\n        buildingSymbols.delete(symbol.id);\n      }\n    }\n\n    // Only emit a call if the symbol has a value (implementation) OR the\n    // symbol is currently being built (recursive reference) ‚Äî in the\n    // latter case we allow emitting a call that will be implemented later.\n    if (symbol.node || buildingSymbols.has(symbol.id)) {\n      const ref = plugin.referenceSymbol(query);\n      const callExpression = $(ref).call(dataExpression);\n\n      if (dataExpression) {\n        // In a map callback, the item needs to be returned, not just the transformation result\n        if (typeof dataExpression === 'string' && dataExpression === 'item') {\n          return [$.return(callExpression)];\n        }\n\n        return [\n          typeof dataExpression === 'string'\n            ? callExpression\n            : $(dataExpression).assign(callExpression),\n        ];\n      }\n    }\n\n    return [];\n  }\n\n  if (schema.type === 'array') {\n    if (!dataExpression || typeof dataExpression === 'string') {\n      return [];\n    }\n\n    // TODO: parser - handle tuples and complex arrays\n    const nodes = !schema.items\n      ? []\n      : processSchemaType({\n          dataExpression: 'item',\n          plugin,\n          schema: schema.items?.[0]\n            ? schema.items[0]\n            : {\n                ...schema,\n                type: undefined,\n              },\n        });\n\n    if (!nodes.length) {\n      return [];\n    }\n\n    // TODO: remove\n    // Ensure the map callback has a return statement for the item\n    const mapCallbackStatements: Array<Expr> = nodes;\n    const hasReturnStatement = mapCallbackStatements.some((stmt) =>\n      isNodeReturnStatement(stmt),\n    );\n\n    if (!hasReturnStatement) {\n      mapCallbackStatements.push($.return('item'));\n    }\n\n    return [\n      $(dataExpression).assign(\n        $(dataExpression)\n          .attr('map')\n          .call(\n            $.func()\n              .param('item', (p) => p.type('any'))\n              .do(...mapCallbackStatements),\n          ),\n      ),\n    ];\n  }\n\n  if (schema.type === 'object') {\n    let nodes: Array<Expr> = [];\n    const required = schema.required ?? [];\n\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n      const propertyAccessExpression = $(\n        dataExpression || dataVariableName,\n      ).attr(name);\n      const propertyNodes = processSchemaType({\n        dataExpression: propertyAccessExpression,\n        plugin,\n        schema: property,\n      });\n      if (!propertyNodes.length) {\n        continue;\n      }\n      const noNullableTypesInSchema = !property.items?.find(\n        (x) => x.type === 'null',\n      );\n      const requiredField = required.includes(name);\n      // Cannot fully rely on required fields\n      // Such value has to be present, but it doesn't guarantee that this value is not nullish\n      if (requiredField && noNullableTypesInSchema) {\n        nodes = nodes.concat(propertyNodes);\n      } else {\n        nodes.push(\n          // todo: Probably, it would make more sense to go with if(x !== undefined && x !== null) instead of if(x)\n          // this place influences all underlying transformers, while it's not exactly transformer itself\n          // Keep in mind that !!0 === false, so it already makes output for Bigint undesirable\n          $.if(propertyAccessExpression).do(...propertyNodes),\n        );\n      }\n    }\n\n    return nodes;\n  }\n\n  if (schema.items) {\n    if (schema.items.length === 1) {\n      return processSchemaType({\n        dataExpression: 'item',\n        plugin,\n        schema: schema.items[0]!,\n      });\n    }\n\n    let arrayNodes: Array<Expr> = [];\n    // process 2 items if one of them is null\n    if (\n      schema.logicalOperator === 'and' ||\n      (schema.items.length === 2 &&\n        schema.items.find(\n          (item) => item.type === 'null' || item.type === 'void',\n        ))\n    ) {\n      for (const item of schema.items) {\n        const nodes = processSchemaType({\n          dataExpression: dataExpression || 'item',\n          plugin,\n          schema: item,\n        });\n        if (nodes.length) {\n          if (dataExpression) {\n            arrayNodes = arrayNodes.concat(nodes);\n          } else {\n            // processed means the item was transformed\n            arrayNodes.push($.if('item').do(...nodes), $.return('item'));\n          }\n        }\n      }\n      return arrayNodes;\n    }\n\n    // assume enums do not contain transformable values\n    if (schema.type !== 'enum') {\n      if (\n        !(schema.items ?? []).every((item) =>\n          (\n            ['boolean', 'integer', 'null', 'number', 'string'] as ReadonlyArray<\n              typeof item.type\n            >\n          ).includes(item.type),\n        )\n      ) {\n        console.warn(\n          `‚ùóÔ∏è Transformers warning: schema ${JSON.stringify(schema)} is too complex and won't be currently processed. This will likely produce an incomplete transformer which is not what you want. Please open an issue if you'd like this improved https://github.com/hey-api/openapi-ts/issues`,\n        );\n      }\n    }\n  }\n\n  for (const transformer of plugin.config.transformers) {\n    const t = transformer({\n      config: plugin.config,\n      dataExpression,\n      schema,\n    });\n    if (t) {\n      return t;\n    }\n  }\n\n  return [];\n};\n\n// handles only response transformers for now\nexport const handler: HeyApiTransformersPlugin['Handler'] = ({ plugin }) => {\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const { response } = operationResponsesMap(operation);\n      if (!response) return;\n\n      if (response.items && response.items.length > 1) {\n        if (plugin.context.config.logs.level === 'debug') {\n          console.warn(\n            `‚ùóÔ∏è Transformers warning: route ${createOperationKey(operation)} has ${response.items.length} non-void success responses. This is currently not handled and we will not generate a response transformer. Please open an issue if you'd like this feature https://github.com/hey-api/openapi-ts/issues`,\n          );\n        }\n        return;\n      }\n\n      const symbolResponse = plugin.querySymbol({\n        category: 'type',\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'response',\n      });\n      if (!symbolResponse) return;\n\n      // TODO: parser - consider handling simple string response which is also a date\n      const nodes = schemaResponseTransformerNodes({\n        plugin,\n        schema: response,\n      });\n      if (!nodes.length) return;\n      const symbol = plugin.symbol(\n        applyNaming(operation.id, {\n          case: 'camelCase',\n          name: '{{name}}ResponseTransformer',\n        }),\n        {\n          meta: {\n            category: 'transform',\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'response',\n          },\n        },\n      );\n      const value = $.const(symbol)\n        .export()\n        .assign(\n          // TODO: parser - add types, generate types without transforms\n          $.func()\n            .async()\n            .param(dataVariableName, (p) => p.type('any'))\n            .returns($.type('Promise').generic(symbolResponse))\n            .do(...nodes),\n        );\n      plugin.node(value);\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { bigIntExpressions, dateExpressions } from './expressions';\nimport { handler } from './plugin';\nimport type { HeyApiTransformersPlugin } from './types';\n\nexport const defaultConfig: HeyApiTransformersPlugin['Config'] = {\n  config: {\n    bigInt: true,\n    dates: true,\n    exportFromIndex: false,\n    transformers: [],\n    typeTransformers: [],\n  },\n  dependencies: ['@hey-api/typescript'],\n  handler,\n  name: '@hey-api/transformers',\n  resolveConfig: (plugin) => {\n    if (!plugin.config.transformers) {\n      plugin.config.transformers = [];\n    }\n\n    if (plugin.config.dates) {\n      plugin.config.transformers = [\n        ...plugin.config.transformers,\n        dateExpressions,\n      ];\n    }\n\n    if (plugin.config.bigInt) {\n      plugin.config.transformers = [\n        ...plugin.config.transformers,\n        bigIntExpressions,\n      ];\n    }\n  },\n  tags: ['transformer'],\n};\n\n/**\n * Type helper for `@hey-api/transformers`, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '~/ir/types';\nimport {\n  getClientBaseUrlKey,\n  getClientPlugin,\n} from '~/plugins/@hey-api/client-core/utils';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\nimport { parseUrl } from '~/utils/url';\n\nimport type { HeyApiTypeScriptPlugin } from '../types';\n\nconst serverToBaseUrlType = ({ server }: { server: IR.ServerObject }) => {\n  const url = parseUrl(server.url);\n\n  if (url.protocol && url.host) {\n    return $.type.literal(server.url);\n  }\n\n  return $.type\n    .template()\n    .add(url.protocol || $.type('string'))\n    .add('://')\n    .add(url.host || $.type('string'))\n    .add(url.port ? `:${url.port}` : '')\n    .add(url.path || '');\n};\n\nexport const createClientOptions = ({\n  nodeIndex,\n  plugin,\n  servers,\n}: {\n  nodeIndex: number;\n  plugin: HeyApiTypeScriptPlugin['Instance'];\n  servers: ReadonlyArray<IR.ServerObject>;\n}) => {\n  const client = getClientPlugin(plugin.context.config);\n\n  const types: Array<TypeTsDsl> = servers.map((server) =>\n    serverToBaseUrlType({ server }),\n  );\n\n  if (!servers.length) {\n    types.push($.type('string'));\n  } else if (\n    !('strictBaseUrl' in client.config && client.config.strictBaseUrl)\n  ) {\n    types.push($.type.and($.type('string'), $.type.object()));\n  }\n\n  const symbol = plugin.symbol(\n    applyNaming('ClientOptions', {\n      case: plugin.config.case,\n    }),\n    {\n      meta: {\n        category: 'type',\n        resource: 'client',\n        role: 'options',\n        tool: 'typescript',\n      },\n    },\n  );\n\n  const node = $.type\n    .alias(symbol)\n    .export()\n    .type(\n      $.type\n        .object()\n        .prop(getClientBaseUrlKey(plugin.context.config), (p) =>\n          p.type($.type.or(...types)),\n        ),\n    );\n  plugin.node(node, nodeIndex);\n};\n","import type { IR } from '~/ir/types';\nimport { escapeComment } from '~/utils/escape';\n\nexport const createSchemaComment = (\n  schema: IR.SchemaObject,\n): ReadonlyArray<string> | undefined => {\n  const comments: Array<string> = [];\n\n  if (schema.title) {\n    comments.push(escapeComment(schema.title));\n  }\n\n  if (schema.description) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line between title and description\n    }\n    comments.push(escapeComment(schema.description));\n  }\n\n  if (schema.deprecated) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line before deprecated\n    }\n    comments.push('@deprecated');\n  }\n\n  return comments.length ? comments : undefined;\n};\n","import { fromRef } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\nimport { $, regexp } from '~/ts-dsl';\nimport { applyNaming, toCase } from '~/utils/naming';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport type { HeyApiTypeScriptPlugin } from '../types';\nimport type { IrSchemaToAstOptions } from './types';\n\nconst schemaToEnumObject = ({\n  plugin,\n  schema,\n}: {\n  plugin: HeyApiTypeScriptPlugin['Instance'];\n  schema: IR.SchemaObject;\n}) => {\n  const typeofItems: Array<\n    | 'bigint'\n    | 'boolean'\n    | 'function'\n    | 'number'\n    | 'object'\n    | 'string'\n    | 'symbol'\n    | 'undefined'\n  > = [];\n\n  const obj = (schema.items ?? []).map((item, index) => {\n    const typeOfItemConst = typeof item.const;\n\n    if (!typeofItems.includes(typeOfItemConst)) {\n      // track types of enum values because some modes support\n      // only enums with string and number types\n      typeofItems.push(typeOfItemConst);\n    }\n\n    let key: string | undefined;\n    if (item.title) {\n      key = item.title;\n    } else if (typeOfItemConst === 'number' || typeOfItemConst === 'string') {\n      key = `${item.const}`;\n    } else if (typeOfItemConst === 'boolean') {\n      key = item.const ? 'true' : 'false';\n    } else if (item.const === null) {\n      key = 'null';\n    } else {\n      key = `${index}`;\n    }\n\n    if (key) {\n      key = toCase(key, plugin.config.enums.case, {\n        stripLeadingSeparators: false,\n      });\n\n      regexp.number.lastIndex = 0;\n      // TypeScript enum keys cannot be numbers\n      if (\n        regexp.number.test(key) &&\n        plugin.config.enums.enabled &&\n        (plugin.config.enums.mode === 'typescript' ||\n          plugin.config.enums.mode === 'typescript-const')\n      ) {\n        key = `_${key}`;\n      }\n    }\n\n    return {\n      key,\n      schema: item,\n    };\n  });\n\n  return {\n    obj,\n    typeofItems,\n  };\n};\n\nexport const exportType = ({\n  plugin,\n  schema,\n  state,\n  type,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n  type: MaybeTsDsl<TypeTsDsl>;\n}) => {\n  const $ref = pathToJsonPointer(fromRef(state.path));\n\n  // root enums have an additional export\n  if (schema.type === 'enum' && plugin.config.enums.enabled) {\n    const enumObject = schemaToEnumObject({ plugin, schema });\n\n    if (plugin.config.enums.mode === 'javascript') {\n      // JavaScript enums might want to ignore null values\n      if (\n        plugin.config.enums.constantsIgnoreNull &&\n        enumObject.typeofItems.includes('object')\n      ) {\n        enumObject.obj = enumObject.obj.filter(\n          (item) => item.schema.const !== null,\n        );\n      }\n\n      const symbolObject = plugin.symbol(\n        applyNaming(refToName($ref), plugin.config.definitions),\n        {\n          meta: {\n            category: 'utility',\n            path: fromRef(state.path),\n            resource: 'definition',\n            resourceId: $ref,\n            tags: fromRef(state.tags),\n            tool: 'typescript',\n          },\n        },\n      );\n      const objectNode = $.const(symbolObject)\n        .export()\n        .$if(createSchemaComment(schema), (c, v) => c.doc(v))\n        .assign(\n          $.object(\n            ...enumObject.obj.map((item) =>\n              $.prop({ kind: 'prop', name: item.key })\n                .$if(createSchemaComment(item.schema), (p, v) => p.doc(v))\n                .value($.fromValue(item.schema.const)),\n            ),\n          ).as('const'),\n        );\n      plugin.node(objectNode);\n\n      const symbol = plugin.symbol(\n        applyNaming(refToName($ref), plugin.config.definitions),\n        {\n          meta: {\n            category: 'type',\n            path: fromRef(state.path),\n            resource: 'definition',\n            resourceId: $ref,\n            tags: fromRef(state.tags),\n            tool: 'typescript',\n          },\n        },\n      );\n      const node = $.type\n        .alias(symbol)\n        .export()\n        .$if(createSchemaComment(schema), (t, v) => t.doc(v))\n        .type(\n          $.type(symbol).idx($.type(symbol).typeofType().keyof()).typeofType(),\n        );\n      plugin.node(node);\n      return;\n    } else if (\n      plugin.config.enums.mode === 'typescript' ||\n      plugin.config.enums.mode === 'typescript-const'\n    ) {\n      // TypeScript enums support only string and number values\n      const shouldCreateTypeScriptEnum = !enumObject.typeofItems.some(\n        (type) => type !== 'number' && type !== 'string',\n      );\n      if (shouldCreateTypeScriptEnum) {\n        const symbol = plugin.symbol(\n          applyNaming(refToName($ref), plugin.config.definitions),\n          {\n            meta: {\n              category: 'type',\n              path: fromRef(state.path),\n              resource: 'definition',\n              resourceId: $ref,\n              tags: fromRef(state.tags),\n              tool: 'typescript',\n            },\n          },\n        );\n        const enumNode = $.enum(symbol)\n          .export()\n          .$if(createSchemaComment(schema), (e, v) => e.doc(v))\n          .const(plugin.config.enums.mode === 'typescript-const')\n          .members(\n            ...enumObject.obj.map((item) =>\n              $.member(item.key)\n                .$if(createSchemaComment(item.schema), (m, v) => m.doc(v))\n                .value($.fromValue(item.schema.const)),\n            ),\n          );\n        plugin.node(enumNode);\n        return;\n      }\n    }\n  }\n\n  const symbol = plugin.symbol(\n    applyNaming(refToName($ref), plugin.config.definitions),\n    {\n      meta: {\n        category: 'type',\n        path: fromRef(state.path),\n        resource: 'definition',\n        resourceId: $ref,\n        tags: fromRef(state.tags),\n        tool: 'typescript',\n      },\n    },\n  );\n  const node = $.type\n    .alias(symbol)\n    .export()\n    .$if(createSchemaComment(schema), (t, v) => t.doc(v))\n    .type(type);\n  plugin.node(node);\n};\n","import { fromRef } from '@hey-api/codegen-core';\n\nimport { operationResponsesMap } from '~/ir/operation';\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\n\nimport { irSchemaToAst } from '../v1/plugin';\nimport type { IrSchemaToAstOptions } from './types';\n\nconst irParametersToIrSchema = ({\n  parameters,\n}: {\n  parameters: Record<string, IR.ParameterObject>;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {\n    type: 'object',\n  };\n\n  if (parameters) {\n    const properties: Record<string, IR.SchemaObject> = {};\n    const required: Array<string> = [];\n\n    for (const key in parameters) {\n      const parameter = parameters[key]!;\n\n      properties[parameter.name] = deduplicateSchema({\n        detectFormat: false,\n        schema: parameter.schema,\n      });\n\n      if (parameter.required) {\n        required.push(parameter.name);\n      }\n    }\n\n    irSchema.properties = properties;\n\n    if (required.length) {\n      irSchema.required = required;\n    }\n  }\n\n  return irSchema;\n};\n\nconst operationToDataType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}) => {\n  const data: IR.SchemaObject = {\n    type: 'object',\n  };\n  const dataRequired: Array<string> = [];\n\n  if (!data.properties) {\n    data.properties = {};\n  }\n\n  if (operation.body) {\n    data.properties.body = operation.body.schema;\n\n    if (operation.body.required) {\n      dataRequired.push('body');\n    }\n  } else {\n    data.properties.body = {\n      type: 'never',\n    };\n  }\n\n  // TODO: parser - handle cookie parameters\n\n  // do not set headers to never so we can always pass arbitrary values\n  if (operation.parameters?.header) {\n    data.properties.headers = irParametersToIrSchema({\n      parameters: operation.parameters.header,\n    });\n\n    if (data.properties.headers.required) {\n      dataRequired.push('headers');\n    }\n  }\n\n  if (operation.parameters?.path) {\n    data.properties.path = irParametersToIrSchema({\n      parameters: operation.parameters.path,\n    });\n\n    if (data.properties.path.required) {\n      dataRequired.push('path');\n    }\n  } else {\n    data.properties.path = {\n      type: 'never',\n    };\n  }\n\n  if (operation.parameters?.query) {\n    data.properties.query = irParametersToIrSchema({\n      parameters: operation.parameters.query,\n    });\n\n    if (data.properties.query.required) {\n      dataRequired.push('query');\n    }\n  } else {\n    data.properties.query = {\n      type: 'never',\n    };\n  }\n\n  data.properties.url = {\n    const: operation.path,\n    type: 'string',\n  };\n  dataRequired.push('url');\n\n  data.required = dataRequired;\n\n  const symbol = plugin.symbol(\n    applyNaming(operation.id, plugin.config.requests),\n    {\n      meta: {\n        category: 'type',\n        path: fromRef(state.path),\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'data',\n        tags: fromRef(state.tags),\n        tool: 'typescript',\n      },\n    },\n  );\n  const node = $.type\n    .alias(symbol)\n    .export()\n    .type(\n      irSchemaToAst({\n        plugin,\n        schema: data,\n        state,\n      }),\n    );\n  plugin.node(node);\n};\n\nexport const operationToType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}) => {\n  operationToDataType({ operation, plugin, state });\n\n  const { error, errors, response, responses } =\n    operationResponsesMap(operation);\n\n  if (errors) {\n    const symbolErrors = plugin.symbol(\n      applyNaming(operation.id, plugin.config.errors),\n      {\n        meta: {\n          category: 'type',\n          path: fromRef(state.path),\n          resource: 'operation',\n          resourceId: operation.id,\n          role: 'errors',\n          tags: fromRef(state.tags),\n          tool: 'typescript',\n        },\n      },\n    );\n    const node = $.type\n      .alias(symbolErrors)\n      .export()\n      .type(\n        irSchemaToAst({\n          plugin,\n          schema: errors,\n          state,\n        }),\n      );\n    plugin.node(node);\n\n    if (error) {\n      const symbol = plugin.symbol(\n        applyNaming(operation.id, {\n          case: plugin.config.errors.case,\n          name: plugin.config.errors.error,\n        }),\n        {\n          meta: {\n            category: 'type',\n            path: fromRef(state.path),\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'error',\n            tags: fromRef(state.tags),\n            tool: 'typescript',\n          },\n        },\n      );\n      const node = $.type\n        .alias(symbol)\n        .export()\n        .type($.type(symbolErrors).idx($.type(symbolErrors).keyof()));\n      plugin.node(node);\n    }\n  }\n\n  if (responses) {\n    const symbolResponses = plugin.symbol(\n      applyNaming(operation.id, plugin.config.responses),\n      {\n        meta: {\n          category: 'type',\n          path: fromRef(state.path),\n          resource: 'operation',\n          resourceId: operation.id,\n          role: 'responses',\n          tags: fromRef(state.tags),\n          tool: 'typescript',\n        },\n      },\n    );\n    const node = $.type\n      .alias(symbolResponses)\n      .export()\n      .type(\n        irSchemaToAst({\n          plugin,\n          schema: responses,\n          state,\n        }),\n      );\n    plugin.node(node);\n\n    if (response) {\n      const symbol = plugin.symbol(\n        applyNaming(operation.id, {\n          case: plugin.config.responses.case,\n          name: plugin.config.responses.response,\n        }),\n        {\n          meta: {\n            category: 'type',\n            path: fromRef(state.path),\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'response',\n            tags: fromRef(state.tags),\n            tool: 'typescript',\n          },\n        },\n      );\n      const node = $.type\n        .alias(symbol)\n        .export()\n        .type($.type(symbolResponses).idx($.type(symbolResponses).keyof()));\n      plugin.node(node);\n    }\n  }\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport { fromRef } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\n\nimport { irSchemaToAst } from '../v1/plugin';\nimport type { IrSchemaToAstOptions } from './types';\n\nconst operationToDataType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}): Symbol => {\n  const data: IR.SchemaObject = {\n    type: 'object',\n  };\n  const dataRequired: Array<string> = [];\n\n  if (!data.properties) {\n    data.properties = {};\n  }\n\n  if (operation.body) {\n    const symbolWebhookPayload = plugin.symbol(\n      applyNaming(operation.id, {\n        case: plugin.config.webhooks.case,\n        name: plugin.config.webhooks.payload,\n      }),\n      {\n        meta: {\n          category: 'type',\n          path: fromRef(state.path),\n          resource: 'webhook',\n          resourceId: operation.id,\n          role: 'data',\n          tags: fromRef(state.tags),\n          tool: 'typescript',\n        },\n      },\n    );\n    const node = $.type\n      .alias(symbolWebhookPayload)\n      .export()\n      .$if(createSchemaComment(operation.body.schema), (t, v) => t.doc(v))\n      .type(\n        irSchemaToAst({\n          plugin,\n          schema: operation.body.schema,\n          state,\n        }),\n      );\n    plugin.node(node);\n\n    data.properties.body = { symbolRef: symbolWebhookPayload };\n    dataRequired.push('body');\n  } else {\n    data.properties.body = { type: 'never' };\n  }\n\n  data.properties.key = {\n    const: operation.path,\n    type: 'string',\n  };\n  dataRequired.push('key');\n\n  data.properties.path = { type: 'never' };\n  data.properties.query = { type: 'never' };\n\n  data.required = dataRequired;\n\n  const symbolWebhookRequest = plugin.symbol(\n    applyNaming(operation.id, plugin.config.webhooks),\n    {\n      meta: {\n        category: 'type',\n        path: fromRef(state.path),\n        resource: 'webhook',\n        resourceId: operation.id,\n        role: 'data',\n        tags: fromRef(state.tags),\n        tool: 'typescript',\n      },\n    },\n  );\n  const node = $.type\n    .alias(symbolWebhookRequest)\n    .export()\n    .type(\n      irSchemaToAst({\n        plugin,\n        schema: data,\n        state,\n      }),\n    );\n  plugin.node(node);\n\n  return symbolWebhookRequest;\n};\n\nexport const webhookToType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}): Symbol => {\n  const symbol = operationToDataType({ operation, plugin, state });\n  return symbol;\n\n  // don't handle webhook responses for now, users only need requestBody\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): TypeTsDsl => {\n  if (!schema.items) {\n    return $.type('Array').generic($.type(plugin.config.topType));\n  }\n\n  schema = deduplicateSchema({ detectFormat: true, schema });\n\n  const itemTypes: Array<MaybeTsDsl<TypeTsDsl>> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const type = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      itemTypes.push(type);\n    });\n  }\n\n  if (itemTypes.length === 1) {\n    return $.type('Array').generic(itemTypes[0]!);\n  }\n\n  return schema.logicalOperator === 'and'\n    ? $.type('Array').generic($.type.and(...itemTypes))\n    : $.type('Array').generic($.type.or(...itemTypes));\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const booleanToAst = ({\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): TypeTsDsl => {\n  if (schema.const !== undefined) {\n    return $.type.literal(schema.const as boolean);\n  }\n\n  return $.type('boolean');\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): MaybeTsDsl<TypeTsDsl> => {\n  const type = irSchemaToAst({\n    plugin,\n    schema: {\n      ...schema,\n      type: undefined,\n    },\n    state,\n  });\n  return type;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'never'>;\n  },\n): TypeTsDsl => {\n  const node = $.type('never');\n  return node;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'null'>;\n  },\n): TypeTsDsl => {\n  const node = $.type.literal(null);\n  return node;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const numberToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): TypeTsDsl => {\n  if (schema.const !== undefined) {\n    return $.type.literal(schema.const as number);\n  }\n\n  if (schema.type === 'integer' && schema.format === 'int64') {\n    // TODO: parser - add ability to skip type transformers\n    if (plugin.getPlugin('@hey-api/transformers')?.config.bigInt) {\n      return $.type('bigint');\n    }\n  }\n\n  return $.type('number');\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport type { SchemaWithType } from '~/plugins';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): TypeTsDsl => {\n  // TODO: parser - handle constants\n  const shape = $.type.object();\n  const required = schema.required ?? [];\n  let indexSchemas: Array<IR.SchemaObject> = [];\n  let hasOptionalProperties = false;\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const propertyType = irSchemaToAst({\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: ref([...fromRef(state.path), 'properties', name]),\n      },\n    });\n    const isRequired = required.includes(name);\n    shape.prop(name, (p) =>\n      p\n        .$if(createSchemaComment(property), (p, v) => p.doc(v))\n        .readonly(property.accessScope === 'read')\n        .required(isRequired)\n        .type(propertyType),\n    );\n    indexSchemas.push(property);\n\n    if (!isRequired) {\n      hasOptionalProperties = true;\n    }\n  }\n\n  // include pattern value schemas into the index union\n  if (schema.patternProperties) {\n    for (const pattern in schema.patternProperties) {\n      const ir = schema.patternProperties[pattern]!;\n      indexSchemas.unshift(ir);\n    }\n  }\n\n  const hasPatterns =\n    !!schema.patternProperties &&\n    Object.keys(schema.patternProperties).length > 0;\n\n  const addPropsRaw = schema.additionalProperties;\n  const addPropsObj =\n    addPropsRaw !== false && addPropsRaw\n      ? (addPropsRaw as IR.SchemaObject)\n      : undefined;\n  const shouldCreateIndex =\n    hasPatterns ||\n    (!!addPropsObj && (addPropsObj.type !== 'never' || !indexSchemas.length));\n\n  if (shouldCreateIndex) {\n    // only inject additionalProperties when it's not \"never\"\n    const addProps = addPropsObj;\n    if (addProps && addProps.type !== 'never') {\n      indexSchemas.unshift(addProps);\n    } else if (\n      !hasPatterns &&\n      !indexSchemas.length &&\n      addProps &&\n      addProps.type === 'never'\n    ) {\n      // keep \"never\" only when there are NO patterns and NO explicit properties\n      indexSchemas = [addProps];\n    }\n\n    if (hasOptionalProperties) {\n      indexSchemas.push({ type: 'undefined' });\n    }\n\n    const type =\n      indexSchemas.length === 1\n        ? irSchemaToAst({\n            plugin,\n            schema: indexSchemas[0]!,\n            state,\n          })\n        : irSchemaToAst({\n            plugin,\n            schema: { items: indexSchemas, logicalOperator: 'or' },\n            state,\n          });\n\n    if (schema.propertyNames?.$ref) {\n      return $.type\n        .mapped('key')\n        .key(\n          irSchemaToAst({\n            plugin,\n            schema: {\n              $ref: schema.propertyNames.$ref,\n            },\n            state,\n          }),\n        )\n        .optional()\n        .type(type);\n    }\n\n    shape.idxSig('key', (i) => i.key('string').type(type));\n  }\n\n  return shape;\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\n\nimport type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { toCase } from '~/utils/naming';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const stringToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): TypeTsDsl => {\n  if (schema.const !== undefined) {\n    return $.type.literal(schema.const as string);\n  }\n\n  if (schema.format) {\n    if (schema.format === 'binary') {\n      return $.type.or($.type('Blob'), $.type('File'));\n    }\n\n    if (schema.format === 'date-time' || schema.format === 'date') {\n      // TODO: parser - add ability to skip type transformers\n      if (plugin.getPlugin('@hey-api/transformers')?.config.dates) {\n        return $.type('Date');\n      }\n    }\n\n    if (schema.format === 'typeid' && typeof schema.example === 'string') {\n      const parts = String(schema.example).split('_');\n      parts.pop(); // remove the ID part\n      const type = parts.join('_');\n\n      const query: SymbolMeta = {\n        category: 'type',\n        resource: 'type-id',\n        resourceId: type,\n        tool: 'typescript',\n      };\n      if (!plugin.getSymbol(query)) {\n        const queryTypeId: SymbolMeta = {\n          category: 'type',\n          resource: 'type-id',\n          tool: 'typescript',\n          variant: 'container',\n        };\n\n        if (!plugin.getSymbol(queryTypeId)) {\n          const symbolTypeId = plugin.symbol('TypeID', {\n            meta: queryTypeId,\n          });\n          const nodeTypeId = $.type\n            .alias(symbolTypeId)\n            .export()\n            .generic('T', (g) => g.extends('string'))\n            .type(\n              $.type.template().add($.type('T')).add('_').add($.type('string')),\n            );\n          plugin.node(nodeTypeId);\n        }\n\n        const symbolTypeId = plugin.referenceSymbol(queryTypeId);\n        const symbolTypeName = plugin.symbol(\n          toCase(`${type}_id`, plugin.config.case),\n          {\n            meta: query,\n          },\n        );\n        const node = $.type\n          .alias(symbolTypeName)\n          .export()\n          .type($.type(symbolTypeId).generic($.type.literal(type)));\n        plugin.node(node);\n      }\n      const symbol = plugin.referenceSymbol(query);\n      return $.type(symbol);\n    }\n  }\n\n  return $.type('string');\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport type { SchemaWithType } from '~/plugins';\nimport type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): MaybeTsDsl<TypeTsDsl> => {\n  let itemTypes: Array<MaybeTsDsl<TypeTsDsl>> = [];\n\n  if (schema.const && Array.isArray(schema.const)) {\n    itemTypes = schema.const.map((value) => $.type.fromValue(value));\n  } else if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const type = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      itemTypes.push(type);\n    });\n  }\n\n  return $.type.tuple(...itemTypes);\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'undefined'>;\n  },\n): TypeTsDsl => {\n  const node = $.type('undefined');\n  return node;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}): TypeTsDsl => {\n  const node = $.type(plugin.config.topType);\n  return node;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'void'>;\n  },\n): TypeTsDsl => {\n  const node = $.type('void');\n  return node;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToAst } from './number';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): MaybeTsDsl<TypeTsDsl> => {\n  const transformersPlugin = args.plugin.getPlugin('@hey-api/transformers');\n  if (transformersPlugin?.config.typeTransformers) {\n    for (const typeTransformer of transformersPlugin.config.typeTransformers) {\n      const typeNode = typeTransformer({ schema });\n      if (typeNode) {\n        return typeNode;\n      }\n    }\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return booleanToAst({\n        ...args,\n        schema: schema as SchemaWithType<'boolean'>,\n      });\n    case 'enum':\n      return enumToAst({\n        ...args,\n        schema: schema as SchemaWithType<'enum'>,\n      });\n    case 'integer':\n    case 'number':\n      return numberToAst({\n        ...args,\n        schema: schema as SchemaWithType<'integer' | 'number'>,\n      });\n    case 'never':\n      return neverToAst({\n        ...args,\n        schema: schema as SchemaWithType<'never'>,\n      });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return stringToAst({\n        ...args,\n        schema: schema as SchemaWithType<'string'>,\n      });\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return undefinedToAst({\n        ...args,\n        schema: schema as SchemaWithType<'undefined'>,\n      });\n    case 'unknown':\n      return unknownToAst({\n        ...args,\n        schema: schema as SchemaWithType<'unknown'>,\n      });\n    case 'void':\n      return voidToAst({\n        ...args,\n        schema: schema as SchemaWithType<'void'>,\n      });\n  }\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport { refs } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport type { SchemaWithType } from '~/plugins';\nimport type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\n\nimport { createClientOptions } from '../shared/clientOptions';\nimport { exportType } from '../shared/export';\nimport { operationToType } from '../shared/operation';\nimport type { IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { webhookToType } from '../shared/webhook';\nimport type { HeyApiTypeScriptPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): MaybeTsDsl<TypeTsDsl> => {\n  if (schema.symbolRef) {\n    const baseType = $.type(schema.symbolRef);\n    if (schema.omit && schema.omit.length > 0) {\n      // Render as Omit<Type, 'prop1' | 'prop2'>\n      const omittedKeys =\n        schema.omit.length === 1\n          ? $.type.literal(schema.omit[0]!)\n          : $.type.or(...schema.omit.map((key) => $.type.literal(key)));\n      return $.type('Omit').generics(baseType, omittedKeys);\n    }\n    return baseType;\n  }\n\n  if (schema.$ref) {\n    const symbol = plugin.referenceSymbol({\n      category: 'type',\n      resource: 'definition',\n      resourceId: schema.$ref,\n    });\n    const baseType = $.type(symbol);\n    if (schema.omit && schema.omit.length > 0) {\n      // Render as Omit<Type, 'prop1' | 'prop2'>\n      const omittedKeys =\n        schema.omit.length === 1\n          ? $.type.literal(schema.omit[0]!)\n          : $.type.or(...schema.omit.map((key) => $.type.literal(key)));\n      return $.type('Omit').generics(baseType, omittedKeys);\n    }\n    return baseType;\n  }\n\n  if (schema.type) {\n    return irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n  }\n\n  if (schema.items) {\n    schema = deduplicateSchema({ detectFormat: false, schema });\n    if (schema.items) {\n      const itemTypes = schema.items.map((item) =>\n        irSchemaToAst({ plugin, schema: item, state }),\n      );\n      return schema.logicalOperator === 'and'\n        ? $.type.and(...itemTypes)\n        : $.type.or(...itemTypes);\n    }\n\n    return irSchemaToAst({ plugin, schema, state });\n  }\n\n  // catch-all fallback for failed schemas\n  return irSchemaWithTypeToAst({\n    plugin,\n    schema: {\n      type: 'unknown',\n    },\n    state,\n  });\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}) => {\n  const type = irSchemaToAst({ plugin, schema, state });\n  exportType({\n    plugin,\n    schema,\n    state,\n    type,\n  });\n};\n\nexport const handlerV1: HeyApiTypeScriptPlugin['Handler'] = ({ plugin }) => {\n  // reserve node for ClientOptions\n  const nodeClientIndex = plugin.node(null);\n  // reserve node for Webhooks\n  const nodeWebhooksIndex = plugin.node(null);\n\n  const servers: Array<IR.ServerObject> = [];\n  const webhooks: Array<Symbol> = [];\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'server',\n    'webhook',\n    (event) => {\n      const state = refs<PluginState>({\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          operationToType({\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'server':\n          servers.push(event.server);\n          break;\n        case 'webhook':\n          webhooks.push(\n            webhookToType({\n              operation: event.operation,\n              plugin,\n              state,\n            }),\n          );\n          break;\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  createClientOptions({ nodeIndex: nodeClientIndex, plugin, servers });\n\n  if (webhooks.length > 0) {\n    const symbol = plugin.symbol(\n      applyNaming('Webhooks', {\n        case: plugin.config.case,\n      }),\n      {\n        meta: {\n          category: 'type',\n          resource: 'webhook',\n          tool: 'typescript',\n          variant: 'container',\n        },\n      },\n    );\n    const node = $.type\n      .alias(symbol)\n      .export()\n      .type($.type.or(...webhooks));\n    plugin.node(node, nodeWebhooksIndex);\n  }\n};\n","import type { MaybeTsDsl, TypeTsDsl } from '~/ts-dsl';\n\nimport { irSchemaToAstV1 } from './v1/api';\n\nexport type IApi = {\n  schemaToType: (\n    args: Parameters<typeof irSchemaToAstV1>[0],\n  ) => MaybeTsDsl<TypeTsDsl>;\n};\n\nexport class Api implements IApi {\n  schemaToType(\n    args: Parameters<typeof irSchemaToAstV1>[0],\n  ): MaybeTsDsl<TypeTsDsl> {\n    return irSchemaToAstV1(args);\n  }\n}\n","import type { HeyApiTypeScriptPlugin } from './types';\nimport { handlerV1 } from './v1/plugin';\n\nexport const handler: HeyApiTypeScriptPlugin['Handler'] = (args) =>\n  handlerV1(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { HeyApiTypeScriptPlugin } from './types';\n\nexport const defaultConfig: HeyApiTypeScriptPlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'PascalCase',\n    exportFromIndex: true,\n    topType: 'unknown',\n  },\n  handler,\n  name: '@hey-api/typescript',\n  resolveConfig: (plugin, context) => {\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.enums = context.valueToObject({\n      defaultValue: {\n        case: 'SCREAMING_SNAKE_CASE',\n        constantsIgnoreNull: false,\n        enabled: Boolean(plugin.config.enums),\n        mode: 'javascript',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        string: (mode) => ({ mode }),\n      },\n      value: plugin.config.enums,\n    });\n\n    plugin.config.errors = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        error: '{{name}}Error',\n        name: '{{name}}Errors',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.errors,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}Data',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}Responses',\n        response: '{{name}}Response',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}WebhookRequest',\n        payload: '{{name}}WebhookPayload',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n};\n\n/**\n * Type helper for `@hey-api/typescript` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '~/ir/types';\nimport { $ } from '~/ts-dsl';\n\nimport type { PiniaColadaPlugin } from './types';\n\nexport const handleMeta = (\n  plugin: PiniaColadaPlugin['Instance'],\n  operation: IR.OperationObject,\n  configPath: 'queryOptions' | 'mutationOptions',\n): ReturnType<typeof $.fromValue> | undefined => {\n  const metaFn = plugin.config[configPath].meta;\n  if (!metaFn) return;\n\n  const metaObject = metaFn(operation);\n  if (!Object.keys(metaObject).length) return;\n\n  return $.fromValue(metaObject);\n};\n","import type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { operationOptionsType } from '~/plugins/@hey-api/sdk/shared/operation';\nimport { $ } from '~/ts-dsl';\n\nimport type { PiniaColadaPlugin } from './types';\n\nexport const useTypeData = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): ReturnType<typeof $.type> => {\n  const pluginSdk = plugin.getPluginOrThrow('@hey-api/sdk');\n  return operationOptionsType({ operation, plugin: pluginSdk });\n};\n\nexport const useTypeError = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): ReturnType<typeof $.type> => {\n  const client = getClientPlugin(plugin.context.config);\n  const symbolErrorType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'error',\n  });\n  const symbolError = symbolErrorType || 'Error';\n  if (client.name === '@hey-api/client-axios') {\n    const symbol = plugin.referenceSymbol({\n      category: 'external',\n      resource: 'axios.AxiosError',\n    });\n    return $.type(symbol).generic(symbolError);\n  }\n  return $.type(symbolError);\n};\n\nexport const useTypeResponse = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): ReturnType<typeof $.type> => {\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'response',\n  });\n  return $.type(symbolResponseType ?? 'unknown');\n};\n","import type { IR } from '~/ir/types';\nimport { $ } from '~/ts-dsl';\n\nimport type { PiniaColadaPlugin } from './types';\nimport { useTypeData } from './useType';\n\nexport const getPublicTypeData = ({\n  isNuxtClient,\n  operation,\n  plugin,\n}: {\n  isNuxtClient: boolean;\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}) => {\n  const typeData = useTypeData({ operation, plugin });\n  return isNuxtClient\n    ? $.type('Omit').generic(typeData).generic('composable')\n    : typeData;\n};\n","import type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { createOperationComment } from '~/plugins/shared/utils/operation';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\n\nimport { handleMeta } from './meta';\nimport type { PiniaColadaPlugin } from './types';\nimport { useTypeError, useTypeResponse } from './useType';\nimport { getPublicTypeData } from './utils';\n\nexport const createMutationOptions = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): void => {\n  const symbolMutationOptionsType = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.UseMutationOptions`,\n  });\n\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const typeData = getPublicTypeData({ isNuxtClient, operation, plugin });\n\n  const options = plugin.symbol('options');\n  const fnOptions = plugin.symbol('vars');\n\n  const awaitSdkFn = $.lazy((ctx) =>\n    ctx\n      .access(\n        plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }),\n      )\n      .call(\n        $.object()\n          .pretty()\n          .spread(options)\n          .spread(fnOptions)\n          .prop('throwOnError', $.literal(true)),\n      )\n      .await(),\n  );\n\n  const statements: Array<ReturnType<typeof $.var | typeof $.return>> = [];\n\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push(\n      $.const().object('data').assign(awaitSdkFn),\n      $.return('data'),\n    );\n  }\n\n  const mutationOpts = $.object()\n    .pretty()\n    .prop(\n      'mutation',\n      $.func()\n        .async()\n        .param(fnOptions, (p) =>\n          p.$if(isNuxtClient, (f) =>\n            f.type($.type('Partial').generic(typeData)),\n          ),\n        )\n        .do(...statements),\n    )\n    .$if(handleMeta(plugin, operation, 'mutationOptions'), (o, v) =>\n      o.prop('meta', v),\n    );\n  const symbolMutationOptions = plugin.symbol(\n    applyNaming(operation.id, plugin.config.mutationOptions),\n  );\n  const statement = $.const(symbolMutationOptions)\n    .export()\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $.func()\n        .param(options, (p) =>\n          p.optional().type($.type('Partial').generic(typeData)),\n        )\n        .returns(\n          $.type(symbolMutationOptionsType)\n            .generic(useTypeResponse({ operation, plugin }))\n            .generic(typeData)\n            .generic(useTypeError({ operation, plugin })),\n        )\n        .do($.return(mutationOpts)),\n    );\n  plugin.node(statement);\n};\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport { clientFolderAbsolutePath } from '~/generate/client';\nimport { hasOperationDataRequired } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport {\n  getClientBaseUrlKey,\n  getClientPlugin,\n} from '~/plugins/@hey-api/client-core/utils';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\n\nimport type { PiniaColadaPlugin } from './types';\nimport { getPublicTypeData } from './utils';\n\nconst TOptionsType = 'TOptions';\n\nexport const createQueryKeyFunction = ({\n  plugin,\n}: {\n  plugin: PiniaColadaPlugin['Instance'];\n}) => {\n  const symbolCreateQueryKey = plugin.symbol(\n    applyNaming('createQueryKey', {\n      case: plugin.config.case,\n    }),\n    {\n      meta: {\n        category: 'utility',\n        resource: 'createQueryKey',\n        tool: plugin.name,\n      },\n    },\n  );\n  const symbolQueryKeyType = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'QueryKey',\n    tool: plugin.name,\n  });\n  const symbolJsonValue = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}._JSONValue`,\n  });\n\n  const returnType = $.type(symbolQueryKeyType).generic(TOptionsType).idx(0);\n\n  const baseUrlKey = getClientBaseUrlKey(plugin.context.config);\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolClient = plugin.getSymbol({\n    category: 'client',\n  });\n\n  const clientModule = clientFolderAbsolutePath(plugin.context.config);\n  const symbolSerializeQueryValue = plugin.symbol('serializeQueryKeyValue', {\n    external: clientModule,\n    meta: {\n      category: 'external',\n      resource: `${clientModule}.serializeQueryKeyValue`,\n    },\n  });\n\n  const fn = $.const(symbolCreateQueryKey).assign(\n    $.func()\n      .param('id', (p) => p.type('string'))\n      .param('options', (p) => p.optional().type(TOptionsType))\n      .param('tags', (p) => p.optional().type('ReadonlyArray<string>'))\n      .returns($.type.tuple(returnType))\n      .generic(TOptionsType, (g) => g.extends(symbolOptions))\n      .do(\n        $.const('params')\n          .type(returnType)\n          .assign(\n            $.object()\n              .prop('_id', 'id')\n              .prop(\n                baseUrlKey,\n                $('options')\n                  .attr(baseUrlKey)\n                  .optional()\n                  .or(\n                    $('options')\n                      .attr('client')\n                      .optional()\n                      .$if(symbolClient, (a, v) => a.coalesce(v))\n                      .attr('getConfig')\n                      .call()\n                      .attr(baseUrlKey),\n                  ),\n              )\n              .as(returnType),\n          ),\n        $.if('tags').do(\n          $('params')\n            .attr('tags')\n            .assign($('tags').as('unknown').as(symbolJsonValue)),\n        ),\n        $.if($('options').attr('body').optional().neq($.id('undefined'))).do(\n          $.const('normalizedBody').assign(\n            $(symbolSerializeQueryValue).call($('options').attr('body')),\n          ),\n          $.if($('normalizedBody').neq($.id('undefined'))).do(\n            $('params').attr('body').assign('normalizedBody'),\n          ),\n        ),\n        $.if($('options').attr('path').optional()).do(\n          $('params').attr('path').assign($('options').attr('path')),\n        ),\n        $.if($('options').attr('query').optional().neq($.id('undefined'))).do(\n          $.const('normalizedQuery').assign(\n            $(symbolSerializeQueryValue).call($('options').attr('query')),\n          ),\n          $.if($('normalizedQuery').neq($.id('undefined'))).do(\n            $('params').attr('query').assign('normalizedQuery'),\n          ),\n        ),\n        $.return($.array($('params'))),\n      ),\n  );\n  plugin.node(fn);\n};\n\nconst createQueryKeyLiteral = ({\n  id,\n  operation,\n  plugin,\n}: {\n  id: string;\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}) => {\n  const config = plugin.config.queryKeys;\n  let tagsExpression: ReturnType<typeof $.array> | undefined;\n  if (config.tags && operation.tags && operation.tags.length > 0) {\n    tagsExpression = $.array(...operation.tags.map((tag) => $.literal(tag)));\n  }\n\n  const symbolCreateQueryKey = plugin.referenceSymbol({\n    category: 'utility',\n    resource: 'createQueryKey',\n    tool: plugin.name,\n  });\n  const createQueryKeyCallExpression = $(symbolCreateQueryKey).call(\n    $.literal(id),\n    'options',\n    tagsExpression,\n  );\n  return createQueryKeyCallExpression;\n};\n\nexport const createQueryKeyType = ({\n  plugin,\n}: {\n  plugin: PiniaColadaPlugin['Instance'];\n}) => {\n  const symbolJsonValue = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}._JSONValue`,\n  });\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolQueryKeyType = plugin.symbol('QueryKey', {\n    meta: {\n      category: 'type',\n      resource: 'QueryKey',\n      tool: plugin.name,\n    },\n  });\n  const queryKeyType = $.type\n    .alias(symbolQueryKeyType)\n    .export()\n    .generic(TOptionsType, (g) => g.extends($.type(symbolOptions)))\n    .type(\n      $.type.tuple(\n        $.type.and(\n          $.type(`Pick<${TOptionsType}, 'path'>`),\n          $.type\n            .object()\n            .prop('_id', (p) => p.type('string'))\n            .prop(getClientBaseUrlKey(plugin.context.config), (p) =>\n              p.optional().type(symbolJsonValue),\n            )\n            .prop('body', (p) => p.optional().type(symbolJsonValue))\n            .prop('query', (p) => p.optional().type(symbolJsonValue))\n            .prop('tags', (p) => p.optional().type(symbolJsonValue)),\n        ),\n      ),\n    );\n  plugin.node(queryKeyType);\n};\n\nexport const queryKeyStatement = ({\n  operation,\n  plugin,\n  symbol,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n  symbol: Symbol;\n}) => {\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const statement = $.const(symbol)\n    .export()\n    .assign(\n      $.func()\n        .param('options', (p) =>\n          p\n            .required(hasOperationDataRequired(operation))\n            .type(getPublicTypeData({ isNuxtClient, operation, plugin })),\n        )\n        .do(\n          createQueryKeyLiteral({\n            id: operation.id,\n            operation,\n            plugin,\n          }).return(),\n        ),\n    );\n  return statement;\n};\n","import type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport {\n  createOperationComment,\n  hasOperationSse,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\n\nimport { handleMeta } from './meta';\nimport {\n  createQueryKeyFunction,\n  createQueryKeyType,\n  queryKeyStatement,\n} from './queryKey';\nimport type { PiniaColadaPlugin } from './types';\nimport { getPublicTypeData } from './utils';\n\nconst optionsParamName = 'options';\nconst fnOptions = 'context';\n\nexport const createQueryOptions = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n  if (\n    !plugin.getSymbol({\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    })\n  ) {\n    createQueryKeyType({ plugin });\n    createQueryKeyFunction({ plugin });\n  }\n\n  let keyExpression: ReturnType<typeof $.call>;\n  if (plugin.config.queryKeys.enabled) {\n    const symbolQueryKey = plugin.symbol(\n      applyNaming(operation.id, plugin.config.queryKeys),\n    );\n    const node = queryKeyStatement({\n      operation,\n      plugin,\n      symbol: symbolQueryKey,\n    });\n    plugin.node(node);\n    keyExpression = $(symbolQueryKey).call(optionsParamName);\n  } else {\n    const symbolCreateQueryKey = plugin.referenceSymbol({\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    });\n    // Optionally include tags when configured\n    let tagsExpr: ReturnType<typeof $.array> | undefined;\n    if (\n      plugin.config.queryKeys.tags &&\n      operation.tags &&\n      operation.tags.length > 0\n    ) {\n      tagsExpr = $.array(...operation.tags.map((t) => $.literal(t)));\n    }\n    keyExpression = $(symbolCreateQueryKey).call(\n      $.literal(operation.id),\n      optionsParamName,\n      tagsExpr,\n    );\n  }\n\n  const client = getClientPlugin(plugin.context.config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const typeData = getPublicTypeData({ isNuxtClient, operation, plugin });\n  const awaitSdkFn = $.lazy((ctx) =>\n    ctx\n      .access(\n        plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }),\n      )\n      .call(\n        $.object()\n          .spread(optionsParamName)\n          .spread(fnOptions)\n          .prop('throwOnError', $.literal(true)),\n      )\n      .await(),\n  );\n\n  const statements: Array<ReturnType<typeof $.return | typeof $.const>> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push(\n      $.const().object('data').assign(awaitSdkFn),\n      $.return('data'),\n    );\n  }\n\n  const queryOpts = $.object()\n    .pretty()\n    .prop('key', keyExpression)\n    .prop(\n      'query',\n      $.func()\n        .async()\n        .param(fnOptions)\n        .do(...statements),\n    )\n    .$if(handleMeta(plugin, operation, 'queryOptions'), (o, v) =>\n      o.prop('meta', v),\n    );\n\n  const symbolQueryOptionsFn = plugin.symbol(\n    applyNaming(operation.id, plugin.config.queryOptions),\n    {\n      meta: {\n        category: 'hook',\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'queryOptions',\n        tool: plugin.name,\n      },\n    },\n  );\n  const symbolDefineQueryOptions = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.defineQueryOptions`,\n  });\n  const statement = $.const(symbolQueryOptionsFn)\n    .export()\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $(symbolDefineQueryOptions).call(\n        $.func()\n          .param(optionsParamName, (p) =>\n            p.required(isRequiredOptions).type(typeData),\n          )\n          .do($.return(queryOpts)),\n      ),\n    );\n  plugin.node(statement);\n};\n","import { createMutationOptions } from '../mutationOptions';\nimport { createQueryOptions } from '../queryOptions';\nimport type { PiniaColadaPlugin } from '../types';\n\nexport const handlerV0: PiniaColadaPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('defineQueryOptions', {\n    external: plugin.name,\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.defineQueryOptions`,\n    },\n  });\n  plugin.symbol('UseMutationOptions', {\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.UseMutationOptions`,\n    },\n  });\n  plugin.symbol('UseQueryOptions', {\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.UseQueryOptions`,\n    },\n  });\n  plugin.symbol('_JSONValue', {\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}._JSONValue`,\n    },\n  });\n  plugin.symbol('AxiosError', {\n    external: 'axios',\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: 'axios.AxiosError',\n    },\n  });\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      if (plugin.hooks.operation.isQuery(operation)) {\n        if (plugin.config.queryOptions.enabled) {\n          createQueryOptions({ operation, plugin });\n        }\n      }\n\n      if (plugin.hooks.operation.isMutation(operation)) {\n        if (plugin.config.mutationOptions.enabled) {\n          createMutationOptions({ operation, plugin });\n        }\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import type { PiniaColadaPlugin } from './types';\nimport { handlerV0 } from './v0/plugin';\n\nexport const handler: PiniaColadaPlugin['Handler'] = (args) => handlerV0(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { handler } from './plugin';\nimport type { PiniaColadaPlugin } from './types';\n\nexport const defaultConfig: PiniaColadaPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/typescript', '@hey-api/sdk'],\n  handler: handler as PiniaColadaPlugin['Handler'],\n  name: '@pinia/colada',\n  resolveConfig: (plugin, context) => {\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Query',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@pinia/colada` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '~/ir/types';\nimport { getClientPlugin } from '~/plugins/@hey-api/client-core/utils';\nimport { operationOptionsType } from '~/plugins/@hey-api/sdk/shared/operation';\nimport { $ } from '~/ts-dsl';\n\nimport type { PluginInstance } from '../types';\n\nexport const useTypeData = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): ReturnType<typeof $.type> => {\n  const pluginSdk = plugin.getPluginOrThrow('@hey-api/sdk');\n  return operationOptionsType({ operation, plugin: pluginSdk });\n};\n\nexport const useTypeError = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): ReturnType<typeof $.type> => {\n  const client = getClientPlugin(plugin.context.config);\n  const symbolErrorType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'error',\n  });\n  const symbolError =\n    symbolErrorType ||\n    plugin.referenceSymbol({\n      category: 'external',\n      resource: `${plugin.name}.DefaultError`,\n    });\n  if (client.name === '@hey-api/client-axios') {\n    const symbol = plugin.referenceSymbol({\n      category: 'external',\n      resource: 'axios.AxiosError',\n    });\n    return $.type(symbol).generic(symbolError);\n  }\n  return $.type(symbolError);\n};\n\nexport const useTypeResponse = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): ReturnType<typeof $.type> => {\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'response',\n  });\n  return $.type(symbolResponseType ?? 'unknown');\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { hasOperationDataRequired } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { getClientBaseUrlKey } from '~/plugins/@hey-api/client-core/utils';\nimport type { TsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\n\nimport { useTypeData } from './shared/useType';\nimport type { PluginInstance } from './types';\n\nconst TOptionsType = 'TOptions';\n\nexport const createQueryKeyFunction = ({\n  plugin,\n}: {\n  plugin: PluginInstance;\n}) => {\n  const symbolCreateQueryKey = plugin.symbol(\n    applyNaming('createQueryKey', {\n      case: plugin.config.case,\n    }),\n    {\n      meta: {\n        category: 'utility',\n        resource: 'createQueryKey',\n        tool: plugin.name,\n      },\n    },\n  );\n  const symbolQueryKeyType = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'QueryKey',\n    tool: plugin.name,\n  });\n\n  const baseUrlKey = getClientBaseUrlKey(plugin.context.config);\n\n  const symbolClient = plugin.getSymbol({\n    category: 'client',\n  });\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n\n  const returnType = $.type(symbolQueryKeyType).generic(TOptionsType).idx(0);\n\n  const fn = $.const(symbolCreateQueryKey).assign(\n    $.func()\n      .param('id', (p) => p.type('string'))\n      .param('options', (p) => p.optional().type(TOptionsType))\n      .param('infinite', (p) => p.optional().type('boolean'))\n      .param('tags', (p) => p.optional().type('ReadonlyArray<string>'))\n      .generic(TOptionsType, (g) => g.extends(symbolOptions))\n      .returns($.type.tuple(returnType))\n      .do(\n        $.const('params')\n          .type(returnType)\n          .assign(\n            $.object()\n              .prop('_id', 'id')\n              .prop(\n                baseUrlKey,\n                $('options')\n                  .attr(baseUrlKey)\n                  .optional()\n                  .or(\n                    $('options')\n                      .attr('client')\n                      .optional()\n                      .$if(symbolClient, (a, v) => a.coalesce(v))\n                      .attr('getConfig')\n                      .call()\n                      .attr(baseUrlKey),\n                  ),\n              )\n              .as(returnType),\n          ),\n        $.if('infinite').do($('params').attr('_infinite').assign('infinite')),\n        $.if('tags').do($('params').attr('tags').assign('tags')),\n        $.if($('options').attr('body').optional()).do(\n          $('params').attr('body').assign($('options').attr('body')),\n        ),\n        $.if($('options').attr('headers').optional()).do(\n          $('params').attr('headers').assign($('options').attr('headers')),\n        ),\n        $.if($('options').attr('path').optional()).do(\n          $('params').attr('path').assign($('options').attr('path')),\n        ),\n        $.if($('options').attr('query').optional()).do(\n          $('params').attr('query').assign($('options').attr('query')),\n        ),\n        $.return($.array().element($('params'))),\n      ),\n  );\n  plugin.node(fn);\n};\n\nconst createQueryKeyLiteral = ({\n  id,\n  isInfinite,\n  operation,\n  plugin,\n}: {\n  id: string;\n  isInfinite?: boolean;\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}) => {\n  const config = isInfinite\n    ? plugin.config.infiniteQueryKeys\n    : plugin.config.queryKeys;\n  let tagsArray: TsDsl<ts.ArrayLiteralExpression> | undefined;\n  if (config.tags && operation.tags && operation.tags.length > 0) {\n    tagsArray = $.array().elements(...operation.tags);\n  }\n  const symbolCreateQueryKey = plugin.referenceSymbol({\n    category: 'utility',\n    resource: 'createQueryKey',\n    tool: plugin.name,\n  });\n  const createQueryKeyCallExpression = $(symbolCreateQueryKey).call(\n    $.literal(id),\n    'options',\n    isInfinite || tagsArray ? $.literal(Boolean(isInfinite)) : undefined,\n    tagsArray,\n  );\n  return createQueryKeyCallExpression;\n};\n\nexport const createQueryKeyType = ({ plugin }: { plugin: PluginInstance }) => {\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolQueryKeyType = plugin.symbol('QueryKey', {\n    meta: {\n      category: 'type',\n      resource: 'QueryKey',\n      tool: plugin.name,\n    },\n  });\n  const queryKeyType = $.type\n    .alias(symbolQueryKeyType)\n    .export()\n    .generic(TOptionsType, (g) => g.extends(symbolOptions))\n    .type(\n      $.type.tuple(\n        $.type.and(\n          $.type(\n            `Pick<${TOptionsType}, '${getClientBaseUrlKey(plugin.context.config)}' | 'body' | 'headers' | 'path' | 'query'>`,\n          ),\n          $.type\n            .object()\n            .prop('_id', (p) => p.type('string'))\n            .prop('_infinite', (p) => p.optional().type('boolean'))\n            .prop('tags', (p) => p.optional().type('ReadonlyArray<string>')),\n        ),\n      ),\n    );\n  plugin.node(queryKeyType);\n};\n\nexport const queryKeyStatement = ({\n  isInfinite,\n  operation,\n  plugin,\n  symbol,\n  typeQueryKey,\n}: {\n  isInfinite: boolean;\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n  symbol: Symbol;\n  typeQueryKey?: ReturnType<typeof $.type>;\n}) => {\n  const typeData = useTypeData({ operation, plugin });\n  const statement = $.const(symbol)\n    .export()\n    .assign(\n      $.func()\n        .param('options', (p) =>\n          p.required(hasOperationDataRequired(operation)).type(typeData),\n        )\n        .$if(isInfinite && typeQueryKey, (f, v) => f.returns(v))\n        .do(\n          createQueryKeyLiteral({\n            id: operation.id,\n            isInfinite,\n            operation,\n            plugin,\n          }).return(),\n        ),\n    );\n  return statement;\n};\n","import type { IR } from '~/ir/types';\nimport { $ } from '~/ts-dsl';\n\nimport type { PluginInstance } from '../types';\n\nexport const handleMeta = (\n  plugin: PluginInstance,\n  operation: IR.OperationObject,\n  configPath: 'queryOptions' | 'infiniteQueryOptions' | 'mutationOptions',\n): ReturnType<typeof $.fromValue> | undefined => {\n  const metaFn = plugin.config[configPath].meta;\n  if (!metaFn) return;\n\n  const metaObject = metaFn(operation);\n  if (!Object.keys(metaObject).length) return;\n\n  return $.fromValue(metaObject);\n};\n","import { ref } from '@hey-api/codegen-core';\n\nimport { operationPagination } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport type { TsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\n\nimport {\n  createQueryKeyFunction,\n  createQueryKeyType,\n  queryKeyStatement,\n} from '../queryKey';\nimport { handleMeta } from '../shared/meta';\nimport { useTypeData, useTypeError, useTypeResponse } from '../shared/useType';\nimport type { PluginInstance } from '../types';\n\nconst createInfiniteParamsFunction = ({\n  plugin,\n}: {\n  plugin: PluginInstance;\n}) => {\n  const symbolCreateInfiniteParams = plugin.symbol(\n    applyNaming('createInfiniteParams', {\n      case: plugin.config.case,\n    }),\n    {\n      meta: {\n        category: 'utility',\n        resource: 'createInfiniteParams',\n        tool: plugin.name,\n      },\n    },\n  );\n\n  const fn = $.const(symbolCreateInfiniteParams).assign(\n    $.func()\n      .generic('K', (g) =>\n        g.extends(\n          $.type('Pick').generics(\n            $.type('QueryKey').generic('Options').idx(0),\n            $.type.or(\n              $.type.literal('body'),\n              $.type.literal('headers'),\n              $.type.literal('path'),\n              $.type.literal('query'),\n            ),\n          ),\n        ),\n      )\n      .param('queryKey', (p) => p.type('QueryKey<Options>'))\n      .param('page', (p) => p.type('K'))\n      .do(\n        $.const('params').assign($.object().spread($('queryKey').attr(0))),\n        $.if($('page').attr('body')).do(\n          $('params')\n            .attr('body')\n            .assign(\n              $.object()\n                .pretty()\n                .spread($('queryKey').attr(0).attr('body').as('any'))\n                .spread($('page').attr('body').as('any')),\n            ),\n        ),\n        $.if($('page').attr('headers')).do(\n          $('params')\n            .attr('headers')\n            .assign(\n              $.object()\n                .pretty()\n                .spread($('queryKey').attr(0).attr('headers'))\n                .spread($('page').attr('headers')),\n            ),\n        ),\n        $.if($('page').attr('path')).do(\n          $('params')\n            .attr('path')\n            .assign(\n              $.object()\n                .pretty()\n                .spread($('queryKey').attr(0).attr('path').as('any'))\n                .spread($('page').attr('path').as('any')),\n            ),\n        ),\n        $.if($('page').attr('query')).do(\n          $('params')\n            .attr('query')\n            .assign(\n              $.object()\n                .pretty()\n                .spread($('queryKey').attr(0).attr('query').as('any'))\n                .spread($('page').attr('query').as('any')),\n            ),\n        ),\n        $.return($('params').as('unknown').as($('page').typeofType())),\n      ),\n  );\n  plugin.node(fn);\n};\n\nexport const createInfiniteQueryOptions = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): void => {\n  const pagination = operationPagination({\n    context: plugin.context,\n    operation,\n  });\n\n  if (!pagination) {\n    return;\n  }\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n\n  if (\n    !plugin.getSymbol({\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    })\n  ) {\n    createQueryKeyType({ plugin });\n    createQueryKeyFunction({ plugin });\n  }\n\n  if (\n    !plugin.getSymbol({\n      category: 'utility',\n      resource: 'createInfiniteParams',\n      tool: plugin.name,\n    })\n  ) {\n    createInfiniteParamsFunction({ plugin });\n  }\n\n  const symbolInfiniteQueryOptions = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.infiniteQueryOptions`,\n  });\n  const symbolInfiniteDataType = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.InfiniteData`,\n  });\n\n  const typeData = useTypeData({ operation, plugin });\n  const typeResponse = useTypeResponse({ operation, plugin });\n\n  const symbolQueryKeyType = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'QueryKey',\n    tool: plugin.name,\n  });\n  const typeQueryKey = $.type(symbolQueryKeyType).generic(typeData);\n  const typePageObjectParam = $.type('Pick').generics(\n    typeQueryKey.idx(0),\n    $.type.or(\n      $.type.literal('body'),\n      $.type.literal('headers'),\n      $.type.literal('path'),\n      $.type.literal('query'),\n    ),\n  );\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  const type = pluginTypeScript.api.schemaToType({\n    plugin: pluginTypeScript,\n    schema: pagination.schema,\n    state: {\n      path: ref([]),\n    },\n  });\n\n  const symbolInfiniteQueryKey = plugin.symbol(\n    applyNaming(operation.id, plugin.config.infiniteQueryKeys),\n  );\n  const node = queryKeyStatement({\n    isInfinite: true,\n    operation,\n    plugin,\n    symbol: symbolInfiniteQueryKey,\n    typeQueryKey,\n  });\n  plugin.node(node);\n\n  const awaitSdkFn = $.lazy((ctx) =>\n    ctx\n      .access(\n        plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }),\n      )\n      .call(\n        $.object()\n          .spread('options')\n          .spread('params')\n          .prop('signal', $('signal'))\n          .prop('throwOnError', $.literal(true)),\n      )\n      .await(),\n  );\n\n  const symbolCreateInfiniteParams = plugin.referenceSymbol({\n    category: 'utility',\n    resource: 'createInfiniteParams',\n    tool: plugin.name,\n  });\n\n  const statements: Array<TsDsl<any>> = [\n    $.const('page')\n      .type(typePageObjectParam)\n      .hint('@ts-ignore')\n      .assign(\n        $.ternary($('pageParam').typeofExpr().eq($.literal('object')))\n          .do('pageParam')\n          .otherwise(\n            $.object()\n              .pretty()\n              .prop(\n                pagination.in,\n                $.object().pretty().prop(pagination.name, $('pageParam')),\n              ),\n          ),\n      ),\n    $.const('params').assign(\n      $(symbolCreateInfiniteParams).call('queryKey', 'page'),\n    ),\n  ];\n\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push(\n      $.const().object('data').assign(awaitSdkFn),\n      $.return('data'),\n    );\n  }\n\n  const symbolInfiniteQueryOptionsFn = plugin.symbol(\n    applyNaming(operation.id, plugin.config.infiniteQueryOptions),\n  );\n  const statement = $.const(symbolInfiniteQueryOptionsFn)\n    .export()\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $.func()\n        .param('options', (p) => p.required(isRequiredOptions).type(typeData))\n        .do(\n          $.return(\n            $(symbolInfiniteQueryOptions)\n              .call(\n                $.object()\n                  .pretty()\n                  .hint('@ts-ignore')\n                  .prop(\n                    'queryFn',\n                    $.func()\n                      .async()\n                      .param((p) => p.object('pageParam', 'queryKey', 'signal'))\n                      .do(...statements),\n                  )\n                  .prop('queryKey', $(symbolInfiniteQueryKey).call('options'))\n                  .$if(\n                    handleMeta(plugin, operation, 'infiniteQueryOptions'),\n                    (o, v) => o.prop('meta', v),\n                  ),\n              )\n              .generics(\n                typeResponse,\n                useTypeError({ operation, plugin }),\n                $.type(symbolInfiniteDataType).generic(typeResponse),\n                typeQueryKey,\n                $.type.or(type, typePageObjectParam),\n              ),\n          ),\n        ),\n    );\n  plugin.node(statement);\n};\n","import type { IR } from '~/ir/types';\nimport { createOperationComment } from '~/plugins/shared/utils/operation';\nimport type { TsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\n\nimport { handleMeta } from '../shared/meta';\nimport { useTypeData, useTypeError, useTypeResponse } from '../shared/useType';\nimport type { PluginInstance } from '../types';\n\nexport const createMutationOptions = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): void => {\n  const symbolMutationOptionsType = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.MutationOptions`,\n  });\n\n  const typeData = useTypeData({ operation, plugin });\n  const mutationType = $.type(symbolMutationOptionsType)\n    .generic(useTypeResponse({ operation, plugin }))\n    .generic(useTypeError({ operation, plugin }))\n    .generic(typeData);\n\n  const fnOptions = 'fnOptions';\n\n  const awaitSdkFn = $.lazy((ctx) =>\n    ctx\n      .access(\n        plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }),\n      )\n      .call(\n        $.object()\n          .spread('options')\n          .spread(fnOptions)\n          .prop('throwOnError', $.literal(true)),\n      )\n      .await(),\n  );\n\n  const statements: Array<TsDsl<any>> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push(\n      $.const().object('data').assign(awaitSdkFn),\n      $.return('data'),\n    );\n  }\n\n  const mutationOptionsFn = 'mutationOptions';\n  const symbolMutationOptions = plugin.symbol(\n    applyNaming(operation.id, plugin.config.mutationOptions),\n  );\n  const statement = $.const(symbolMutationOptions)\n    .export()\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $.func()\n        .param('options', (p) =>\n          p.optional().type($.type('Partial').generic(typeData)),\n        )\n        .returns(mutationType)\n        .do(\n          $.const(mutationOptionsFn)\n            .type(mutationType)\n            .assign(\n              $.object()\n                .pretty()\n                .prop(\n                  'mutationFn',\n                  $.func()\n                    .async()\n                    .param(fnOptions)\n                    .do(...statements),\n                )\n                .$if(handleMeta(plugin, operation, 'mutationOptions'), (c, v) =>\n                  c.prop('meta', v),\n                ),\n            ),\n          $(mutationOptionsFn).return(),\n        ),\n    );\n  plugin.node(statement);\n};\n","import type { IR } from '~/ir/types';\nimport {\n  createOperationComment,\n  hasOperationSse,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport type { TsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\n\nimport {\n  createQueryKeyFunction,\n  createQueryKeyType,\n  queryKeyStatement,\n} from '../queryKey';\nimport { handleMeta } from '../shared/meta';\nimport { useTypeData, useTypeError, useTypeResponse } from '../shared/useType';\nimport type { PluginInstance } from '../types';\n\nconst optionsParamName = 'options';\n\nexport const createQueryOptions = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n\n  if (\n    !plugin.getSymbol({\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    })\n  ) {\n    createQueryKeyType({ plugin });\n    createQueryKeyFunction({ plugin });\n  }\n\n  const symbolQueryOptions = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.queryOptions`,\n  });\n\n  const symbolQueryKey = plugin.symbol(\n    applyNaming(operation.id, plugin.config.queryKeys),\n  );\n  const node = queryKeyStatement({\n    isInfinite: false,\n    operation,\n    plugin,\n    symbol: symbolQueryKey,\n  });\n  plugin.node(node);\n\n  const typeResponse = useTypeResponse({ operation, plugin });\n\n  const awaitSdkFn = $.lazy((ctx) =>\n    ctx\n      .access(\n        plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }),\n      )\n      .call(\n        $.object()\n          .spread(optionsParamName)\n          .spread($('queryKey').attr(0))\n          .prop('signal', $('signal'))\n          .prop('throwOnError', $.literal(true)),\n      )\n      .await(),\n  );\n\n  const statements: Array<TsDsl<any>> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push(\n      $.const().object('data').assign(awaitSdkFn),\n      $.return('data'),\n    );\n  }\n\n  const queryOptionsObj = $.object()\n    .pretty()\n    .prop(\n      'queryFn',\n      $.func()\n        .async()\n        .param((p) => p.object('queryKey', 'signal'))\n        .do(...statements),\n    )\n    .prop('queryKey', $(symbolQueryKey).call(optionsParamName))\n    .$if(handleMeta(plugin, operation, 'queryOptions'), (o, v) =>\n      o.prop('meta', v),\n    );\n\n  const symbolQueryOptionsFn = plugin.symbol(\n    applyNaming(operation.id, plugin.config.queryOptions),\n    {\n      meta: {\n        category: 'hook',\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'queryOptions',\n        tool: plugin.name,\n      },\n    },\n  );\n  // TODO: add type error\n  // TODO: AxiosError<PutSubmissionMetaError>\n  const statement = $.const(symbolQueryOptionsFn)\n    .export(plugin.config.queryOptions.exported)\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $.func()\n        .param(optionsParamName, (p) =>\n          p\n            .required(isRequiredOptions)\n            .type(useTypeData({ operation, plugin })),\n        )\n        .do(\n          $(symbolQueryOptions)\n            .call(queryOptionsObj)\n            .generics(\n              typeResponse,\n              useTypeError({ operation, plugin }),\n              typeResponse,\n              $(symbolQueryKey).returnType(),\n            )\n            .return(),\n        ),\n    );\n  plugin.node(statement);\n};\n","import type { IR } from '~/ir/types';\nimport {\n  createOperationComment,\n  hasOperationSse,\n  isOperationOptionsRequired,\n} from '~/plugins/shared/utils/operation';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\n\nimport { useTypeData } from '../shared/useType';\nimport type { PluginInstance } from '../types';\n\nconst optionsParamName = 'options';\n\nexport const createUseQuery = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  if (!('useQuery' in plugin.config)) {\n    return;\n  }\n\n  const symbolUseQueryFn = plugin.symbol(\n    applyNaming(operation.id, plugin.config.useQuery),\n  );\n\n  const symbolUseQuery = plugin.referenceSymbol({\n    category: 'external',\n    resource: `${plugin.name}.useQuery`,\n  });\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n  const typeData = useTypeData({ operation, plugin });\n\n  const symbolQueryOptionsFn = plugin.referenceSymbol({\n    category: 'hook',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'queryOptions',\n    tool: plugin.name,\n  });\n  const statement = $.const(symbolUseQueryFn)\n    .export()\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $.func()\n        .param(optionsParamName, (p) =>\n          p.required(isRequiredOptions).type(typeData),\n        )\n        .do(\n          $(symbolUseQuery)\n            .call($(symbolQueryOptionsFn).call(optionsParamName))\n            .return(),\n        ),\n    );\n  plugin.node(statement);\n};\n","import type { PluginHandler } from '../types';\nimport { createInfiniteQueryOptions } from './infiniteQueryOptions';\nimport { createMutationOptions } from './mutationOptions';\nimport { createQueryOptions } from './queryOptions';\nimport { createUseQuery } from './useQuery';\n\nexport const handlerV5: PluginHandler = ({ plugin }) => {\n  plugin.symbol('DefaultError', {\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.DefaultError`,\n    },\n  });\n  plugin.symbol('InfiniteData', {\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.InfiniteData`,\n    },\n  });\n  const mutationsType =\n    plugin.name === '@tanstack/angular-query-experimental' ||\n    plugin.name === '@tanstack/svelte-query' ||\n    plugin.name === '@tanstack/solid-query'\n      ? 'MutationOptions'\n      : 'UseMutationOptions';\n  plugin.symbol(mutationsType, {\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.MutationOptions`,\n    },\n  });\n  plugin.symbol('infiniteQueryOptions', {\n    external: plugin.name,\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.infiniteQueryOptions`,\n    },\n  });\n  plugin.symbol('queryOptions', {\n    external: plugin.name,\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.queryOptions`,\n    },\n  });\n  plugin.symbol('useQuery', {\n    external: plugin.name,\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.useQuery`,\n    },\n  });\n  plugin.symbol('AxiosError', {\n    external: 'axios',\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: 'axios.AxiosError',\n    },\n  });\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      if (plugin.hooks.operation.isQuery(operation)) {\n        if (plugin.config.queryOptions.enabled) {\n          createQueryOptions({ operation, plugin });\n        }\n\n        if (plugin.config.infiniteQueryOptions.enabled) {\n          createInfiniteQueryOptions({ operation, plugin });\n        }\n\n        if ('useQuery' in plugin.config && plugin.config.useQuery.enabled) {\n          createUseQuery({ operation, plugin });\n        }\n      }\n\n      if (plugin.hooks.operation.isMutation(operation)) {\n        if (plugin.config.mutationOptions.enabled) {\n          createMutationOptions({ operation, plugin });\n        }\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import type { PluginHandler } from './types';\nimport { handlerV5 } from './v5/plugin';\n\nexport const handler: PluginHandler = (args) =>\n  handlerV5(args as Parameters<PluginHandler>[0]);\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { TanStackAngularQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackAngularQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackAngularQueryPlugin['Handler'],\n  name: '@tanstack/angular-query-experimental',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/angular-query-experimental` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { TanStackReactQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackReactQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackReactQueryPlugin['Handler'],\n  name: '@tanstack/react-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n\n    plugin.config.useQuery = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: false,\n        name: 'use{{name}}Query',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ enabled: true, name }),\n        object: (fields) => ({ enabled: true, ...fields }),\n        string: (name) => ({ enabled: true, name }),\n      },\n      value: plugin.config.useQuery,\n    });\n\n    if (plugin.config.useQuery.enabled) {\n      // useQuery hooks consume queryOptions\n      if (!plugin.config.queryOptions.enabled) {\n        plugin.config.queryOptions.enabled = true;\n        plugin.config.queryOptions.exported = false;\n      }\n    }\n  },\n};\n\n/**\n * Type helper for `@tanstack/react-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { TanStackSolidQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackSolidQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackSolidQueryPlugin['Handler'],\n  name: '@tanstack/solid-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/solid-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { TanStackSvelteQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackSvelteQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackSvelteQueryPlugin['Handler'],\n  name: '@tanstack/svelte-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/svelte-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { handler } from '~/plugins/@tanstack/query-core/plugin';\nimport { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport type { TanStackVueQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackVueQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackVueQueryPlugin['Handler'],\n  name: '@tanstack/vue-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/vue-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { $ } from '~/ts-dsl';\n\nimport type { ValidatorArgs } from '../shared/types';\n\nexport const createRequestValidatorV2 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'arktype',\n  });\n  if (!symbol) return;\n\n  // const out = User({\n  //   name: \"Alan Turing\",\n  //   device: {\n  //     platform: \"enigma\",\n  //     versions: [0, \"1\", 0n]\n  //   }\n  // })\n  // if (out instanceof type.errors) {\n  //   // hover out.summary to see validation errors\n  //   console.error(out.summary)\n  // } else {\n  //   // hover out to see your validated data\n  //   console.log(`Hello, ${out.name}`)\n  // }\n  const dataParameterName = 'data';\n  return $.func()\n    .async()\n    .param(dataParameterName)\n    .do($(symbol).attr('parseAsync').call(dataParameterName).await().return());\n};\n\nexport const createResponseValidatorV2 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'arktype',\n  });\n  if (!symbol) return;\n\n  const dataParameterName = 'data';\n  return $.func()\n    .async()\n    .param(dataParameterName)\n    .do($(symbol).attr('parseAsync').call(dataParameterName).await().return());\n};\n","import type { $ } from '~/ts-dsl';\n\nimport type { ValidatorArgs } from './shared/types';\nimport { createRequestValidatorV2, createResponseValidatorV2 } from './v2/api';\n\nexport type IApi = {\n  createRequestValidator: (\n    args: ValidatorArgs,\n  ) => ReturnType<typeof $.func> | undefined;\n  createResponseValidator: (\n    args: ValidatorArgs,\n  ) => ReturnType<typeof $.func> | undefined;\n};\n\nexport class Api implements IApi {\n  createRequestValidator(\n    args: ValidatorArgs,\n  ): ReturnType<typeof $.func> | undefined {\n    return createRequestValidatorV2(args);\n  }\n\n  createResponseValidator(\n    args: ValidatorArgs,\n  ): ReturnType<typeof $.func> | undefined {\n    return createResponseValidatorV2(args);\n  }\n}\n","export const identifiers = {\n  keywords: {\n    false: 'false',\n    true: 'true',\n  },\n  /**\n   * {@link https://arktype.io/docs/primitives#number Number}\n   */\n  number: {\n    Infinity: 'Infinity',\n    NaN: 'NaN',\n    NegativeInfinity: 'NegativeInfinity',\n    epoch: 'epoch',\n    integer: 'integer',\n    safe: 'safe',\n  },\n  /**\n   * {@link https://arktype.io/docs/primitives Primitives}\n   */\n  primitives: {\n    bigint: 'bigint',\n    boolean: 'boolean',\n    keywords: 'keywords',\n    null: 'null',\n    number: 'number',\n    string: 'string',\n    symbol: 'symbol',\n    undefined: 'undefined',\n    unit: 'unit',\n  },\n  /**\n   * {@link https://arktype.io/docs/primitives#string String}\n   */\n  string: {\n    NFC: 'NFC',\n    NFD: 'NFD',\n    NFKC: 'NFKC',\n    NFKD: 'NFKD',\n    alpha: 'alpha',\n    alphanumeric: 'alphanumeric',\n    base64: 'base64',\n    capitalize: 'capitalize',\n    creditCard: 'creditCard',\n    date: 'date',\n    digits: 'digits',\n    email: 'email',\n    epoch: 'epoch',\n    hex: 'hex',\n    integer: 'integer',\n    ip: 'ip',\n    iso: 'iso',\n    json: 'json',\n    lower: 'lower',\n    normalize: 'normalize',\n    numeric: 'numeric',\n    parse: 'parse',\n    preformatted: 'preformatted',\n    regex: 'regex',\n    semver: 'semver',\n    trim: 'trim',\n    upper: 'upper',\n    url: 'url',\n    uuid: 'uuid',\n    v1: 'v1',\n    v2: 'v2',\n    v3: 'v3',\n    v4: 'v4',\n    v5: 'v5',\n    v6: 'v6',\n    v7: 'v7',\n    v8: 'v8',\n  },\n  /**\n   * {@link https://arktype.io/docs/type-api Type API}\n   */\n  type: {\n    $: '$',\n    allows: 'allows',\n    and: 'and',\n    array: 'array',\n    as: 'as',\n    assert: 'assert',\n    brand: 'brand',\n    configure: 'configure',\n    default: 'default',\n    describe: 'describe',\n    description: 'description',\n    equals: 'equals',\n    exclude: 'exclude',\n    expression: 'expression',\n    extends: 'extends',\n    extract: 'extract',\n    filter: 'filter',\n    from: 'from',\n    ifEquals: 'ifEquals',\n    ifExtends: 'ifExtends',\n    infer: 'infer',\n    inferIn: 'inferIn',\n    intersect: 'intersect',\n    json: 'json',\n    meta: 'meta',\n    narrow: 'narrow',\n    onDeepUndeclaredKey: 'onDeepUndeclaredKey',\n    onUndeclaredKey: 'onUndeclaredKey',\n    optional: 'optional',\n    or: 'or',\n    overlaps: 'overlaps',\n    pipe: 'pipe',\n    select: 'select',\n    to: 'to',\n    toJsonSchema: 'toJsonSchema',\n  },\n};\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../constants';\nimport type { ArktypePlugin } from '../types';\nimport type { Ast } from './types';\n\nexport const exportAst = ({\n  ast,\n  plugin,\n  schema,\n  symbol,\n  typeInferSymbol,\n}: {\n  ast: Ast;\n  plugin: ArktypePlugin['Instance'];\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n  typeInferSymbol: Symbol | undefined;\n}): void => {\n  const type = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'arktype.type',\n  });\n\n  const statement = $.const(symbol)\n    .export()\n    .$if(plugin.config.comments && createSchemaComment(schema), (c, v) =>\n      c.doc(v),\n    )\n    // .type(\n    //   ast.typeName\n    //     ? (tsc.propertyAccessExpression({\n    //         expression: z,\n    //         name: ast.typeName,\n    //       }) as unknown as ts.TypeNode)\n    //     : undefined,\n    // )\n    .assign($(type).call(ast.def ? $.literal(ast.def) : ast.expression));\n  plugin.node(statement);\n\n  if (typeInferSymbol) {\n    const inferType = $.type\n      .alias(typeInferSymbol)\n      .export()\n      .type($.type(symbol).attr(identifiers.type.infer).typeofType());\n    plugin.node(inferType);\n  }\n};\n","import type { SchemaWithType } from '~/plugins/shared/types/schema';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'null'>;\n  },\n): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.def = identifiers.primitives.null;\n  return result as Omit<Ast, 'typeName'>;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport type { SchemaWithType } from '~/plugins/shared/types/schema';\nimport { $ } from '~/ts-dsl';\n\n// import { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  // TODO: parser - handle constants\n\n  const shape = $.object().pretty();\n\n  const required = schema.required ?? [];\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const isRequired = required.includes(name);\n\n    const propertyAst = irSchemaToAst({\n      optional: !isRequired,\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: ref([...fromRef(state.path), 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    // if (propertyAst.hasCircularReference) {\n    //   properties.push(\n    //     tsc.getAccessorDeclaration({\n    //       name: propertyName,\n    //       // @ts-expect-error\n    //       returnType: propertyAst.typeName\n    //         ? tsc.propertyAccessExpression({\n    //             expression: 'TODO',\n    //             name: propertyAst.typeName,\n    //           })\n    //         : undefined,\n    //       statements: [\n    //         tsc.returnStatement({\n    //           expression: propertyAst.expression,\n    //         }),\n    //       ],\n    //     }),\n    //   );\n    // } else {\n    //   properties.push(\n    //     tsc.propertyAssignment({\n    //       initializer: propertyAst.expression,\n    //       name: ts.factory.createComputedPropertyName(\n    //         ts.factory.createStringLiteral(`${propertyName}?`),\n    //       ),\n    //     }),\n    //   );\n    // }\n\n    shape.prop(isRequired ? name : `${name}?`, propertyAst.expression);\n  }\n\n  if (\n    schema.additionalProperties &&\n    (!schema.properties || !Object.keys(schema.properties).length)\n  ) {\n    const additionalAst = irSchemaToAst({\n      plugin,\n      schema: schema.additionalProperties,\n      state: {\n        ...state,\n        path: ref([...fromRef(state.path), 'additionalProperties']),\n      },\n    });\n    // name: identifiers.record,\n    result.expression = $('TODO').attr('record').call(\n      // name: identifiers.string,\n      $('TODO').attr('string').call(),\n      additionalAst.expression,\n    );\n    if (additionalAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = shape;\n\n  // return with typeName for circular references\n  if (result.hasLazyExpression) {\n    return {\n      ...result,\n      typeName: 'TODO',\n    } as Ast;\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins/shared/types/schema';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const stringToAst = ({\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  if (typeof schema.const === 'string') {\n    result.def = schema.const;\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  let def = identifiers.primitives.string;\n\n  if (schema.format) {\n    switch (schema.format) {\n      case 'date':\n      case 'date-time':\n      case 'time':\n        def = `${def}.${identifiers.string.date}.${identifiers.string.iso}`;\n        break;\n      case 'email':\n        def = `${def}.${identifiers.string.email}`;\n        break;\n      case 'ipv4':\n        def = `${def}.${identifiers.string.ip}.${identifiers.string.v4}`;\n        break;\n      case 'ipv6':\n        def = `${def}.${identifiers.string.ip}.${identifiers.string.v6}`;\n        break;\n      case 'uri':\n        def = `${def}.${identifiers.string.url}`;\n        break;\n      case 'uuid':\n        def = `${def}.${identifiers.string.uuid}`;\n        break;\n    }\n  }\n\n  if (schema.minLength === schema.maxLength && schema.minLength !== undefined) {\n    def = `${schema.minLength} <= ${def} <= ${schema.maxLength}`;\n  } else {\n    if (schema.maxLength !== undefined) {\n      def = `${def} <= ${schema.maxLength}`;\n\n      if (schema.minLength !== undefined) {\n        def = `${schema.minLength} <= ${def}`;\n      }\n    } else if (schema.minLength !== undefined) {\n      def = `${def} >= ${schema.minLength}`;\n    }\n  }\n\n  if (schema.pattern) {\n    def = `/${schema.pattern}/`;\n  }\n\n  result.def = def;\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins/shared/types/schema';\nimport { $ } from '~/ts-dsl';\n\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { nullToAst } from './null';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\n// import { arrayToAst } from \"./array\";\n// import { booleanToAst } from \"./boolean\";\n// import { enumToAst } from \"./enum\";\n// import { neverToAst } from \"./never\";\n// import { numberToAst } from \"./number\";\n// import { tupleToAst } from \"./tuple\";\n// import { undefinedToAst } from \"./undefined\";\n// import { unknownToAst } from \"./unknown\";\n// import { voidToAst } from \"./void\";\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> => {\n  switch (schema.type) {\n    // case 'array':\n    //   return arrayToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'array'>,\n    //   });\n    // case 'boolean':\n    //   return booleanToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'boolean'>,\n    //   });\n    // case 'enum':\n    //   return enumToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'enum'>,\n    //   });\n    // case 'integer':\n    // case 'number':\n    //   return numberToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'integer' | 'number'>,\n    //   });\n    // case 'never':\n    //   return neverToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'never'>,\n    //   });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return stringToAst({\n        ...args,\n        schema: schema as SchemaWithType<'string'>,\n      });\n    // case 'tuple':\n    //   return tupleToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'tuple'>,\n    //   });\n    // case 'undefined':\n    //   return undefinedToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'undefined'>,\n    //   });\n    // case 'unknown':\n    //   return unknownToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'unknown'>,\n    //   });\n    // case 'void':\n    //   return voidToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'void'>,\n    //   });\n  }\n\n  const type = args.plugin.referenceSymbol({\n    category: 'external',\n    resource: 'arktype.type',\n  });\n\n  const expression = $(type).call(\n    $.object()\n      .prop('name', $.literal('string'))\n      .prop('platform', $.literal(\"'android' | 'ios'\"))\n      .prop('versions?', $.literal('(number | string)[]')),\n  );\n\n  return {\n    def: '',\n    expression,\n    hasLazyExpression: false,\n  };\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport { fromRef, refs } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport type { SchemaWithType } from '~/plugins/shared/types/schema';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { exportAst } from '../shared/export';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport type { ArktypePlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  // optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  let ast: Partial<Ast> = {};\n\n  // const z = plugin.referenceSymbol({\n  //   category: 'external',\n  //   resource: 'arktype.type',\n  // });\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'arktype',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      const ref = $(refSymbol);\n      ast.expression = ref;\n    } else {\n      // expression: z,\n      // name: identifiers.lazy,\n      const lazyExpression = $('TODO')\n        .attr('TODO')\n        .call($.func().returns('any').do($.return(refSymbol)));\n      ast.expression = lazyExpression;\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression['~ref'] = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.def = typeAst.def;\n    ast.expression = typeAst.expression;\n    ast.hasLazyExpression = typeAst.hasLazyExpression;\n\n    if (plugin.config.metadata && schema.description) {\n      // TODO: add description\n      // ast.expression = tsc.callExpression({\n      //   functionName: tsc.propertyAccessExpression({\n      //     expression: ast.expression,\n      //     name: identifiers.register,\n      //   }),\n      //   parameters: [\n      //     tsc.propertyAccessExpression({\n      //       expression: z,\n      //       name: identifiers.globalRegistry,\n      //     }),\n      //     tsc.objectExpression({\n      //       obj: [\n      //         {\n      //           key: 'description',\n      //           value: tsc.stringLiteral({ text: schema.description }),\n      //         },\n      //       ],\n      //     }),\n      //   ],\n      // });\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      //     const itemSchemas = schema.items.map((item, index) =>\n      //       irSchemaToAst({\n      //         plugin,\n      //         schema: item,\n      //         state: {\n      //           ...state,\n      //           _path: [...state._path, 'items', index],\n      //         },\n      //       }),\n      //     );\n      //     if (schema.logicalOperator === 'and') {\n      //       const firstSchema = schema.items[0]!;\n      //       // we want to add an intersection, but not every schema can use the same API.\n      //       // if the first item contains another array or not an object, we cannot use\n      //       // `.merge()` as that does not exist on `.union()` and non-object schemas.\n      //       if (\n      //         firstSchema.logicalOperator === 'or' ||\n      //         (firstSchema.type && firstSchema.type !== 'object')\n      //       ) {\n      //         ast.expression = tsc.callExpression({\n      //           functionName: tsc.propertyAccessExpression({\n      //             expression: z,\n      //             name: identifiers.intersection,\n      //           }),\n      //           parameters: itemSchemas.map((schema) => schema.expression),\n      //         });\n      //       } else {\n      //         ast.expression = itemSchemas[0]!.expression;\n      //         itemSchemas.slice(1).forEach((schema) => {\n      //           ast.expression = tsc.callExpression({\n      //             functionName: tsc.propertyAccessExpression({\n      //               expression: ast.expression!,\n      //               name: identifiers.and,\n      //             }),\n      //             parameters: [\n      //               schema.hasCircularReference\n      //                 ? tsc.callExpression({\n      //                     functionName: tsc.propertyAccessExpression({\n      //                       expression: z,\n      //                       name: identifiers.lazy,\n      //                     }),\n      //                     parameters: [\n      //                       tsc.arrowFunction({\n      //                         statements: [\n      //                           tsc.returnStatement({\n      //                             expression: schema.expression,\n      //                           }),\n      //                         ],\n      //                       }),\n      //                     ],\n      //                   })\n      //                 : schema.expression,\n      //             ],\n      //           });\n      //         });\n      //       }\n      //     } else {\n      //       ast.expression = tsc.callExpression({\n      //         functionName: tsc.propertyAccessExpression({\n      //           expression: z,\n      //           name: identifiers.union,\n      //         }),\n      //         parameters: [\n      //           tsc.arrayLiteralExpression({\n      //             elements: itemSchemas.map((schema) => schema.expression),\n      //           }),\n      //         ],\n      //       });\n      //     }\n    } else {\n      ast = irSchemaToAst({ plugin, schema, state });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.def = typeAst.def;\n    ast.expression = typeAst.expression;\n  }\n\n  // TODO: remove later\n  if (!ast.expression) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n  }\n  // END TODO: remove later\n\n  // if (ast.expression) {\n  //   if (schema.accessScope === 'read') {\n  //     ast.expression = tsc.callExpression({\n  //       functionName: tsc.propertyAccessExpression({\n  //         expression: ast.expression,\n  //         name: identifiers.readonly,\n  //       }),\n  //     });\n  //   }\n\n  //   if (optional) {\n  //     ast.expression = tsc.callExpression({\n  //       functionName: tsc.propertyAccessExpression({\n  //         expression: z,\n  //         name: identifiers.optional,\n  //       }),\n  //       parameters: [ast.expression],\n  //     });\n  //     ast.typeName = identifiers.ZodOptional;\n  //   }\n\n  //   if (schema.default !== undefined) {\n  //     const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n  //     const callParameter = numberParameter({\n  //       isBigInt,\n  //       value: schema.default,\n  //     });\n  //     if (callParameter) {\n  //       ast.expression = tsc.callExpression({\n  //         functionName: tsc.propertyAccessExpression({\n  //           expression: ast.expression,\n  //           name: identifiers.default,\n  //         }),\n  //         parameters: [callParameter],\n  //       });\n  //     }\n  //   }\n  // }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(fromRef(state.path));\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.symbol(\n    applyNaming(baseName, plugin.config.definitions),\n    {\n      meta: {\n        category: 'schema',\n        path: fromRef(state.path),\n        resource: 'definition',\n        resourceId: $ref,\n        tags: fromRef(state.tags),\n        tool: 'arktype',\n      },\n    },\n  );\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.symbol(\n        applyNaming(baseName, plugin.config.definitions.types.infer),\n        {\n          meta: {\n            category: 'type',\n            path: fromRef(state.path),\n            resource: 'definition',\n            resourceId: $ref,\n            tool: 'arktype',\n            variant: 'infer',\n          },\n        },\n      )\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n};\n\nexport const handlerV2: ArktypePlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('type', {\n    external: 'arktype',\n    meta: {\n      category: 'external',\n      resource: 'arktype.type',\n    },\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = refs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        //   case 'operation':\n        //     operationToZodSchema({\n        //       getZodSchema: (schema) => {\n        //         const state: State = {\n        //           circularReferenceTracker: [],\n        //           currentReferenceTracker: [],\n        //           hasCircularReference: false,\n        //         };\n        //         return schemaToZodSchema({ plugin, schema, state });\n        //       },\n        //       operation: event.operation,\n        //       plugin,\n        //     });\n        //     break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        //   case 'webhook':\n        //     webhookToZodSchema({\n        //       getZodSchema: (schema) => {\n        //         const state: State = {\n        //           circularReferenceTracker: [],\n        //           currentReferenceTracker: [],\n        //           hasCircularReference: false,\n        //         };\n        //         return schemaToZodSchema({ plugin, schema, state });\n        //       },\n        //       operation: event.operation,\n        //       plugin,\n        //     });\n        //     break;\n      }\n    },\n  );\n};\n","import type { ArktypePlugin } from './types';\nimport { handlerV2 } from './v2/plugin';\n\nexport const handler: ArktypePlugin['Handler'] = (args) => handlerV2(args);\n","import { definePluginConfig, mappers } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { ArktypePlugin } from './types';\n\nexport const defaultConfig: ArktypePlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'PascalCase',\n    comments: true,\n    exportFromIndex: false,\n    metadata: false,\n  },\n  handler,\n  name: 'arktype',\n  resolveConfig: (plugin, context) => {\n    plugin.config.types = context.valueToObject({\n      defaultValue: {\n        infer: {\n          case: 'PascalCase',\n          enabled: false,\n        },\n      },\n      mappers: {\n        object: (fields, defaultValue) => ({\n          ...fields,\n          infer: context.valueToObject({\n            defaultValue: {\n              ...(defaultValue.infer as Extract<\n                typeof defaultValue.infer,\n                Record<string, unknown>\n              >),\n              enabled:\n                fields.infer !== undefined\n                  ? Boolean(fields.infer)\n                  : (\n                      defaultValue.infer as Extract<\n                        typeof defaultValue.infer,\n                        Record<string, unknown>\n                      >\n                    ).enabled,\n            },\n            mappers,\n            value: fields.infer,\n          }),\n        }),\n      },\n      value: plugin.config.types,\n    });\n\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}Data',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}Data',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}Response',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}Response',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}WebhookRequest',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}WebhookRequest',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n  tags: ['validator'],\n};\n\n/**\n * Type helper for Arktype plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { operationResponsesMap } from '~/ir/operation';\nimport { hasParameterGroupObjectRequired } from '~/ir/parameter';\nimport type { IR } from '~/ir/types';\nimport { $ } from '~/ts-dsl';\n\nimport type { FastifyPlugin } from './types';\n\nconst operationToRouteHandler = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: FastifyPlugin['Instance'];\n}) => {\n  const type = $.type.object();\n\n  const symbolDataType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'typescript',\n  });\n  if (symbolDataType) {\n    if (operation.body) {\n      type.prop('Body', (p) =>\n        p\n          .required(operation.body!.required)\n          .type($.type(symbolDataType).idx($.type.literal('body'))),\n      );\n    }\n\n    if (operation.parameters) {\n      if (operation.parameters.header) {\n        type.prop('Headers', (p) =>\n          p\n            .required(\n              hasParameterGroupObjectRequired(operation.parameters!.header),\n            )\n            .type($.type(symbolDataType).idx($.type.literal('headers'))),\n        );\n      }\n\n      if (operation.parameters.path) {\n        type.prop('Params', (p) =>\n          p\n            .required(\n              hasParameterGroupObjectRequired(operation.parameters!.path),\n            )\n            .type($.type(symbolDataType).idx($.type.literal('path'))),\n        );\n      }\n\n      if (operation.parameters.query) {\n        type.prop('Querystring', (p) =>\n          p\n            .required(\n              hasParameterGroupObjectRequired(operation.parameters!.query),\n            )\n            .type($.type(symbolDataType).idx($.type.literal('query'))),\n        );\n      }\n    }\n  }\n\n  const { errors, responses } = operationResponsesMap(operation);\n\n  let errorsTypeReference: ReturnType<typeof $.type> | undefined;\n  const symbolErrorType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'errors',\n  });\n  if (symbolErrorType && errors && errors.properties) {\n    const keys = Object.keys(errors.properties);\n    if (keys.length) {\n      const hasDefaultResponse = keys.includes('default');\n      if (!hasDefaultResponse) {\n        errorsTypeReference = $.type(symbolErrorType);\n      } else if (keys.length > 1) {\n        errorsTypeReference = $.type('Omit', (t) =>\n          t.generics($.type(symbolErrorType), $.type.literal('default')),\n        );\n      }\n    }\n  }\n\n  let responsesTypeReference: ReturnType<typeof $.type> | undefined = undefined;\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n  });\n  if (symbolResponseType && responses && responses.properties) {\n    const keys = Object.keys(responses.properties);\n    if (keys.length) {\n      const hasDefaultResponse = keys.includes('default');\n      if (!hasDefaultResponse) {\n        responsesTypeReference = $.type(symbolResponseType);\n      } else if (keys.length > 1) {\n        responsesTypeReference = $.type('Omit', (t) =>\n          t.generics($.type(symbolResponseType), $.type.literal('default')),\n        );\n      }\n    }\n  }\n\n  const replyTypes = [errorsTypeReference, responsesTypeReference].filter(\n    (t): t is ReturnType<typeof $.type> => t !== undefined,\n  );\n  if (replyTypes.length) {\n    type.prop('Reply', (p) => p.type($.type.and(...replyTypes)));\n  }\n\n  if (type.isEmpty) {\n    return;\n  }\n\n  const symbolRouteHandler = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'route-handler',\n    tool: 'fastify',\n  });\n  return {\n    name: operation.id,\n    type: $.type(symbolRouteHandler, (t) => t.generic(type)),\n  };\n};\n\nexport const handler: FastifyPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('RouteHandler', {\n    external: 'fastify',\n    kind: 'type',\n    meta: {\n      category: 'type',\n      resource: 'route-handler',\n      tool: 'fastify',\n    },\n  });\n\n  const symbolRouteHandlers = plugin.symbol('RouteHandlers');\n\n  const type = $.type.object();\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const routeHandler = operationToRouteHandler({ operation, plugin });\n      if (routeHandler) {\n        type.prop(routeHandler.name, (p) => p.type(routeHandler.type));\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  const node = $.type.alias(symbolRouteHandlers).export().type(type);\n  plugin.node(node);\n};\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { handler } from './plugin';\nimport type { FastifyPlugin } from './types';\n\nexport const defaultConfig: FastifyPlugin['Config'] = {\n  config: {\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/typescript'],\n  handler,\n  name: 'fastify',\n};\n\n/**\n * Type helper for `fastify` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '~/ir/types';\nimport {\n  createOperationComment,\n  hasOperationSse,\n} from '~/plugins/shared/utils/operation';\nimport type { TsDsl } from '~/ts-dsl';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\n\nimport type { SwrPlugin } from '../types';\n\nexport const createUseSwr = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: SwrPlugin['Instance'];\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  const symbolUseSwr = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'swr',\n  });\n  const symbolUseQueryFn = plugin.symbol(\n    applyNaming(operation.id, plugin.config.useSwr),\n  );\n\n  const awaitSdkFn = $.lazy((ctx) =>\n    ctx\n      .access(\n        plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }),\n      )\n      .call($.object().prop('throwOnError', $.literal(true)))\n      .await(),\n  );\n\n  const statements: Array<TsDsl<any>> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push(\n      $.const().object('data').assign(awaitSdkFn),\n      $.return('data'),\n    );\n  }\n\n  const statement = $.const(symbolUseQueryFn)\n    .export()\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) =>\n      c.doc(v),\n    )\n    .assign(\n      $.func().do(\n        $(symbolUseSwr)\n          .call(\n            $.literal(operation.path),\n            $.func()\n              .async()\n              .do(...statements),\n          )\n          .return(),\n      ),\n    );\n  plugin.node(statement);\n};\n","import type { SwrPlugin } from '../types';\nimport { createUseSwr } from './useSwr';\n\nexport const handlerV2: SwrPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('useSWR', {\n    external: 'swr',\n    importKind: 'default',\n    kind: 'function',\n    meta: {\n      category: 'external',\n      resource: 'swr',\n    },\n  });\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      if (plugin.hooks.operation.isQuery(operation)) {\n        // if (plugin.config.queryOptions.enabled) {\n        //   createQueryOptions({ operation, plugin });\n        // }\n\n        // if (plugin.config.infiniteQueryOptions.enabled) {\n        //   createInfiniteQueryOptions({ operation, plugin });\n        // }\n\n        if (plugin.config.useSwr.enabled) {\n          createUseSwr({ operation, plugin });\n        }\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import type { SwrPlugin } from './types';\nimport { handlerV2 } from './v2/plugin';\n\nexport const handler: SwrPlugin['Handler'] = (args) => handlerV2(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { handler } from './plugin';\nimport type { SwrPlugin } from './types';\n\nexport const defaultConfig: SwrPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as SwrPlugin['Handler'],\n  name: 'swr',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.queryOptions,\n    });\n\n    plugin.config.useSwr = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'use{{name}}',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ enabled: true, name }),\n        object: (fields) => ({ enabled: true, ...fields }),\n        string: (name) => ({ enabled: true, name }),\n      },\n      value: plugin.config.useSwr,\n    });\n\n    if (plugin.config.useSwr.enabled) {\n      // useSwr hooks consume queryOptions\n      if (!plugin.config.queryOptions.enabled) {\n        plugin.config.queryOptions.enabled = true;\n        plugin.config.queryOptions.exported = false;\n      }\n    }\n  },\n};\n\n/**\n * Type helper for `swr` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","export const identifiers = {\n  /**\n   * {@link https://valibot.dev/api/#actions Actions}\n   */\n  actions: {\n    args: 'args',\n    base64: 'base64',\n    bic: 'bic',\n    brand: 'brand',\n    bytes: 'bytes',\n    check: 'check',\n    checkItems: 'checkItems',\n    creditCard: 'creditCard',\n    cuid2: 'cuid2',\n    decimal: 'decimal',\n    description: 'description',\n    digits: 'digits',\n    email: 'email',\n    emoji: 'emoji',\n    empty: 'empty',\n    endsWith: 'endsWith',\n    entries: 'entries',\n    everyItem: 'everyItem',\n    excludes: 'excludes',\n    filterItems: 'filterItems',\n    findItem: 'findItem',\n    finite: 'finite',\n    flavor: 'flavor',\n    graphemes: 'graphemes',\n    gtValue: 'gtValue',\n    hash: 'hash',\n    hexColor: 'hexColor',\n    hexadecimal: 'hexadecimal',\n    imei: 'imei',\n    includes: 'includes',\n    integer: 'integer',\n    ip: 'ip',\n    ipv4: 'ipv4',\n    ipv6: 'ipv6',\n    isoDate: 'isoDate',\n    isoDateTime: 'isoDateTime',\n    isoTime: 'isoTime',\n    isoTimeSecond: 'isoTimeSecond',\n    isoTimestamp: 'isoTimestamp',\n    isoWeek: 'isoWeek',\n    length: 'length',\n    ltValue: 'ltValue',\n    mac: 'mac',\n    mac48: 'mac48',\n    mac64: 'mac64',\n    mapItems: 'mapItems',\n    maxBytes: 'maxBytes',\n    maxEntries: 'maxEntries',\n    maxGraphemes: 'maxGraphemes',\n    maxLength: 'maxLength',\n    maxSize: 'maxSize',\n    maxValue: 'maxValue',\n    maxWords: 'maxWords',\n    metadata: 'metadata',\n    mimeType: 'mimeType',\n    minBytes: 'minBytes',\n    minEntries: 'minEntries',\n    minGraphemes: 'minGraphemes',\n    minLength: 'minLength',\n    minSize: 'minSize',\n    minValue: 'minValue',\n    minWords: 'minWords',\n    multipleOf: 'multipleOf',\n    nanoid: 'nanoid',\n    nonEmpty: 'nonEmpty',\n    normalize: 'normalize',\n    notBytes: 'notBytes',\n    notEntries: 'notEntries',\n    notGraphemes: 'notGraphemes',\n    notLength: 'notLength',\n    notSize: 'notSize',\n    notValue: 'notValue',\n    notValues: 'notValues',\n    notWords: 'notWords',\n    octal: 'octal',\n    parseJson: 'parseJson',\n    partialCheck: 'partialCheck',\n    rawCheck: 'rawCheck',\n    rawTransform: 'rawTransform',\n    readonly: 'readonly',\n    reduceItems: 'reduceItems',\n    regex: 'regex',\n    returns: 'returns',\n    rfcEmail: 'rfcEmail',\n    safeInteger: 'safeInteger',\n    size: 'size',\n    slug: 'slug',\n    someItem: 'someItem',\n    sortItems: 'sortItems',\n    startsWith: 'startsWith',\n    stringifyJson: 'stringifyJson',\n    title: 'title',\n    toLowerCase: 'toLowerCase',\n    toMaxValue: 'toMaxValue',\n    toMinValue: 'toMinValue',\n    toUpperCase: 'toUpperCase',\n    transform: 'transform',\n    trim: 'trim',\n    trimEnd: 'trimEnd',\n    trimStart: 'trimStart',\n    ulid: 'ulid',\n    url: 'url',\n    uuid: 'uuid',\n    value: 'value',\n    values: 'values',\n    words: 'words',\n  },\n  /**\n   * {@link https://valibot.dev/api/#async Async}\n   */\n  async: {\n    argsAsync: 'argsAsync',\n    arrayAsync: 'arrayAsync',\n    awaitAsync: 'awaitAsync',\n    checkAsync: 'checkAsync',\n    checkItemsAsync: 'checkItemsAsync',\n    customAsync: 'customAsync',\n    exactOptionalAsync: 'exactOptionalAsync',\n    fallbackAsync: 'fallbackAsync',\n    forwardAsync: 'forwardAsync',\n    getDefaultsAsync: 'getDefaultsAsync',\n    getFallbacksAsync: 'getFallbacksAsync',\n    intersectAsync: 'intersectAsync',\n    lazyAsync: 'lazyAsync',\n    looseObjectAsync: 'looseObjectAsync',\n    looseTupleAsync: 'looseTupleAsync',\n    mapAsync: 'mapAsync',\n    nonNullableAsync: 'nonNullableAsync',\n    nonNullishAsync: 'nonNullishAsync',\n    nonOptionalAsync: 'nonOptionalAsync',\n    nullableAsync: 'nullableAsync',\n    nullishAsync: 'nullishAsync',\n    objectAsync: 'objectAsync',\n    objectWithRestAsync: 'objectWithRestAsync',\n    optionalAsync: 'optionalAsync',\n    parseAsync: 'parseAsync',\n    parserAsync: 'parserAsync',\n    partialAsync: 'partialAsync',\n    partialCheckAsync: 'partialCheckAsync',\n    pipeAsync: 'pipeAsync',\n    rawCheckAsync: 'rawCheckAsync',\n    rawTransformAsync: 'rawTransformAsync',\n    recordAsync: 'recordAsync',\n    requiredAsync: 'requiredAsync',\n    returnsAsync: 'returnsAsync',\n    safeParseAsync: 'safeParseAsync',\n    safeParserAsync: 'safeParserAsync',\n    setAsync: 'setAsync',\n    strictObjectAsync: 'strictObjectAsync',\n    strictTupleAsync: 'strictTupleAsync',\n    transformAsync: 'transformAsync',\n    tupleAsync: 'tupleAsync',\n    tupleWithRestAsync: 'tupleWithRestAsync',\n    undefinedableAsync: 'undefinedableAsync',\n    unionAsync: 'unionAsync',\n    variantAsync: 'variantAsync',\n  },\n  /**\n   * {@link https://valibot.dev/api/#methods Methods}\n   */\n  methods: {\n    assert: 'assert',\n    config: 'config',\n    fallback: 'fallback',\n    flatten: 'flatten',\n    forward: 'forward',\n    getDefault: 'getDefault',\n    getDefaults: 'getDefaults',\n    getDescription: 'getDescription',\n    getFallback: 'getFallback',\n    getFallbacks: 'getFallbacks',\n    getMetadata: 'getMetadata',\n    getTitle: 'getTitle',\n    is: 'is',\n    keyof: 'keyof',\n    message: 'message',\n    omit: 'omit',\n    parse: 'parse',\n    parser: 'parser',\n    partial: 'partial',\n    pick: 'pick',\n    pipe: 'pipe',\n    required: 'required',\n    safeParse: 'safeParse',\n    safeParser: 'safeParser',\n    summarize: 'summarize',\n    unwrap: 'unwrap',\n  },\n  /**\n   * {@link https://valibot.dev/api/#schemas Schemas}\n   */\n  schemas: {\n    any: 'any',\n    array: 'array',\n    bigInt: 'bigint',\n    blob: 'blob',\n    boolean: 'boolean',\n    custom: 'custom',\n    date: 'date',\n    enum: 'enum',\n    exactOptional: 'exactOptional',\n    file: 'file',\n    function: 'function',\n    instance: 'instance',\n    intersect: 'intersect',\n    lazy: 'lazy',\n    literal: 'literal',\n    looseObject: 'looseObject',\n    looseTuple: 'looseTuple',\n    map: 'map',\n    nan: 'nan',\n    never: 'never',\n    nonNullable: 'nonNullable',\n    nonNullish: 'nonNullish',\n    nonOptional: 'nonOptional',\n    null: 'null',\n    nullable: 'nullable',\n    nullish: 'nullish',\n    number: 'number',\n    object: 'object',\n    objectWithRest: 'objectWithRest',\n    optional: 'optional',\n    picklist: 'picklist',\n    promise: 'promise',\n    record: 'record',\n    set: 'set',\n    strictObject: 'strictObject',\n    strictTuple: 'strictTuple',\n    string: 'string',\n    symbol: 'symbol',\n    tuple: 'tuple',\n    tupleWithRest: 'tupleWithRest',\n    undefined: 'undefined',\n    undefinedable: 'undefinedable',\n    union: 'union',\n    unknown: 'unknown',\n    variant: 'variant',\n    void: 'void',\n  },\n  /**\n   * {@link https://valibot.dev/api/#storages Storages}\n   */\n  storages: {\n    // TODO: implement if necessary\n  },\n  /**\n   * {@link https://valibot.dev/api/#types Types}\n   */\n  types: {\n    // TODO: implement if necessary\n    GenericSchema: 'GenericSchema',\n  },\n  /**\n   * {@link https://valibot.dev/api/#utils Utils}\n   */\n  utils: {\n    // TODO: implement if necessary\n  },\n};\n","import { $ } from '~/ts-dsl';\n\nimport type { ValibotPlugin } from '../types';\nimport { identifiers } from '../v1/constants';\n\nexport type Pipe = ReturnType<typeof $.call | typeof $.expr>;\nexport type Pipes = Array<Pipe>;\nexport type PipeResult = Pipes | Pipe;\n\ntype PushPipes = (target: Pipes, pipes: PipeResult) => Pipes;\ntype PipesToNode = (\n  pipes: PipeResult,\n  plugin: ValibotPlugin['Instance'],\n) => Pipe;\n\nexport const pipesToNode: PipesToNode = (pipes, plugin) => {\n  if (!(pipes instanceof Array)) return pipes;\n  if (pipes.length === 1) return pipes[0]!;\n\n  const v = plugin.external('valibot.v');\n  return $(v)\n    .attr(identifiers.methods.pipe)\n    .call(...pipes);\n};\n\nexport const pushPipes: PushPipes = (target, pipes) => {\n  if (pipes instanceof Array) {\n    target.push(...pipes);\n  } else {\n    target.push(pipes);\n  }\n  return target;\n};\n\nexport interface PipesUtils {\n  /**\n   * Push pipes into target array.\n   */\n  push: PushPipes;\n  /**\n   * Convert pipes to a single node.\n   */\n  toNode: PipesToNode;\n}\n\n/**\n * Functions for working with pipes.\n */\nexport const pipes: PipesUtils = {\n  push: pushPipes,\n  toNode: pipesToNode,\n};\n","import { $ } from '~/ts-dsl';\n\nimport { pipes } from '../shared/pipes';\nimport type { ValidatorArgs } from '../shared/types';\nimport type { ValidatorResolverContext } from '../types';\nimport { identifiers } from './constants';\n\nconst validatorResolver = (\n  ctx: ValidatorResolverContext,\n): ReturnType<typeof $.return> => {\n  const { schema, v } = ctx.symbols;\n  return $(v)\n    .attr(identifiers.async.parseAsync)\n    .call(schema, 'data')\n    .await()\n    .return();\n};\n\nexport const createRequestValidatorV1 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'valibot',\n  });\n  if (!symbol) return;\n\n  const ctx: ValidatorResolverContext = {\n    $,\n    operation,\n    pipes: {\n      ...pipes,\n      current: [],\n    },\n    plugin,\n    symbols: {\n      schema: symbol,\n      v: plugin.external('valibot.v'),\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.request;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n\nexport const createResponseValidatorV1 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'valibot',\n  });\n  if (!symbol) return;\n\n  const ctx: ValidatorResolverContext = {\n    $,\n    operation,\n    pipes: {\n      ...pipes,\n      current: [],\n    },\n    plugin,\n    symbols: {\n      schema: symbol,\n      v: plugin.external('valibot.v'),\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.response;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n","import type { $ } from '~/ts-dsl';\n\nimport type { ValidatorArgs } from './shared/types';\nimport { createRequestValidatorV1, createResponseValidatorV1 } from './v1/api';\n\nexport type IApi = {\n  createRequestValidator: (\n    args: ValidatorArgs,\n  ) => ReturnType<typeof $.func> | undefined;\n  createResponseValidator: (\n    args: ValidatorArgs,\n  ) => ReturnType<typeof $.func> | undefined;\n};\n\nexport class Api implements IApi {\n  createRequestValidator(\n    args: ValidatorArgs,\n  ): ReturnType<typeof $.func> | undefined {\n    return createRequestValidatorV1(args);\n  }\n\n  createResponseValidator(\n    args: ValidatorArgs,\n  ): ReturnType<typeof $.func> | undefined {\n    return createResponseValidatorV1(args);\n  }\n}\n","import { $ } from '~/ts-dsl';\n\nexport type MaybeBigInt = (\n  value: unknown,\n  format: string | undefined,\n) => ReturnType<typeof $.fromValue>;\nexport type ShouldCoerceToBigInt = (format: string | undefined) => boolean;\n\nexport const shouldCoerceToBigInt: ShouldCoerceToBigInt = (format) =>\n  format === 'int64' || format === 'uint64';\n\nexport const maybeBigInt: MaybeBigInt = (value, format) => {\n  if (!shouldCoerceToBigInt(format)) {\n    return $.fromValue(value);\n  }\n\n  if (typeof value === 'string') {\n    // handle invalid input\n    if (value.endsWith('n')) value = value.slice(0, -1);\n    return $('BigInt').call($.fromValue(value));\n  }\n\n  if (typeof value === 'number') {\n    return $('BigInt').call($.fromValue(value));\n  }\n\n  return $.fromValue(value);\n};\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../v1/constants';\nimport { pipesToNode } from './pipes';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const exportAst = ({\n  ast,\n  plugin,\n  schema,\n  state,\n  symbol,\n}: IrSchemaToAstOptions & {\n  ast: Ast;\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n}): void => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  const statement = $.const(symbol)\n    .export()\n    .$if(plugin.config.comments && createSchemaComment(schema), (c, v) =>\n      c.doc(v),\n    )\n    .$if(state.hasLazyExpression['~ref'], (c) =>\n      c.type($.type(v).attr(ast.typeName || identifiers.types.GenericSchema)),\n    )\n    .assign(pipesToNode(ast.pipes, plugin));\n  plugin.node(statement);\n};\n","import { fromRef } from '@hey-api/codegen-core';\n\nimport { operationResponsesMap } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { applyNaming } from '~/utils/naming';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irOperationToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (\n    schema: IR.SchemaObject,\n    path: ReadonlyArray<string | number>,\n  ) => Ast;\n  operation: IR.OperationObject;\n}) => {\n  if (plugin.config.requests.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, fromRef(state.path));\n    const symbol = plugin.symbol(\n      applyNaming(operation.id, plugin.config.requests),\n      {\n        meta: {\n          category: 'schema',\n          path: fromRef(state.path),\n          resource: 'operation',\n          resourceId: operation.id,\n          role: 'data',\n          tags: fromRef(state.tags),\n          tool: 'valibot',\n        },\n      },\n    );\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      state,\n      symbol,\n    });\n  }\n\n  if (plugin.config.responses.enabled) {\n    if (operation.responses) {\n      const { response } = operationResponsesMap(operation);\n\n      if (response) {\n        const path = [...fromRef(state.path), 'responses'];\n        const ast = getAst(response, path);\n        const symbol = plugin.symbol(\n          applyNaming(operation.id, plugin.config.responses),\n          {\n            meta: {\n              category: 'schema',\n              path,\n              resource: 'operation',\n              resourceId: operation.id,\n              role: 'responses',\n              tags: fromRef(state.tags),\n              tool: 'valibot',\n            },\n          },\n        );\n        exportAst({\n          ast,\n          plugin,\n          schema: response,\n          state,\n          symbol,\n        });\n      }\n    }\n  }\n};\n","import { fromRef } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { applyNaming } from '~/utils/naming';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irWebhookToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (\n    schema: IR.SchemaObject,\n    path: ReadonlyArray<string | number>,\n  ) => Ast;\n  operation: IR.OperationObject;\n}) => {\n  if (plugin.config.webhooks.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, fromRef(state.path));\n    const symbol = plugin.symbol(\n      applyNaming(operation.id, plugin.config.webhooks),\n      {\n        meta: {\n          category: 'schema',\n          path: fromRef(state.path),\n          resource: 'webhook',\n          resourceId: operation.id,\n          role: 'data',\n          tags: fromRef(state.tags),\n          tool: 'valibot',\n        },\n      },\n    );\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      state,\n      symbol,\n    });\n  }\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}) => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  const expression = $(v).attr(identifiers.schemas.unknown).call();\n  return expression;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { pipesToNode } from '../../shared/pipes';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Omit<Ast, 'typeName'> = {\n    pipes: [],\n  };\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n  const functionName = $(v).attr(identifiers.schemas.array);\n\n  if (!schema.items) {\n    const expression = functionName.call(\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }),\n    );\n    result.pipes.push(expression);\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return pipesToNode(itemAst.pipes, plugin);\n    });\n\n    if (itemExpressions.length === 1) {\n      const expression = functionName.call(...itemExpressions);\n      result.pipes.push(expression);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        // TODO: parser - handle intersection\n        // return tsc.typeArrayNode(\n        //   tsc.typeIntersectionNode({ types: itemExpressions }),\n        // );\n      }\n\n      // TODO: parser - handle union\n      // return tsc.typeArrayNode(tsc.typeUnionNode({ types: itemExpressions }));\n\n      const expression = functionName.call(\n        unknownToAst({\n          plugin,\n          schema: {\n            type: 'unknown',\n          },\n          state,\n        }),\n      );\n      result.pipes.push(expression);\n    }\n  }\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    const expression = $(v)\n      .attr(identifiers.actions.length)\n      .call($.fromValue(schema.minItems));\n    result.pipes.push(expression);\n  } else {\n    if (schema.minItems !== undefined) {\n      const expression = $(v)\n        .attr(identifiers.actions.minLength)\n        .call($.fromValue(schema.minItems));\n      result.pipes.push(expression);\n    }\n\n    if (schema.maxItems !== undefined) {\n      const expression = $(v)\n        .attr(identifiers.actions.maxLength)\n        .call($.fromValue(schema.maxItems));\n      result.pipes.push(expression);\n    }\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { pipesToNode } from '../../shared/pipes';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const booleanToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): ReturnType<typeof $.call | typeof $.expr> => {\n  const pipes: Array<ReturnType<typeof $.call>> = [];\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  if (typeof schema.const === 'boolean') {\n    pipes.push(\n      $(v).attr(identifiers.schemas.literal).call($.literal(schema.const)),\n    );\n    return pipesToNode(pipes, plugin);\n  }\n\n  pipes.push($(v).attr(identifiers.schemas.boolean).call());\n  return pipesToNode(pipes, plugin);\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { unknownToAst } from './unknown';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): ReturnType<typeof $.call> => {\n  const enumMembers: Array<ReturnType<typeof $.literal>> = [];\n\n  let isNullable = false;\n\n  for (const item of schema.items ?? []) {\n    // Zod supports only string enums\n    if (item.type === 'string' && typeof item.const === 'string') {\n      enumMembers.push($.literal(item.const));\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  if (!enumMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  let resultExpression = $(v)\n    .attr(identifiers.schemas.picklist)\n    .call($.array(...enumMembers));\n\n  if (isNullable) {\n    resultExpression = $(v)\n      .attr(identifiers.schemas.nullable)\n      .call(resultExpression);\n  }\n\n  return resultExpression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}) => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n  const expression = $(v).attr(identifiers.schemas.never).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}) => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n  const expression = $(v).attr(identifiers.schemas.null).call();\n  return expression;\n};\n","type Range = number | string;\n\ninterface IntegerLimit {\n  maxError: string;\n  maxValue: Range;\n  minError: string;\n  minValue: Range;\n}\n\nexport type GetIntegerLimit = (\n  format: string | undefined,\n) => IntegerLimit | undefined;\n\nconst rangeErrors = (format: string, range: [Range, Range]) => ({\n  maxError: `Invalid value: Expected ${format} to be <= ${range[1]}`,\n  minError: `Invalid value: Expected ${format} to be >= ${range[0]}`,\n});\n\nconst integerRange: Record<string, [Range, Range]> = {\n  int16: [-32768, 32767],\n  int32: [-2147483648, 2147483647],\n  int64: ['-9223372036854775808', '9223372036854775807'],\n  int8: [-128, 127],\n  uint16: [0, 65535],\n  uint32: [0, 4294967295],\n  uint64: ['0', '18446744073709551615'],\n  uint8: [0, 255],\n};\n\nexport const getIntegerLimit: GetIntegerLimit = (format) => {\n  if (!format) return;\n  const range = integerRange[format];\n  if (!range) return;\n  const errors = rangeErrors(format, range);\n  return { maxValue: range[1], minValue: range[0], ...errors };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport {\n  maybeBigInt,\n  shouldCoerceToBigInt,\n} from '~/plugins/shared/utils/coerce';\nimport { getIntegerLimit } from '~/plugins/shared/utils/formats';\nimport { $ } from '~/ts-dsl';\n\nimport type { Pipe, PipeResult, Pipes } from '../../shared/pipes';\nimport { pipes } from '../../shared/pipes';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport type { NumberResolverContext } from '../../types';\nimport { identifiers } from '../constants';\n\nfunction baseNode(ctx: NumberResolverContext): PipeResult {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (ctx.utils.shouldCoerceToBigInt(schema.format)) {\n    return [\n      $(v)\n        .attr(identifiers.schemas.union)\n        .call(\n          $.array(\n            $(v).attr(identifiers.schemas.number).call(),\n            $(v).attr(identifiers.schemas.string).call(),\n            $(v).attr(identifiers.schemas.bigInt).call(),\n          ),\n        ),\n      $(v)\n        .attr(identifiers.actions.transform)\n        .call($.func().param('x').do($('BigInt').call('x').return())),\n    ];\n  }\n  const pipes: Pipes = [];\n  pipes.push($(v).attr(identifiers.schemas.number).call());\n  if (schema.type === 'integer') {\n    pipes.push($(v).attr(identifiers.actions.integer).call());\n  }\n  return pipes;\n}\n\nfunction constNode(ctx: NumberResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (schema.const === undefined) return;\n  return $(v)\n    .attr(identifiers.schemas.literal)\n    .call(ctx.utils.maybeBigInt(schema.const, schema.format));\n}\n\nfunction maxNode(ctx: NumberResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (schema.exclusiveMaximum !== undefined) {\n    return $(v)\n      .attr(identifiers.actions.ltValue)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMaximum, schema.format));\n  }\n  if (schema.maximum !== undefined) {\n    return $(v)\n      .attr(identifiers.actions.maxValue)\n      .call(ctx.utils.maybeBigInt(schema.maximum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return $(v)\n      .attr(identifiers.actions.maxValue)\n      .call(\n        ctx.utils.maybeBigInt(limit.maxValue, schema.format),\n        $.literal(limit.maxError),\n      );\n  }\n  return;\n}\n\nfunction minNode(ctx: NumberResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (schema.exclusiveMinimum !== undefined) {\n    return $(v)\n      .attr(identifiers.actions.gtValue)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMinimum, schema.format));\n  }\n  if (schema.minimum !== undefined) {\n    return $(v)\n      .attr(identifiers.actions.minValue)\n      .call(ctx.utils.maybeBigInt(schema.minimum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return $(v)\n      .attr(identifiers.actions.minValue)\n      .call(\n        ctx.utils.maybeBigInt(limit.minValue, schema.format),\n        $.literal(limit.minError),\n      );\n  }\n  return;\n}\n\nfunction numberResolver(ctx: NumberResolverContext): Pipes {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) return ctx.pipes.push(ctx.pipes.current, constNode);\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.pipes.push(ctx.pipes.current, baseNode);\n\n  const minNode = ctx.nodes.min(ctx);\n  if (minNode) ctx.pipes.push(ctx.pipes.current, minNode);\n\n  const maxNode = ctx.nodes.max(ctx);\n  if (maxNode) ctx.pipes.push(ctx.pipes.current, maxNode);\n\n  return ctx.pipes.current;\n}\n\nexport const numberToNode = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): Pipe => {\n  const ctx: NumberResolverContext = {\n    $,\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      max: maxNode,\n      min: minNode,\n    },\n    pipes: {\n      ...pipes,\n      current: [],\n    },\n    plugin,\n    schema,\n    symbols: {\n      v: plugin.external('valibot.v'),\n    },\n    utils: {\n      getIntegerLimit,\n      maybeBigInt,\n      shouldCoerceToBigInt,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.number;\n  const node = resolver?.(ctx) ?? numberResolver(ctx);\n  return ctx.pipes.toNode(node, plugin);\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { Pipe, PipeResult } from '../../shared/pipes';\nimport { pipes } from '../../shared/pipes';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { ObjectResolverContext } from '../../types';\nimport { identifiers } from '../constants';\nimport { irSchemaToAst } from '../plugin';\n\nfunction additionalPropertiesNode(\n  ctx: ObjectResolverContext,\n): Pipe | null | undefined {\n  const { plugin, schema } = ctx;\n\n  if (!schema.additionalProperties || !schema.additionalProperties.type) return;\n  if (schema.additionalProperties.type === 'never') return null;\n\n  const additionalAst = irSchemaToAst({\n    plugin,\n    schema: schema.additionalProperties,\n    state: {\n      ...ctx.utils.state,\n      path: ref([...fromRef(ctx.utils.state.path), 'additionalProperties']),\n    },\n  });\n  if (additionalAst.hasLazyExpression) ctx.utils.ast.hasLazyExpression = true;\n  return pipes.toNode(additionalAst.pipes, plugin);\n}\n\nfunction baseNode(ctx: ObjectResolverContext): PipeResult {\n  const { nodes, symbols } = ctx;\n  const { v } = symbols;\n\n  const additional = nodes.additionalProperties(ctx);\n  const shape = nodes.shape(ctx);\n\n  if (additional === null) {\n    return $(v).attr(identifiers.schemas.strictObject).call(shape);\n  }\n\n  if (additional) {\n    if (shape.isEmpty) {\n      return $(v)\n        .attr(identifiers.schemas.record)\n        .call($(v).attr(identifiers.schemas.string).call(), additional);\n    }\n\n    return $(v)\n      .attr(identifiers.schemas.objectWithRest)\n      .call(shape, additional);\n  }\n\n  return $(v).attr(identifiers.schemas.object).call(shape);\n}\n\nfunction objectResolver(ctx: ObjectResolverContext): PipeResult {\n  // TODO: parser - handle constants\n  return ctx.nodes.base(ctx);\n}\n\nfunction shapeNode(ctx: ObjectResolverContext): ReturnType<typeof $.object> {\n  const { plugin, schema } = ctx;\n  const shape = $.object().pretty();\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n\n    const propertyAst = irSchemaToAst({\n      optional: !schema.required?.includes(name),\n      plugin,\n      schema: property,\n      state: {\n        ...ctx.utils.state,\n        path: ref([...fromRef(ctx.utils.state.path), 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) ctx.utils.ast.hasLazyExpression = true;\n    shape.prop(name, pipes.toNode(propertyAst.pipes, plugin));\n  }\n\n  return shape;\n}\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const ctx: ObjectResolverContext = {\n    $,\n    nodes: {\n      additionalProperties: additionalPropertiesNode,\n      base: baseNode,\n      shape: shapeNode,\n    },\n    pipes: {\n      ...pipes,\n      current: [],\n    },\n    plugin,\n    schema,\n    symbols: {\n      v: plugin.external('valibot.v'),\n    },\n    utils: {\n      ast: {},\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.object;\n  const node = resolver?.(ctx) ?? objectResolver(ctx);\n  ctx.utils.ast.pipes = [ctx.pipes.toNode(node, plugin)];\n  return ctx.utils.ast as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { Pipe, PipeResult, Pipes } from '../../shared/pipes';\nimport { pipes } from '../../shared/pipes';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport type { StringResolverContext } from '../../types';\nimport { identifiers } from '../constants';\n\nfunction baseNode(ctx: StringResolverContext): PipeResult {\n  const { v } = ctx.symbols;\n  return $(v).attr(identifiers.schemas.string).call();\n}\n\nfunction constNode(ctx: StringResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (typeof schema.const !== 'string') return;\n  return $(v).attr(identifiers.schemas.literal).call($.literal(schema.const));\n}\n\nfunction formatNode(ctx: StringResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  switch (schema.format) {\n    case 'date':\n      return $(v).attr(identifiers.actions.isoDate).call();\n    case 'date-time':\n      return $(v).attr(identifiers.actions.isoTimestamp).call();\n    case 'email':\n      return $(v).attr(identifiers.actions.email).call();\n    case 'ipv4':\n    case 'ipv6':\n      return $(v).attr(identifiers.actions.ip).call();\n    case 'time':\n      return $(v).attr(identifiers.actions.isoTimeSecond).call();\n    case 'uri':\n      return $(v).attr(identifiers.actions.url).call();\n    case 'uuid':\n      return $(v).attr(identifiers.actions.uuid).call();\n  }\n\n  return;\n}\n\nfunction lengthNode(ctx: StringResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (schema.minLength === undefined || schema.minLength !== schema.maxLength)\n    return;\n  return $(v)\n    .attr(identifiers.actions.length)\n    .call($.literal(schema.minLength));\n}\n\nfunction maxLengthNode(ctx: StringResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (schema.maxLength === undefined) return;\n  return $(v)\n    .attr(identifiers.actions.maxLength)\n    .call($.literal(schema.maxLength));\n}\n\nfunction minLengthNode(ctx: StringResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (schema.minLength === undefined) return;\n  return $(v)\n    .attr(identifiers.actions.minLength)\n    .call($.literal(schema.minLength));\n}\n\nfunction patternNode(ctx: StringResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (!schema.pattern) return;\n  return $(v).attr(identifiers.actions.regex).call($.regexp(schema.pattern));\n}\n\nfunction stringResolver(ctx: StringResolverContext): Pipes {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) return ctx.pipes.push(ctx.pipes.current, constNode);\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.pipes.push(ctx.pipes.current, baseNode);\n\n  const formatNode = ctx.nodes.format(ctx);\n  if (formatNode) ctx.pipes.push(ctx.pipes.current, formatNode);\n\n  const lengthNode = ctx.nodes.length(ctx);\n  if (lengthNode) {\n    ctx.pipes.push(ctx.pipes.current, lengthNode);\n  } else {\n    const minLengthNode = ctx.nodes.minLength(ctx);\n    if (minLengthNode) ctx.pipes.push(ctx.pipes.current, minLengthNode);\n\n    const maxLengthNode = ctx.nodes.maxLength(ctx);\n    if (maxLengthNode) ctx.pipes.push(ctx.pipes.current, maxLengthNode);\n  }\n\n  const patternNode = ctx.nodes.pattern(ctx);\n  if (patternNode) ctx.pipes.push(ctx.pipes.current, patternNode);\n\n  return ctx.pipes.current;\n}\n\nexport const stringToNode = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Pipe => {\n  const ctx: StringResolverContext = {\n    $,\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      format: formatNode,\n      length: lengthNode,\n      maxLength: maxLengthNode,\n      minLength: minLengthNode,\n      pattern: patternNode,\n    },\n    pipes: {\n      ...pipes,\n      current: [],\n    },\n    plugin,\n    schema,\n    symbols: {\n      v: plugin.external('valibot.v'),\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.string;\n  const node = resolver?.(ctx) ?? stringResolver(ctx);\n  return ctx.pipes.toNode(node, plugin);\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { pipesToNode } from '../../shared/pipes';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      $(v).attr(identifiers.schemas.literal).call($.fromValue(value)),\n    );\n    result.pipes = [\n      $(v)\n        .attr(identifiers.schemas.tuple)\n        .call($.array(...tupleElements)),\n    ];\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  if (schema.items) {\n    const tupleElements = schema.items.map((item, index) => {\n      const schemaPipes = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      if (schemaPipes.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return pipesToNode(schemaPipes.pipes, plugin);\n    });\n    result.pipes = [\n      $(v)\n        .attr(identifiers.schemas.tuple)\n        .call($.array(...tupleElements)),\n    ];\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  return {\n    pipes: [\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }),\n    ],\n  };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}) => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  const expression = $(v).attr(identifiers.schemas.undefined).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}) => {\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  const expression = $(v).attr(identifiers.schemas.void).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { shouldCoerceToBigInt } from '~/plugins/shared/utils/coerce';\nimport type { $ } from '~/ts-dsl';\n\nimport { pipesToNode } from '../../shared/pipes';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToNode } from './number';\nimport { objectToAst } from './object';\nimport { stringToNode } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): {\n  anyType?: string;\n  expression: ReturnType<typeof $.call | typeof $.expr>;\n} => {\n  switch (schema.type) {\n    case 'array':\n      return {\n        expression: pipesToNode(\n          arrayToAst({\n            ...args,\n            schema: schema as SchemaWithType<'array'>,\n          }).pipes,\n          args.plugin,\n        ),\n      };\n    case 'boolean':\n      return {\n        expression: booleanToAst({\n          ...args,\n          schema: schema as SchemaWithType<'boolean'>,\n        }),\n      };\n    case 'enum':\n      return {\n        expression: enumToAst({\n          ...args,\n          schema: schema as SchemaWithType<'enum'>,\n        }),\n      };\n    case 'integer':\n    case 'number':\n      return {\n        expression: numberToNode({\n          ...args,\n          schema: schema as SchemaWithType<'integer' | 'number'>,\n        }),\n      };\n    case 'never':\n      return {\n        expression: neverToAst({\n          ...args,\n          schema: schema as SchemaWithType<'never'>,\n        }),\n      };\n    case 'null':\n      return {\n        expression: nullToAst({\n          ...args,\n          schema: schema as SchemaWithType<'null'>,\n        }),\n      };\n    case 'object':\n      return {\n        expression: pipesToNode(\n          objectToAst({\n            ...args,\n            schema: schema as SchemaWithType<'object'>,\n          }).pipes,\n          args.plugin,\n        ),\n      };\n    case 'string':\n      return {\n        expression: shouldCoerceToBigInt(schema.format)\n          ? numberToNode({\n              ...args,\n              schema: { ...schema, type: 'number' },\n            })\n          : stringToNode({\n              ...args,\n              schema: schema as SchemaWithType<'string'>,\n            }),\n      };\n    case 'tuple':\n      return {\n        expression: pipesToNode(\n          tupleToAst({\n            ...args,\n            schema: schema as SchemaWithType<'tuple'>,\n          }).pipes,\n          args.plugin,\n        ),\n      };\n    case 'undefined':\n      return {\n        expression: undefinedToAst({\n          ...args,\n          schema: schema as SchemaWithType<'undefined'>,\n        }),\n      };\n    case 'unknown':\n      return {\n        expression: unknownToAst({\n          ...args,\n          schema: schema as SchemaWithType<'unknown'>,\n        }),\n      };\n    case 'void':\n      return {\n        expression: voidToAst({\n          ...args,\n          schema: schema as SchemaWithType<'void'>,\n        }),\n      };\n  }\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport { fromRef, ref, refs } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport type { SchemaWithType } from '~/plugins';\nimport { maybeBigInt } from '~/plugins/shared/utils/coerce';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { exportAst } from '../shared/export';\nimport { irOperationToAst } from '../shared/operation';\nimport { pipesToNode } from '../shared/pipes';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ValibotPlugin } from '../types';\nimport { identifiers } from './constants';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  const ast: Ast = {\n    pipes: [],\n  };\n\n  const v = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'valibot.v',\n  });\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'valibot',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      const ref = $(refSymbol);\n      ast.pipes.push(ref);\n    } else {\n      const lazyExpression = $(v)\n        .attr(identifiers.schemas.lazy)\n        .call($.func().do($(refSymbol).return()));\n      ast.pipes.push(lazyExpression);\n      state.hasLazyExpression['~ref'] = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.typeName = typeAst.anyType;\n    ast.pipes.push(typeAst.expression);\n\n    if (plugin.config.metadata && schema.description) {\n      const expression = $(v)\n        .attr(identifiers.actions.metadata)\n        .call($.object().prop('description', $.literal(schema.description)));\n      ast.pipes.push(expression);\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemsAst = schema.items.map((item, index) => {\n        const itemAst = irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: ref([...fromRef(state.path), 'items', index]),\n          },\n        });\n        return pipesToNode(itemAst.pipes, plugin);\n      });\n\n      if (schema.logicalOperator === 'and') {\n        const intersectExpression = $(v)\n          .attr(identifiers.schemas.intersect)\n          .call($.array(...itemsAst));\n        ast.pipes.push(intersectExpression);\n      } else {\n        const unionExpression = $(v)\n          .attr(identifiers.schemas.union)\n          .call($.array(...itemsAst));\n        ast.pipes.push(unionExpression);\n      }\n    } else {\n      const schemaPipes = irSchemaToAst({ plugin, schema, state });\n      ast.pipes.push(...schemaPipes.pipes);\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.typeName = typeAst.anyType;\n    ast.pipes.push(typeAst.expression);\n  }\n\n  if (ast.pipes.length) {\n    if (schema.accessScope === 'read') {\n      const readonlyExpression = $(v).attr(identifiers.actions.readonly).call();\n      ast.pipes.push(readonlyExpression);\n    }\n\n    if (schema.default !== undefined) {\n      ast.pipes = [\n        $(v)\n          .attr(identifiers.schemas.optional)\n          .call(\n            pipesToNode(ast.pipes, plugin),\n            schema.type === 'integer' || schema.type === 'number'\n              ? maybeBigInt(schema.default, schema.format)\n              : $.fromValue(schema.default),\n          ),\n      ];\n    } else if (optional) {\n      ast.pipes = [\n        $(v)\n          .attr(identifiers.schemas.optional)\n          .call(pipesToNode(ast.pipes, plugin)),\n      ];\n    }\n  }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(fromRef(state.path));\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.symbol(\n    applyNaming(baseName, plugin.config.definitions),\n    {\n      meta: {\n        category: 'schema',\n        path: fromRef(state.path),\n        resource: 'definition',\n        resourceId: $ref,\n        tags: fromRef(state.tags),\n        tool: 'valibot',\n      },\n    },\n  );\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    state,\n    symbol,\n  });\n};\n\nexport const handlerV1: ValibotPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('v', {\n    external: 'valibot',\n    importKind: 'namespace',\n    meta: {\n      category: 'external',\n      resource: 'valibot.v',\n    },\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = refs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          irOperationToAst({\n            getAst: (schema, path) => {\n              const state = refs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'webhook':\n          irWebhookToAst({\n            getAst: (schema, path) => {\n              const state = refs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n      }\n    },\n  );\n};\n","import type { ValibotPlugin } from './types';\nimport { handlerV1 } from './v1/plugin';\n\nexport const handler: ValibotPlugin['Handler'] = (args) => handlerV1(args);\n","import { definePluginConfig } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { ValibotPlugin } from './types';\n\nexport const defaultConfig: ValibotPlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n    metadata: false,\n  },\n  handler,\n  name: 'valibot',\n  resolveConfig: (plugin, context) => {\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}Data',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}Response',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}WebhookRequest',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n  tags: ['validator'],\n};\n\n/**\n * Type helper for Valibot plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","// TODO: this is inaccurate, it combines identifiers for all supported versions\nexport const identifiers = {\n  ZodMiniOptional: 'ZodMiniOptional',\n  ZodOptional: 'ZodOptional',\n  _default: '_default',\n  and: 'and',\n  array: 'array',\n  bigint: 'bigint',\n  boolean: 'boolean',\n  check: 'check',\n  coerce: 'coerce',\n  date: 'date',\n  datetime: 'datetime',\n  default: 'default',\n  describe: 'describe',\n  email: 'email',\n  enum: 'enum',\n  globalRegistry: 'globalRegistry',\n  gt: 'gt',\n  gte: 'gte',\n  infer: 'infer',\n  int: 'int',\n  intersection: 'intersection',\n  ip: 'ip',\n  ipv4: 'ipv4',\n  ipv6: 'ipv6',\n  iso: 'iso',\n  lazy: 'lazy',\n  length: 'length',\n  literal: 'literal',\n  lt: 'lt',\n  lte: 'lte',\n  max: 'max',\n  maxLength: 'maxLength',\n  maximum: 'maximum', // Zod Mini\n  min: 'min',\n  minLength: 'minLength',\n  minimum: 'minimum', // Zod Mini\n  never: 'never',\n  null: 'null',\n  nullable: 'nullable',\n  number: 'number',\n  object: 'object',\n  optional: 'optional',\n  parseAsync: 'parseAsync',\n  readonly: 'readonly',\n  record: 'record',\n  regex: 'regex',\n  register: 'register',\n  string: 'string',\n  time: 'time',\n  tuple: 'tuple',\n  undefined: 'undefined',\n  union: 'union',\n  unknown: 'unknown',\n  url: 'url',\n  uuid: 'uuid',\n  void: 'void',\n};\n","import { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../constants';\nimport type { ValidatorArgs } from '../shared/types';\nimport type { ValidatorResolverContext } from '../types';\n\nconst validatorResolver = (\n  ctx: ValidatorResolverContext,\n): ReturnType<typeof $.return> => {\n  const { schema } = ctx.symbols;\n  return $(schema).attr(identifiers.parseAsync).call('data').await().return();\n};\n\nexport const createRequestValidatorMini = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const z = plugin.external('zod.z');\n  const ctx: ValidatorResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    operation,\n    plugin,\n    symbols: {\n      schema: symbol,\n      z,\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.request;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n\nexport const createResponseValidatorMini = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const z = plugin.external('zod.z');\n  const ctx: ValidatorResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    operation,\n    plugin,\n    symbols: {\n      schema: symbol,\n      z,\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.response;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n","import { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../constants';\nimport type { ValidatorArgs } from '../shared/types';\nimport type { ValidatorResolverContext } from '../types';\n\nconst validatorResolver = (\n  ctx: ValidatorResolverContext,\n): ReturnType<typeof $.return> => {\n  const { schema } = ctx.symbols;\n  return $(schema).attr(identifiers.parseAsync).call('data').await().return();\n};\n\nexport const createRequestValidatorV3 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const z = plugin.external('zod.z');\n  const ctx: ValidatorResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    operation,\n    plugin,\n    symbols: {\n      schema: symbol,\n      z,\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.request;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n\nexport const createResponseValidatorV3 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const z = plugin.external('zod.z');\n  const ctx: ValidatorResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    operation,\n    plugin,\n    symbols: {\n      schema: symbol,\n      z,\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.response;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n","import { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../constants';\nimport type { ValidatorArgs } from '../shared/types';\nimport type { ValidatorResolverContext } from '../types';\n\nconst validatorResolver = (\n  ctx: ValidatorResolverContext,\n): ReturnType<typeof $.return> => {\n  const { schema } = ctx.symbols;\n  return $(schema).attr(identifiers.parseAsync).call('data').await().return();\n};\n\nexport const createRequestValidatorV4 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const z = plugin.external('zod.z');\n  const ctx: ValidatorResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    operation,\n    plugin,\n    symbols: {\n      schema: symbol,\n      z,\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.request;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n\nexport const createResponseValidatorV4 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const z = plugin.external('zod.z');\n  const ctx: ValidatorResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    operation,\n    plugin,\n    symbols: {\n      schema: symbol,\n      z,\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver =\n    typeof validator === 'function' ? validator : validator?.response;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n","import type { $ } from '~/ts-dsl';\n\nimport {\n  createRequestValidatorMini,\n  createResponseValidatorMini,\n} from './mini/api';\nimport type { ValidatorArgs } from './shared/types';\nimport { createRequestValidatorV3, createResponseValidatorV3 } from './v3/api';\nimport { createRequestValidatorV4, createResponseValidatorV4 } from './v4/api';\n\nexport type IApi = {\n  createRequestValidator: (\n    args: ValidatorArgs,\n  ) => ReturnType<typeof $.func> | undefined;\n  createResponseValidator: (\n    args: ValidatorArgs,\n  ) => ReturnType<typeof $.func> | undefined;\n};\n\nexport class Api implements IApi {\n  createRequestValidator(\n    args: ValidatorArgs,\n  ): ReturnType<typeof $.func> | undefined {\n    const { plugin } = args;\n    switch (plugin.config.compatibilityVersion) {\n      case 3:\n        return createRequestValidatorV3(args);\n      case 'mini':\n        return createRequestValidatorMini(args);\n      case 4:\n      default:\n        return createRequestValidatorV4(args);\n    }\n  }\n\n  createResponseValidator(\n    args: ValidatorArgs,\n  ): ReturnType<typeof $.func> | undefined {\n    const { plugin } = args;\n    switch (plugin.config.compatibilityVersion) {\n      case 3:\n        return createResponseValidatorV3(args);\n      case 'mini':\n        return createResponseValidatorMini(args);\n      case 4:\n      default:\n        return createResponseValidatorV4(args);\n    }\n  }\n}\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { createSchemaComment } from '~/plugins/shared/utils/schema';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../constants';\nimport type { ZodPlugin } from '../types';\nimport type { Ast } from './types';\n\nexport const exportAst = ({\n  ast,\n  plugin,\n  schema,\n  symbol,\n  typeInferSymbol,\n}: {\n  ast: Ast;\n  plugin: ZodPlugin['Instance'];\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n  typeInferSymbol: Symbol | undefined;\n}): void => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const statement = $.const(symbol)\n    .export()\n    .$if(plugin.config.comments && createSchemaComment(schema), (c, v) =>\n      c.doc(v),\n    )\n    .$if(ast.typeName, (c, v) => c.type($.type(z).attr(v)))\n    .assign(ast.expression);\n  plugin.node(statement);\n\n  if (typeInferSymbol) {\n    const inferType = $.type\n      .alias(typeInferSymbol)\n      .export()\n      .type($.type(z).attr(identifiers.infer).generic($(symbol).typeofType()));\n    plugin.node(inferType);\n  }\n};\n","import type { ZodPlugin } from '../types';\n\nexport const getZodModule = ({\n  plugin,\n}: {\n  plugin: ZodPlugin['Instance'];\n}): string => {\n  const version = plugin.package.getVersion('zod');\n\n  if (version) {\n    if (plugin.package.satisfies(version, '<4.0.0')) {\n      switch (plugin.config.compatibilityVersion) {\n        case 3:\n        default:\n          return 'zod';\n        case 4:\n          return 'zod/v4';\n        case 'mini':\n          return 'zod/v4-mini';\n      }\n    }\n  }\n\n  switch (plugin.config.compatibilityVersion) {\n    case 3:\n      return 'zod/v3';\n    case 4:\n    default:\n      return 'zod';\n    case 'mini':\n      return 'zod/mini';\n  }\n};\n","import { fromRef } from '@hey-api/codegen-core';\n\nimport { operationResponsesMap } from '~/ir/operation';\nimport type { IR } from '~/ir/types';\nimport { applyNaming } from '~/utils/naming';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irOperationToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (\n    schema: IR.SchemaObject,\n    path: ReadonlyArray<string | number>,\n  ) => Ast;\n  operation: IR.OperationObject;\n}): void => {\n  if (plugin.config.requests.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, fromRef(state.path));\n    const symbol = plugin.symbol(\n      applyNaming(operation.id, plugin.config.requests),\n      {\n        meta: {\n          category: 'schema',\n          path: fromRef(state.path),\n          resource: 'operation',\n          resourceId: operation.id,\n          role: 'data',\n          tags: fromRef(state.tags),\n          tool: 'zod',\n        },\n      },\n    );\n    const typeInferSymbol = plugin.config.requests.types.infer.enabled\n      ? plugin.symbol(\n          applyNaming(operation.id, plugin.config.requests.types.infer),\n          {\n            meta: {\n              category: 'type',\n              path: fromRef(state.path),\n              resource: 'operation',\n              resourceId: operation.id,\n              role: 'data',\n              tags: fromRef(state.tags),\n              tool: 'zod',\n              variant: 'infer',\n            },\n          },\n        )\n      : undefined;\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      symbol,\n      typeInferSymbol,\n    });\n  }\n\n  if (plugin.config.responses.enabled) {\n    if (operation.responses) {\n      const { response } = operationResponsesMap(operation);\n\n      if (response) {\n        const path = [...fromRef(state.path), 'responses'];\n        const ast = getAst(response, path);\n        const symbol = plugin.symbol(\n          applyNaming(operation.id, plugin.config.responses),\n          {\n            meta: {\n              category: 'schema',\n              path,\n              resource: 'operation',\n              resourceId: operation.id,\n              role: 'responses',\n              tags: fromRef(state.tags),\n              tool: 'zod',\n            },\n          },\n        );\n        const typeInferSymbol = plugin.config.responses.types.infer.enabled\n          ? plugin.symbol(\n              applyNaming(operation.id, plugin.config.responses.types.infer),\n              {\n                meta: {\n                  category: 'type',\n                  path,\n                  resource: 'operation',\n                  resourceId: operation.id,\n                  role: 'responses',\n                  tags: fromRef(state.tags),\n                  tool: 'zod',\n                  variant: 'infer',\n                },\n              },\n            )\n          : undefined;\n        exportAst({\n          ast,\n          plugin,\n          schema: response,\n          symbol,\n          typeInferSymbol,\n        });\n      }\n    }\n  }\n};\n","import { fromRef } from '@hey-api/codegen-core';\n\nimport type { IR } from '~/ir/types';\nimport { applyNaming } from '~/utils/naming';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irWebhookToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (\n    schema: IR.SchemaObject,\n    path: ReadonlyArray<string | number>,\n  ) => Ast;\n  operation: IR.OperationObject;\n}) => {\n  if (plugin.config.webhooks.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, fromRef(state.path));\n    const symbol = plugin.symbol(\n      applyNaming(operation.id, plugin.config.webhooks),\n      {\n        meta: {\n          category: 'schema',\n          path: fromRef(state.path),\n          resource: 'webhook',\n          resourceId: operation.id,\n          role: 'data',\n          tags: fromRef(state.tags),\n          tool: 'zod',\n        },\n      },\n    );\n    const typeInferSymbol = plugin.config.webhooks.types.infer.enabled\n      ? plugin.symbol(\n          applyNaming(operation.id, plugin.config.webhooks.types.infer),\n          {\n            meta: {\n              category: 'type',\n              path: fromRef(state.path),\n              resource: 'webhook',\n              resourceId: operation.id,\n              role: 'data',\n              tags: fromRef(state.tags),\n              tool: 'zod',\n              variant: 'infer',\n            },\n          },\n        )\n      : undefined;\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      symbol,\n      typeInferSymbol,\n    });\n  }\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z).attr(identifiers.unknown).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const functionName = $(z).attr(identifiers.array);\n\n  if (!schema.items) {\n    result.expression = functionName.call(\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }).expression,\n    );\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return itemAst.expression;\n    });\n\n    if (itemExpressions.length === 1) {\n      result.expression = functionName.call(...itemExpressions);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items![0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.intersection()` as that does not exist on `.union()` and non-object schemas.\n        let intersectionExpression: ReturnType<typeof $.expr | typeof $.call>;\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          intersectionExpression = $(z)\n            .attr(identifiers.intersection)\n            .call(...itemExpressions);\n        } else {\n          intersectionExpression = itemExpressions[0]!;\n          for (let i = 1; i < itemExpressions.length; i++) {\n            intersectionExpression = $(z)\n              .attr(identifiers.intersection)\n              .call(intersectionExpression, itemExpressions[i]);\n          }\n        }\n\n        result.expression = functionName.call(intersectionExpression);\n      } else {\n        result.expression = $(z)\n          .attr(identifiers.array)\n          .call(\n            $(z)\n              .attr(identifiers.union)\n              .call($.array(...itemExpressions)),\n          );\n      }\n    }\n  }\n\n  const checks: Array<ReturnType<typeof $.call>> = [];\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    checks.push(\n      $(z).attr(identifiers.length).call($.fromValue(schema.minItems)),\n    );\n  } else {\n    if (schema.minItems !== undefined) {\n      checks.push(\n        $(z).attr(identifiers.minLength).call($.fromValue(schema.minItems)),\n      );\n    }\n\n    if (schema.maxItems !== undefined) {\n      checks.push(\n        $(z).attr(identifiers.maxLength).call($.fromValue(schema.maxItems)),\n      );\n    }\n  }\n\n  if (checks.length > 0) {\n    result.expression = result.expression\n      .attr(identifiers.check)\n      .call(...checks);\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const booleanToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  let chain: ReturnType<typeof $.call>;\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (typeof schema.const === 'boolean') {\n    chain = $(z).attr(identifiers.literal).call($.literal(schema.const));\n    result.expression = chain;\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  chain = $(z).attr(identifiers.boolean).call();\n  result.expression = chain;\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { unknownToAst } from './unknown';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const enumMembers: Array<ReturnType<typeof $.literal>> = [];\n  const literalMembers: Array<ReturnType<typeof $.call>> = [];\n\n  let isNullable = false;\n  let allStrings = true;\n\n  for (const item of schema.items ?? []) {\n    // Zod supports string, number, and boolean enums\n    if (item.type === 'string' && typeof item.const === 'string') {\n      const literal = $.literal(item.const);\n      enumMembers.push(literal);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (\n      (item.type === 'number' || item.type === 'integer') &&\n      typeof item.const === 'number'\n    ) {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (item.type === 'boolean' && typeof item.const === 'boolean') {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  if (!literalMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  // Use z.enum() for pure string enums, z.union() for mixed or non-string types\n  if (allStrings && enumMembers.length > 0) {\n    result.expression = $(z)\n      .attr(identifiers.enum)\n      .call($.array(...enumMembers));\n  } else if (literalMembers.length === 1) {\n    // For single-member unions, use the member directly instead of wrapping in z.union()\n    result.expression = literalMembers[0]!;\n  } else {\n    result.expression = $(z)\n      .attr(identifiers.union)\n      .call($.array(...literalMembers));\n  }\n\n  if (isNullable) {\n    result.expression = $(z).attr(identifiers.nullable).call(result.expression);\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z).attr(identifiers.never).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z).attr(identifiers.null).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport {\n  maybeBigInt,\n  shouldCoerceToBigInt,\n} from '~/plugins/shared/utils/coerce';\nimport { getIntegerLimit } from '~/plugins/shared/utils/formats';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { NumberResolverContext } from '../../types';\n\nfunction baseNode(ctx: NumberResolverContext): Chain {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (ctx.utils.shouldCoerceToBigInt(schema.format)) {\n    return $(z).attr(identifiers.coerce).attr(identifiers.bigint).call();\n  }\n  let chain = $(z).attr(identifiers.number).call();\n  if (schema.type === 'integer') {\n    chain = $(z).attr(identifiers.int).call();\n  }\n  return chain;\n}\n\nfunction constNode(ctx: NumberResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.const === undefined) return;\n  return $(z)\n    .attr(identifiers.literal)\n    .call(ctx.utils.maybeBigInt(schema.const, schema.format));\n}\n\nfunction maxNode(ctx: NumberResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.exclusiveMaximum !== undefined) {\n    return $(z)\n      .attr(identifiers.lt)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMaximum, schema.format));\n  }\n  if (schema.maximum !== undefined) {\n    return $(z)\n      .attr(identifiers.lte)\n      .call(ctx.utils.maybeBigInt(schema.maximum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return $(z)\n      .attr(identifiers.maximum)\n      .call(\n        ctx.utils.maybeBigInt(limit.maxValue, schema.format),\n        $.object().prop('error', $.literal(limit.maxError)),\n      );\n  }\n  return;\n}\n\nfunction minNode(ctx: NumberResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.exclusiveMinimum !== undefined) {\n    return $(z)\n      .attr(identifiers.gt)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMinimum, schema.format));\n  }\n  if (schema.minimum !== undefined) {\n    return $(z)\n      .attr(identifiers.gte)\n      .call(ctx.utils.maybeBigInt(schema.minimum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return $(z)\n      .attr(identifiers.minimum)\n      .call(\n        ctx.utils.maybeBigInt(limit.minValue, schema.format),\n        $.object().prop('error', $.literal(limit.minError)),\n      );\n  }\n  return;\n}\n\nfunction numberResolver(ctx: NumberResolverContext): Chain {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) {\n    ctx.chain.current = constNode;\n    return ctx.chain.current;\n  }\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.chain.current = baseNode;\n\n  const checks: Array<Chain> = [];\n\n  const minNode = ctx.nodes.min(ctx);\n  if (minNode) checks.push(minNode);\n\n  const maxNode = ctx.nodes.max(ctx);\n  if (maxNode) checks.push(maxNode);\n\n  if (checks.length > 0) {\n    ctx.chain.current = ctx.chain.current\n      .attr(identifiers.check)\n      .call(...checks);\n  }\n\n  return ctx.chain.current;\n}\n\nexport const numberToNode = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): Omit<Ast, 'typeName'> => {\n  const ast: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  const ctx: NumberResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      max: maxNode,\n      min: minNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast,\n      getIntegerLimit,\n      maybeBigInt,\n      shouldCoerceToBigInt,\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.number;\n  const node = resolver?.(ctx) ?? numberResolver(ctx);\n  ast.expression = node;\n  return ast as Omit<Ast, 'typeName'>;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { ObjectResolverContext } from '../../types';\nimport { irSchemaToAst } from '../plugin';\n\nfunction additionalPropertiesNode(\n  ctx: ObjectResolverContext,\n): Chain | null | undefined {\n  const { plugin, schema } = ctx;\n\n  if (\n    !schema.additionalProperties ||\n    (schema.properties && Object.keys(schema.properties).length > 0)\n  )\n    return;\n\n  const additionalAst = irSchemaToAst({\n    plugin,\n    schema: schema.additionalProperties,\n    state: {\n      ...ctx.utils.state,\n      path: ref([...fromRef(ctx.utils.state.path), 'additionalProperties']),\n    },\n  });\n  if (additionalAst.hasLazyExpression) ctx.utils.ast.hasLazyExpression = true;\n  return additionalAst.expression;\n}\n\nfunction baseNode(ctx: ObjectResolverContext): Chain {\n  const { nodes, symbols } = ctx;\n  const { z } = symbols;\n\n  const additional = nodes.additionalProperties(ctx);\n  const shape = nodes.shape(ctx);\n\n  if (additional) {\n    return $(z)\n      .attr(identifiers.record)\n      .call($(z).attr(identifiers.string).call(), additional);\n  }\n\n  return $(z).attr(identifiers.object).call(shape);\n}\n\nfunction objectResolver(ctx: ObjectResolverContext): Chain {\n  // TODO: parser - handle constants\n  return ctx.nodes.base(ctx);\n}\n\nfunction shapeNode(ctx: ObjectResolverContext): ReturnType<typeof $.object> {\n  const { plugin, schema } = ctx;\n  const shape = $.object().pretty();\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n\n    const propertyAst = irSchemaToAst({\n      optional: !schema.required?.includes(name),\n      plugin,\n      schema: property,\n      state: {\n        ...ctx.utils.state,\n        path: ref([...fromRef(ctx.utils.state.path), 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      ctx.utils.ast.hasLazyExpression = true;\n      shape.getter(name, propertyAst.expression.return());\n    } else {\n      shape.prop(name, propertyAst.expression);\n    }\n  }\n\n  return shape;\n}\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const ast: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  const ctx: ObjectResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      additionalProperties: additionalPropertiesNode,\n      base: baseNode,\n      shape: shapeNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast,\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.object;\n  const node = resolver?.(ctx) ?? objectResolver(ctx);\n  ast.expression = node;\n  return ast as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { StringResolverContext } from '../../types';\n\nfunction baseNode(ctx: StringResolverContext): Chain {\n  const { z } = ctx.symbols;\n  return $(z).attr(identifiers.string).call();\n}\n\nfunction constNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (typeof schema.const !== 'string') return;\n  return $(z).attr(identifiers.literal).call($.literal(schema.const));\n}\n\nfunction formatNode(ctx: StringResolverContext): Chain | undefined {\n  const { plugin, schema, symbols } = ctx;\n  const { z } = symbols;\n\n  switch (schema.format) {\n    case 'date':\n      return $(z).attr(identifiers.iso).attr(identifiers.date).call();\n    case 'date-time': {\n      const obj = $.object()\n        .$if(plugin.config.dates.offset, (o) =>\n          o.prop('offset', $.literal(true)),\n        )\n        .$if(plugin.config.dates.local, (o) =>\n          o.prop('local', $.literal(true)),\n        );\n      return $(z)\n        .attr(identifiers.iso)\n        .attr(identifiers.datetime)\n        .call(obj.hasProps() ? obj : undefined);\n    }\n    case 'email':\n      return $(z).attr(identifiers.email).call();\n    case 'ipv4':\n      return $(z).attr(identifiers.ipv4).call();\n    case 'ipv6':\n      return $(z).attr(identifiers.ipv6).call();\n    case 'time':\n      return $(z).attr(identifiers.iso).attr(identifiers.time).call();\n    case 'uri':\n      return $(z).attr(identifiers.url).call();\n    case 'uuid':\n      return $(z).attr(identifiers.uuid).call();\n  }\n\n  return;\n}\n\nfunction lengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.minLength === undefined || schema.minLength !== schema.maxLength)\n    return;\n  return $(z).attr(identifiers.length).call($.literal(schema.minLength));\n}\n\nfunction maxLengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.maxLength === undefined) return;\n  return $(z).attr(identifiers.maxLength).call($.literal(schema.maxLength));\n}\n\nfunction minLengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.minLength === undefined) return;\n  return $(z).attr(identifiers.minLength).call($.literal(schema.minLength));\n}\n\nfunction patternNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (!schema.pattern) return;\n  return $(z).attr(identifiers.regex).call($.regexp(schema.pattern));\n}\n\nfunction stringResolver(ctx: StringResolverContext): Chain {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) {\n    ctx.chain.current = constNode;\n    return ctx.chain.current;\n  }\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.chain.current = baseNode;\n\n  const formatNode = ctx.nodes.format(ctx);\n  if (formatNode) ctx.chain.current = formatNode;\n\n  const checks: Array<Chain> = [];\n\n  const lengthNode = ctx.nodes.length(ctx);\n  if (lengthNode) {\n    checks.push(lengthNode);\n  } else {\n    const minLengthNode = ctx.nodes.minLength(ctx);\n    if (minLengthNode) checks.push(minLengthNode);\n\n    const maxLengthNode = ctx.nodes.maxLength(ctx);\n    if (maxLengthNode) checks.push(maxLengthNode);\n  }\n\n  const patternNode = ctx.nodes.pattern(ctx);\n  if (patternNode) checks.push(patternNode);\n\n  if (checks.length > 0) {\n    ctx.chain.current = ctx.chain.current\n      .attr(identifiers.check)\n      .call(...checks);\n  }\n\n  return ctx.chain.current;\n}\n\nexport const stringToNode = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n  const ctx: StringResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      format: formatNode,\n      length: lengthNode,\n      maxLength: maxLengthNode,\n      minLength: minLengthNode,\n      pattern: patternNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.string;\n  const node = resolver?.(ctx) ?? stringResolver(ctx);\n  return {\n    expression: node,\n  };\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      $(z).attr(identifiers.literal).call($.fromValue(value)),\n    );\n    result.expression = $(z)\n      .attr(identifiers.tuple)\n      .call($.array(...tupleElements));\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  const tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const itemSchema = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      tupleElements.push(itemSchema.expression);\n      if (itemSchema.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n    });\n  }\n\n  result.expression = $(z)\n    .attr(identifiers.tuple)\n    .call($.array(...tupleElements));\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z).attr(identifiers.undefined).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z).attr(identifiers.void).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { shouldCoerceToBigInt } from '~/plugins/shared/utils/coerce';\n\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToNode } from './number';\nimport { objectToAst } from './object';\nimport { stringToNode } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> => {\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return booleanToAst({\n        ...args,\n        schema: schema as SchemaWithType<'boolean'>,\n      });\n    case 'enum':\n      return enumToAst({\n        ...args,\n        schema: schema as SchemaWithType<'enum'>,\n      });\n    case 'integer':\n    case 'number':\n      return numberToNode({\n        ...args,\n        schema: schema as SchemaWithType<'integer' | 'number'>,\n      });\n    case 'never':\n      return neverToAst({\n        ...args,\n        schema: schema as SchemaWithType<'never'>,\n      });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return shouldCoerceToBigInt(schema.format)\n        ? numberToNode({\n            ...args,\n            schema: { ...schema, type: 'number' },\n          })\n        : stringToNode({\n            ...args,\n            schema: schema as SchemaWithType<'string'>,\n          });\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return undefinedToAst({\n        ...args,\n        schema: schema as SchemaWithType<'undefined'>,\n      });\n    case 'unknown':\n      return unknownToAst({\n        ...args,\n        schema: schema as SchemaWithType<'unknown'>,\n      });\n    case 'void':\n      return voidToAst({\n        ...args,\n        schema: schema as SchemaWithType<'void'>,\n      });\n  }\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport { fromRef, ref, refs } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport type { SchemaWithType } from '~/plugins';\nimport { maybeBigInt } from '~/plugins/shared/utils/coerce';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { identifiers } from '../constants';\nimport { exportAst } from '../shared/export';\nimport { getZodModule } from '../shared/module';\nimport { irOperationToAst } from '../shared/operation';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ZodPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  let ast: Partial<Ast> = {};\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'zod',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      ast.expression = $(refSymbol);\n    } else {\n      ast.expression = $(z)\n        .attr(identifiers.lazy)\n        .call($.func().returns('any').do($(refSymbol).return()));\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression['~ref'] = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.hasLazyExpression = typeAst.hasLazyExpression;\n\n    if (plugin.config.metadata && schema.description) {\n      ast.expression = ast.expression\n        .attr(identifiers.register)\n        .call(\n          $(z).attr(identifiers.globalRegistry),\n          $.object()\n            .pretty()\n            .prop('description', $.literal(schema.description)),\n        );\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemSchemas = schema.items.map((item, index) =>\n        irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: ref([...fromRef(state.path), 'items', index]),\n          },\n        }),\n      );\n\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items[0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.merge()` as that does not exist on `.union()` and non-object schemas.\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          ast.expression = $(z)\n            .attr(identifiers.intersection)\n            .call(...itemSchemas.map((schema) => schema.expression));\n        } else {\n          ast.expression = itemSchemas[0]!.expression;\n          itemSchemas.slice(1).forEach((schema) => {\n            ast.expression = $(z)\n              .attr(identifiers.intersection)\n              .call(\n                ast.expression,\n                schema.hasLazyExpression\n                  ? $(z)\n                      .attr(identifiers.lazy)\n                      .call($.func().do(schema.expression.return()))\n                  : schema.expression,\n              );\n          });\n        }\n      } else {\n        ast.expression = $(z)\n          .attr(identifiers.union)\n          .call(\n            $.array()\n              .pretty()\n              .elements(...itemSchemas.map((schema) => schema.expression)),\n          );\n      }\n    } else {\n      ast = irSchemaToAst({ plugin, schema, state });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n  }\n\n  if (ast.expression) {\n    if (schema.accessScope === 'read') {\n      ast.expression = $(z).attr(identifiers.readonly).call(ast.expression);\n    }\n\n    if (optional) {\n      ast.expression = $(z).attr(identifiers.optional).call(ast.expression);\n      ast.typeName = identifiers.ZodMiniOptional;\n    }\n\n    if (schema.default !== undefined) {\n      ast.expression = $(z)\n        .attr(identifiers._default)\n        .call(\n          ast.expression,\n          schema.type === 'integer' || schema.type === 'number'\n            ? maybeBigInt(schema.default, schema.format)\n            : $.fromValue(schema.default),\n        );\n    }\n  }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(fromRef(state.path));\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.symbol(\n    applyNaming(baseName, plugin.config.definitions),\n    {\n      meta: {\n        category: 'schema',\n        path: fromRef(state.path),\n        resource: 'definition',\n        resourceId: $ref,\n        tags: fromRef(state.tags),\n        tool: 'zod',\n      },\n    },\n  );\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.symbol(\n        applyNaming(baseName, plugin.config.definitions.types.infer),\n        {\n          meta: {\n            category: 'type',\n            path: fromRef(state.path),\n            resource: 'definition',\n            resourceId: $ref,\n            tags: fromRef(state.tags),\n            tool: 'zod',\n            variant: 'infer',\n          },\n        },\n      )\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n};\n\nexport const handlerMini: ZodPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('z', {\n    external: getZodModule({ plugin }),\n    importKind: 'namespace',\n    meta: {\n      category: 'external',\n      resource: 'zod.z',\n    },\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = refs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          irOperationToAst({\n            getAst: (schema, path) => {\n              const state = refs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'webhook':\n          irWebhookToAst({\n            getAst: (schema, path) => {\n              const state = refs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n      }\n    },\n  );\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}) => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const expression = $(z).attr(identifiers.unknown).call();\n  return expression;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const functionName = $(z).attr(identifiers.array);\n\n  let arrayExpression: ReturnType<typeof $.call> | undefined;\n  let hasLazyExpression = false;\n\n  if (!schema.items) {\n    arrayExpression = functionName.call(\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }),\n    );\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        hasLazyExpression = true;\n      }\n      return itemAst.expression;\n    });\n\n    if (itemExpressions.length === 1) {\n      arrayExpression = functionName.call(...itemExpressions);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items![0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.and()` as that does not exist on `.union()` and non-object schemas.\n        let intersectionExpression: ReturnType<typeof $.call | typeof $.expr>;\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          intersectionExpression = $(z)\n            .attr(identifiers.intersection)\n            .call(...itemExpressions);\n        } else {\n          intersectionExpression = itemExpressions[0]!;\n          for (let i = 1; i < itemExpressions.length; i++) {\n            intersectionExpression = intersectionExpression\n              .attr(identifiers.and)\n              .call(itemExpressions[i]);\n          }\n        }\n\n        arrayExpression = functionName.call(intersectionExpression);\n      } else {\n        arrayExpression = $(z)\n          .attr(identifiers.array)\n          .call(\n            $(z)\n              .attr(identifiers.union)\n              .call($.array(...itemExpressions)),\n          );\n      }\n    }\n  }\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    arrayExpression = arrayExpression\n      .attr(identifiers.length)\n      .call($.fromValue(schema.minItems));\n  } else {\n    if (schema.minItems !== undefined) {\n      arrayExpression = arrayExpression\n        .attr(identifiers.min)\n        .call($.fromValue(schema.minItems));\n    }\n\n    if (schema.maxItems !== undefined) {\n      arrayExpression = arrayExpression\n        .attr(identifiers.max)\n        .call($.fromValue(schema.maxItems));\n    }\n  }\n\n  return {\n    expression: arrayExpression,\n    hasLazyExpression,\n  };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const booleanToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): ReturnType<typeof $.call> => {\n  let chain: ReturnType<typeof $.call>;\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (typeof schema.const === 'boolean') {\n    chain = $(z).attr(identifiers.literal).call($.literal(schema.const));\n    return chain;\n  }\n\n  chain = $(z).attr(identifiers.boolean).call();\n  return chain;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { unknownToAst } from './unknown';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): ReturnType<typeof $.call> => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const enumMembers: Array<ReturnType<typeof $.literal>> = [];\n  const literalMembers: Array<ReturnType<typeof $.call>> = [];\n\n  let isNullable = false;\n  let allStrings = true;\n\n  for (const item of schema.items ?? []) {\n    // Zod supports string, number, and boolean enums\n    if (item.type === 'string' && typeof item.const === 'string') {\n      const literal = $.literal(item.const);\n      enumMembers.push(literal);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (\n      (item.type === 'number' || item.type === 'integer') &&\n      typeof item.const === 'number'\n    ) {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (item.type === 'boolean' && typeof item.const === 'boolean') {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  if (!literalMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  // Use z.enum() for pure string enums, z.union() for mixed or non-string types\n  let enumExpression: ReturnType<typeof $.call>;\n  if (allStrings && enumMembers.length > 0) {\n    enumExpression = $(z)\n      .attr(identifiers.enum)\n      .call($.array(...enumMembers));\n  } else if (literalMembers.length === 1) {\n    // For single-member unions, use the member directly instead of wrapping in z.union()\n    enumExpression = literalMembers[0]!;\n  } else {\n    enumExpression = $(z)\n      .attr(identifiers.union)\n      .call($.array(...literalMembers));\n  }\n\n  if (isNullable) {\n    enumExpression = enumExpression.attr(identifiers.nullable).call();\n  }\n\n  return enumExpression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}) => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const expression = $(z).attr(identifiers.never).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}) => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const expression = $(z).attr(identifiers.null).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport {\n  maybeBigInt,\n  shouldCoerceToBigInt,\n} from '~/plugins/shared/utils/coerce';\nimport { getIntegerLimit } from '~/plugins/shared/utils/formats';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { NumberResolverContext } from '../../types';\n\nfunction baseNode(ctx: NumberResolverContext): Chain {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (ctx.utils.shouldCoerceToBigInt(schema.format)) {\n    return $(z).attr(identifiers.coerce).attr(identifiers.bigint).call();\n  }\n  let chain = $(z).attr(identifiers.number).call();\n  if (schema.type === 'integer') {\n    chain = chain.attr(identifiers.int).call();\n  }\n  return chain;\n}\n\nfunction constNode(ctx: NumberResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.const === undefined) return;\n  return $(z)\n    .attr(identifiers.literal)\n    .call(ctx.utils.maybeBigInt(schema.const, schema.format));\n}\n\nfunction maxNode(ctx: NumberResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.exclusiveMaximum !== undefined) {\n    return chain.current\n      .attr(identifiers.lt)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMaximum, schema.format));\n  }\n  if (schema.maximum !== undefined) {\n    return chain.current\n      .attr(identifiers.lte)\n      .call(ctx.utils.maybeBigInt(schema.maximum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return chain.current\n      .attr(identifiers.max)\n      .call(\n        ctx.utils.maybeBigInt(limit.maxValue, schema.format),\n        $.object().prop('message', $.literal(limit.maxError)),\n      );\n  }\n  return;\n}\n\nfunction minNode(ctx: NumberResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.exclusiveMinimum !== undefined) {\n    return chain.current\n      .attr(identifiers.gt)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMinimum, schema.format));\n  }\n  if (schema.minimum !== undefined) {\n    return chain.current\n      .attr(identifiers.gte)\n      .call(ctx.utils.maybeBigInt(schema.minimum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return chain.current\n      .attr(identifiers.min)\n      .call(\n        ctx.utils.maybeBigInt(limit.minValue, schema.format),\n        $.object().prop('message', $.literal(limit.minError)),\n      );\n  }\n  return;\n}\n\nfunction numberResolver(ctx: NumberResolverContext): Chain {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) {\n    ctx.chain.current = constNode;\n    return ctx.chain.current;\n  }\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.chain.current = baseNode;\n\n  const minNode = ctx.nodes.min(ctx);\n  if (minNode) ctx.chain.current = minNode;\n\n  const maxNode = ctx.nodes.max(ctx);\n  if (maxNode) ctx.chain.current = maxNode;\n\n  return ctx.chain.current;\n}\n\nexport const numberToNode = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): Chain => {\n  const ast: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  const ctx: NumberResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      max: maxNode,\n      min: minNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast,\n      getIntegerLimit,\n      maybeBigInt,\n      shouldCoerceToBigInt,\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.number;\n  const node = resolver?.(ctx) ?? numberResolver(ctx);\n  return node;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { ObjectResolverContext } from '../../types';\nimport { irSchemaToAst } from '../plugin';\n\nfunction additionalPropertiesNode(\n  ctx: ObjectResolverContext,\n): Chain | null | undefined {\n  const { plugin, schema } = ctx;\n\n  if (\n    !schema.additionalProperties ||\n    (schema.properties && Object.keys(schema.properties).length > 0)\n  )\n    return;\n\n  const additionalAst = irSchemaToAst({\n    plugin,\n    schema: schema.additionalProperties,\n    state: {\n      ...ctx.utils.state,\n      path: ref([...fromRef(ctx.utils.state.path), 'additionalProperties']),\n    },\n  });\n  if (additionalAst.hasLazyExpression) ctx.utils.ast.hasLazyExpression = true;\n  return additionalAst.expression;\n}\n\nfunction baseNode(ctx: ObjectResolverContext): Chain {\n  const { nodes, symbols } = ctx;\n  const { z } = symbols;\n\n  const additional = nodes.additionalProperties(ctx);\n  const shape = nodes.shape(ctx);\n\n  if (additional) {\n    return $(z).attr(identifiers.record).call(additional);\n  }\n\n  return $(z).attr(identifiers.object).call(shape);\n}\n\nfunction objectResolver(ctx: ObjectResolverContext): Chain {\n  // TODO: parser - handle constants\n  return ctx.nodes.base(ctx);\n}\n\nfunction shapeNode(ctx: ObjectResolverContext): ReturnType<typeof $.object> {\n  const { plugin, schema } = ctx;\n  const shape = $.object().pretty();\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n\n    const propertyAst = irSchemaToAst({\n      optional: !schema.required?.includes(name),\n      plugin,\n      schema: property,\n      state: {\n        ...ctx.utils.state,\n        path: ref([...fromRef(ctx.utils.state.path), 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) ctx.utils.ast.hasLazyExpression = true;\n    shape.prop(name, propertyAst.expression);\n  }\n\n  return shape;\n}\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  const ast: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  const ctx: ObjectResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      additionalProperties: additionalPropertiesNode,\n      base: baseNode,\n      shape: shapeNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast,\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.object;\n  const node = resolver?.(ctx) ?? objectResolver(ctx);\n  ast.expression = node;\n  return {\n    ...ast,\n    anyType: 'AnyZodObject',\n  } as Omit<Ast, 'typeName'> & {\n    anyType: string;\n  };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Chain } from '../../shared/chain';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport type { StringResolverContext } from '../../types';\n\nfunction baseNode(ctx: StringResolverContext): Chain {\n  const { z } = ctx.symbols;\n  return $(z).attr(identifiers.string).call();\n}\n\nfunction constNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (typeof schema.const !== 'string') return;\n  return $(z).attr(identifiers.literal).call($.literal(schema.const));\n}\n\nfunction formatNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, plugin, schema } = ctx;\n\n  switch (schema.format) {\n    case 'date':\n      return chain.current.attr(identifiers.date).call();\n    case 'date-time': {\n      const obj = $.object()\n        .$if(plugin.config.dates.offset, (o) =>\n          o.prop('offset', $.literal(true)),\n        )\n        .$if(plugin.config.dates.local, (o) =>\n          o.prop('local', $.literal(true)),\n        );\n      return chain.current\n        .attr(identifiers.datetime)\n        .call(obj.hasProps() ? obj : undefined);\n    }\n    case 'email':\n      return chain.current.attr(identifiers.email).call();\n    case 'ipv4':\n    case 'ipv6':\n      return chain.current.attr(identifiers.ip).call();\n    case 'time':\n      return chain.current.attr(identifiers.time).call();\n    case 'uri':\n      return chain.current.attr(identifiers.url).call();\n    case 'uuid':\n      return chain.current.attr(identifiers.uuid).call();\n  }\n\n  return;\n}\n\nfunction lengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.minLength === undefined || schema.minLength !== schema.maxLength)\n    return;\n  return chain.current\n    .attr(identifiers.length)\n    .call($.literal(schema.minLength));\n}\n\nfunction maxLengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.maxLength === undefined) return;\n  return chain.current.attr(identifiers.max).call($.literal(schema.maxLength));\n}\n\nfunction minLengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.minLength === undefined) return;\n  return chain.current.attr(identifiers.min).call($.literal(schema.minLength));\n}\n\nfunction patternNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (!schema.pattern) return;\n  return chain.current.attr(identifiers.regex).call($.regexp(schema.pattern));\n}\n\nfunction stringResolver(ctx: StringResolverContext): Chain {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) {\n    ctx.chain.current = constNode;\n    return ctx.chain.current;\n  }\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.chain.current = baseNode;\n\n  const formatNode = ctx.nodes.format(ctx);\n  if (formatNode) ctx.chain.current = formatNode;\n\n  const lengthNode = ctx.nodes.length(ctx);\n  if (lengthNode) {\n    ctx.chain.current = lengthNode;\n  } else {\n    const minLengthNode = ctx.nodes.minLength(ctx);\n    if (minLengthNode) ctx.chain.current = minLengthNode;\n\n    const maxLengthNode = ctx.nodes.maxLength(ctx);\n    if (maxLengthNode) ctx.chain.current = maxLengthNode;\n  }\n\n  const patternNode = ctx.nodes.pattern(ctx);\n  if (patternNode) ctx.chain.current = patternNode;\n\n  return ctx.chain.current;\n}\n\nexport const stringToNode = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Chain => {\n  const z = plugin.external('zod.z');\n  const ctx: StringResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      format: formatNode,\n      length: lengthNode,\n      maxLength: maxLengthNode,\n      minLength: minLengthNode,\n      pattern: patternNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.string;\n  const node = resolver?.(ctx) ?? stringResolver(ctx);\n  return node;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  let hasLazyExpression = false;\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      $(z).attr(identifiers.literal).call($.fromValue(value)),\n    );\n    const expression = $(z)\n      .attr(identifiers.tuple)\n      .call($.array(...tupleElements));\n    return {\n      expression,\n      hasLazyExpression,\n    };\n  }\n\n  const tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const itemSchema = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      tupleElements.push(itemSchema.expression);\n      if (itemSchema.hasLazyExpression) {\n        hasLazyExpression = true;\n      }\n    });\n  }\n\n  const expression = $(z)\n    .attr(identifiers.tuple)\n    .call($.array(...tupleElements));\n\n  return {\n    expression,\n    hasLazyExpression,\n  };\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}) => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const expression = $(z).attr(identifiers.undefined).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}) => {\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  const expression = $(z).attr(identifiers.void).call();\n  return expression;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { shouldCoerceToBigInt } from '~/plugins/shared/utils/coerce';\n\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToNode } from './number';\nimport { objectToAst } from './object';\nimport { stringToNode } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return {\n        expression: booleanToAst({\n          ...args,\n          schema: schema as SchemaWithType<'boolean'>,\n        }),\n      };\n    case 'enum':\n      return {\n        expression: enumToAst({\n          ...args,\n          schema: schema as SchemaWithType<'enum'>,\n        }),\n      };\n    case 'integer':\n    case 'number':\n      return {\n        expression: numberToNode({\n          ...args,\n          schema: schema as SchemaWithType<'integer' | 'number'>,\n        }),\n      };\n    case 'never':\n      return {\n        expression: neverToAst({\n          ...args,\n          schema: schema as SchemaWithType<'never'>,\n        }),\n      };\n    case 'null':\n      return {\n        expression: nullToAst({\n          ...args,\n          schema: schema as SchemaWithType<'null'>,\n        }),\n      };\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return {\n        expression: shouldCoerceToBigInt(schema.format)\n          ? numberToNode({\n              ...args,\n              schema: { ...schema, type: 'number' },\n            })\n          : stringToNode({\n              ...args,\n              schema: schema as SchemaWithType<'string'>,\n            }),\n      };\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return {\n        expression: undefinedToAst({\n          ...args,\n          schema: schema as SchemaWithType<'undefined'>,\n        }),\n      };\n    case 'unknown':\n      return {\n        expression: unknownToAst({\n          ...args,\n          schema: schema as SchemaWithType<'unknown'>,\n        }),\n      };\n    case 'void':\n      return {\n        expression: voidToAst({\n          ...args,\n          schema: schema as SchemaWithType<'void'>,\n        }),\n      };\n  }\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport { fromRef, ref, refs } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport type { SchemaWithType } from '~/plugins';\nimport { maybeBigInt } from '~/plugins/shared/utils/coerce';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { identifiers } from '../constants';\nimport { exportAst } from '../shared/export';\nimport { getZodModule } from '../shared/module';\nimport { irOperationToAst } from '../shared/operation';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ZodPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  let ast: Partial<Ast> = {};\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'zod',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      ast.expression = $(refSymbol);\n    } else {\n      ast.expression = $(z)\n        .attr(identifiers.lazy)\n        .call($.func().do($(refSymbol).return()));\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression['~ref'] = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.typeName = typeAst.anyType;\n\n    if (plugin.config.metadata && schema.description) {\n      ast.expression = ast.expression\n        .attr(identifiers.describe)\n        .call($.literal(schema.description));\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemTypes = schema.items.map((item, index) => {\n        const typeAst = irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: ref([...fromRef(state.path), 'items', index]),\n          },\n        });\n        return typeAst.expression;\n      });\n\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items[0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.merge()` as that does not exist on `.union()` and non-object schemas.\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          ast.expression = $(z)\n            .attr(identifiers.intersection)\n            .call(...itemTypes);\n        } else {\n          ast.expression = itemTypes[0];\n          itemTypes.slice(1).forEach((item) => {\n            ast.expression = ast.expression!.attr(identifiers.and).call(item);\n          });\n        }\n      } else {\n        ast.expression = $(z)\n          .attr(identifiers.union)\n          .call(\n            $.array()\n              .pretty()\n              .elements(...itemTypes),\n          );\n      }\n    } else {\n      ast = irSchemaToAst({ plugin, schema, state });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.typeName = typeAst.anyType;\n  }\n\n  if (ast.expression) {\n    if (schema.accessScope === 'read') {\n      ast.expression = ast.expression.attr(identifiers.readonly).call();\n    }\n\n    if (optional) {\n      ast.expression = ast.expression.attr(identifiers.optional).call();\n    }\n\n    if (schema.default !== undefined) {\n      ast.expression = ast.expression\n        .attr(identifiers.default)\n        .call(\n          schema.type === 'integer' || schema.type === 'number'\n            ? maybeBigInt(schema.default, schema.format)\n            : $.fromValue(schema.default),\n        );\n    }\n  }\n\n  if (state.hasLazyExpression['~ref']) {\n    if (!ast.typeName) {\n      ast.typeName = 'ZodTypeAny';\n    }\n  } else if (ast.typeName) {\n    ast.typeName = undefined;\n  }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(fromRef(state.path));\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.symbol(\n    applyNaming(baseName, plugin.config.definitions),\n    {\n      meta: {\n        category: 'schema',\n        path: fromRef(state.path),\n        resource: 'definition',\n        resourceId: $ref,\n        tags: fromRef(state.tags),\n        tool: 'zod',\n      },\n    },\n  );\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.symbol(\n        applyNaming(baseName, plugin.config.definitions.types.infer),\n        {\n          meta: {\n            category: 'type',\n            path: fromRef(state.path),\n            resource: 'definition',\n            resourceId: $ref,\n            tags: fromRef(state.tags),\n            tool: 'zod',\n            variant: 'infer',\n          },\n        },\n      )\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n};\n\nexport const handlerV3: ZodPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('z', {\n    external: getZodModule({ plugin }),\n    meta: {\n      category: 'external',\n      resource: 'zod.z',\n    },\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = refs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          irOperationToAst({\n            getAst: (schema, path) => {\n              const state = refs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'webhook':\n          irWebhookToAst({\n            getAst: (schema, path) => {\n              const state = refs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n      }\n    },\n  );\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  result.expression = $(z).attr(identifiers.unknown).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const functionName = $(z).attr(identifiers.array);\n\n  if (!schema.items) {\n    result.expression = functionName.call(\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }).expression,\n    );\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return itemAst.expression;\n    });\n\n    if (itemExpressions.length === 1) {\n      result.expression = functionName.call(...itemExpressions);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items![0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.and()` as that does not exist on `.union()` and non-object schemas.\n        let intersectionExpression: ReturnType<typeof $.call | typeof $.expr>;\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          intersectionExpression = $(z)\n            .attr(identifiers.intersection)\n            .call(...itemExpressions);\n        } else {\n          intersectionExpression = itemExpressions[0]!;\n          for (let i = 1; i < itemExpressions.length; i++) {\n            intersectionExpression = intersectionExpression\n              .attr(identifiers.and)\n              .call(itemExpressions[i]);\n          }\n        }\n\n        result.expression = functionName.call(intersectionExpression);\n      } else {\n        result.expression = $(z)\n          .attr(identifiers.array)\n          .call(\n            $(z)\n              .attr(identifiers.union)\n              .call($.array(...itemExpressions)),\n          );\n      }\n    }\n  }\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    result.expression = result.expression\n      .attr(identifiers.length)\n      .call($.fromValue(schema.minItems));\n  } else {\n    if (schema.minItems !== undefined) {\n      result.expression = result.expression\n        .attr(identifiers.min)\n        .call($.fromValue(schema.minItems));\n    }\n\n    if (schema.maxItems !== undefined) {\n      result.expression = result.expression\n        .attr(identifiers.max)\n        .call($.fromValue(schema.maxItems));\n    }\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const booleanToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  let chain: ReturnType<typeof $.call>;\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (typeof schema.const === 'boolean') {\n    chain = $(z).attr(identifiers.literal).call($.literal(schema.const));\n    result.expression = chain;\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  chain = $(z).attr(identifiers.boolean).call();\n  result.expression = chain;\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { unknownToAst } from './unknown';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  const enumMembers: Array<ReturnType<typeof $.literal>> = [];\n  const literalMembers: Array<ReturnType<typeof $.call>> = [];\n\n  let isNullable = false;\n  let allStrings = true;\n\n  for (const item of schema.items ?? []) {\n    // Zod supports string, number, and boolean enums\n    if (item.type === 'string' && typeof item.const === 'string') {\n      const literal = $.literal(item.const);\n      enumMembers.push(literal);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (\n      (item.type === 'number' || item.type === 'integer') &&\n      typeof item.const === 'number'\n    ) {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (item.type === 'boolean' && typeof item.const === 'boolean') {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  if (!literalMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  // Use z.enum() for pure string enums, z.union() for mixed or non-string types\n  if (allStrings && enumMembers.length > 0) {\n    result.expression = $(z)\n      .attr(identifiers.enum)\n      .call($.array(...enumMembers));\n  } else if (literalMembers.length === 1) {\n    // For single-member unions, use the member directly instead of wrapping in z.union()\n    result.expression = literalMembers[0]!;\n  } else {\n    result.expression = $(z)\n      .attr(identifiers.union)\n      .call($.array(...literalMembers));\n  }\n\n  if (isNullable) {\n    result.expression = $(z).attr(identifiers.nullable).call(result.expression);\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  result.expression = $(z).attr(identifiers.never).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  result.expression = $(z).attr(identifiers.null).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport {\n  maybeBigInt,\n  shouldCoerceToBigInt,\n} from '~/plugins/shared/utils/coerce';\nimport { getIntegerLimit } from '~/plugins/shared/utils/formats';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { NumberResolverContext } from '../../types';\n\nfunction baseNode(ctx: NumberResolverContext): Chain {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (ctx.utils.shouldCoerceToBigInt(schema.format)) {\n    return $(z).attr(identifiers.coerce).attr(identifiers.bigint).call();\n  }\n  let chain = $(z).attr(identifiers.number).call();\n  if (schema.type === 'integer') {\n    chain = $(z).attr(identifiers.int).call();\n  }\n  return chain;\n}\n\nfunction constNode(ctx: NumberResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.const === undefined) return;\n  return $(z)\n    .attr(identifiers.literal)\n    .call(ctx.utils.maybeBigInt(schema.const, schema.format));\n}\n\nfunction maxNode(ctx: NumberResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.exclusiveMaximum !== undefined) {\n    return chain.current\n      .attr(identifiers.lt)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMaximum, schema.format));\n  }\n  if (schema.maximum !== undefined) {\n    return chain.current\n      .attr(identifiers.lte)\n      .call(ctx.utils.maybeBigInt(schema.maximum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return chain.current\n      .attr(identifiers.max)\n      .call(\n        ctx.utils.maybeBigInt(limit.maxValue, schema.format),\n        $.object().prop('error', $.literal(limit.maxError)),\n      );\n  }\n  return;\n}\n\nfunction minNode(ctx: NumberResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.exclusiveMinimum !== undefined) {\n    return chain.current\n      .attr(identifiers.gt)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMinimum, schema.format));\n  }\n  if (schema.minimum !== undefined) {\n    return chain.current\n      .attr(identifiers.gte)\n      .call(ctx.utils.maybeBigInt(schema.minimum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return chain.current\n      .attr(identifiers.min)\n      .call(\n        ctx.utils.maybeBigInt(limit.minValue, schema.format),\n        $.object().prop('error', $.literal(limit.minError)),\n      );\n  }\n  return;\n}\n\nfunction numberResolver(ctx: NumberResolverContext): Chain {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) {\n    ctx.chain.current = constNode;\n    return ctx.chain.current;\n  }\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.chain.current = baseNode;\n\n  const minNode = ctx.nodes.min(ctx);\n  if (minNode) ctx.chain.current = minNode;\n\n  const maxNode = ctx.nodes.max(ctx);\n  if (maxNode) ctx.chain.current = maxNode;\n\n  return ctx.chain.current;\n}\n\nexport const numberToNode = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): Omit<Ast, 'typeName'> => {\n  const ast: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  const ctx: NumberResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      max: maxNode,\n      min: minNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast,\n      getIntegerLimit,\n      maybeBigInt,\n      shouldCoerceToBigInt,\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.number;\n  const node = resolver?.(ctx) ?? numberResolver(ctx);\n  ast.expression = node;\n  return ast as Omit<Ast, 'typeName'>;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { ObjectResolverContext } from '../../types';\nimport { irSchemaToAst } from '../plugin';\n\nfunction additionalPropertiesNode(\n  ctx: ObjectResolverContext,\n): Chain | null | undefined {\n  const { plugin, schema } = ctx;\n\n  if (\n    !schema.additionalProperties ||\n    (schema.properties && Object.keys(schema.properties).length > 0)\n  )\n    return;\n\n  const additionalAst = irSchemaToAst({\n    plugin,\n    schema: schema.additionalProperties,\n    state: {\n      ...ctx.utils.state,\n      path: ref([...fromRef(ctx.utils.state.path), 'additionalProperties']),\n    },\n  });\n  if (additionalAst.hasLazyExpression) ctx.utils.ast.hasLazyExpression = true;\n  return additionalAst.expression;\n}\n\nfunction baseNode(ctx: ObjectResolverContext): Chain {\n  const { nodes, symbols } = ctx;\n  const { z } = symbols;\n\n  const additional = nodes.additionalProperties(ctx);\n  const shape = nodes.shape(ctx);\n\n  if (additional) {\n    return $(z)\n      .attr(identifiers.record)\n      .call($(z).attr(identifiers.string).call(), additional);\n  }\n\n  return $(z).attr(identifiers.object).call(shape);\n}\n\nfunction objectResolver(ctx: ObjectResolverContext): Chain {\n  // TODO: parser - handle constants\n  return ctx.nodes.base(ctx);\n}\n\nfunction shapeNode(ctx: ObjectResolverContext): ReturnType<typeof $.object> {\n  const { plugin, schema } = ctx;\n  const shape = $.object().pretty();\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n\n    const propertyAst = irSchemaToAst({\n      optional: !schema.required?.includes(name),\n      plugin,\n      schema: property,\n      state: {\n        ...ctx.utils.state,\n        path: ref([...fromRef(ctx.utils.state.path), 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      ctx.utils.ast.hasLazyExpression = true;\n      shape.getter(name, propertyAst.expression.return());\n    } else {\n      shape.prop(name, propertyAst.expression);\n    }\n  }\n\n  return shape;\n}\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const ast: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  const ctx: ObjectResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      additionalProperties: additionalPropertiesNode,\n      base: baseNode,\n      shape: shapeNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast,\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.object;\n  const node = resolver?.(ctx) ?? objectResolver(ctx);\n  ast.expression = node;\n  return ast as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport type { StringResolverContext } from '../../types';\n\nfunction baseNode(ctx: StringResolverContext): Chain {\n  const { z } = ctx.symbols;\n  return $(z).attr(identifiers.string).call();\n}\n\nfunction constNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (typeof schema.const !== 'string') return;\n  return $(z).attr(identifiers.literal).call($.literal(schema.const));\n}\n\nfunction formatNode(ctx: StringResolverContext): Chain | undefined {\n  const { plugin, schema, symbols } = ctx;\n  const { z } = symbols;\n\n  switch (schema.format) {\n    case 'date':\n      return $(z).attr(identifiers.iso).attr(identifiers.date).call();\n    case 'date-time': {\n      const obj = $.object()\n        .$if(plugin.config.dates.offset, (o) =>\n          o.prop('offset', $.literal(true)),\n        )\n        .$if(plugin.config.dates.local, (o) =>\n          o.prop('local', $.literal(true)),\n        );\n      return $(z)\n        .attr(identifiers.iso)\n        .attr(identifiers.datetime)\n        .call(obj.hasProps() ? obj : undefined);\n    }\n    case 'email':\n      return $(z).attr(identifiers.email).call();\n    case 'ipv4':\n      return $(z).attr(identifiers.ipv4).call();\n    case 'ipv6':\n      return $(z).attr(identifiers.ipv6).call();\n    case 'time':\n      return $(z).attr(identifiers.iso).attr(identifiers.time).call();\n    case 'uri':\n      return $(z).attr(identifiers.url).call();\n    case 'uuid':\n      return $(z).attr(identifiers.uuid).call();\n  }\n\n  return;\n}\n\nfunction lengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.minLength === undefined || schema.minLength !== schema.maxLength)\n    return;\n  return chain.current\n    .attr(identifiers.length)\n    .call($.literal(schema.minLength));\n}\n\nfunction maxLengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.maxLength === undefined) return;\n  return chain.current.attr(identifiers.max).call($.literal(schema.maxLength));\n}\n\nfunction minLengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.minLength === undefined) return;\n  return chain.current.attr(identifiers.min).call($.literal(schema.minLength));\n}\n\nfunction patternNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (!schema.pattern) return;\n  return chain.current.attr(identifiers.regex).call($.regexp(schema.pattern));\n}\n\nfunction stringResolver(ctx: StringResolverContext): Chain {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) {\n    ctx.chain.current = constNode;\n    return ctx.chain.current;\n  }\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.chain.current = baseNode;\n\n  const formatNode = ctx.nodes.format(ctx);\n  if (formatNode) ctx.chain.current = formatNode;\n\n  const lengthNode = ctx.nodes.length(ctx);\n  if (lengthNode) {\n    ctx.chain.current = lengthNode;\n  } else {\n    const minLengthNode = ctx.nodes.minLength(ctx);\n    if (minLengthNode) ctx.chain.current = minLengthNode;\n\n    const maxLengthNode = ctx.nodes.maxLength(ctx);\n    if (maxLengthNode) ctx.chain.current = maxLengthNode;\n  }\n\n  const patternNode = ctx.nodes.pattern(ctx);\n  if (patternNode) ctx.chain.current = patternNode;\n\n  return ctx.chain.current;\n}\n\nexport const stringToNode = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n  const ctx: StringResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      format: formatNode,\n      length: lengthNode,\n      maxLength: maxLengthNode,\n      minLength: minLengthNode,\n      pattern: patternNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.string;\n  const node = resolver?.(ctx) ?? stringResolver(ctx);\n  return {\n    expression: node,\n  };\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\n\nimport type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      $(z).attr(identifiers.literal).call($.fromValue(value)),\n    );\n    result.expression = $(z)\n      .attr(identifiers.tuple)\n      .call($.array(...tupleElements));\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  const tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const itemSchema = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      tupleElements.push(itemSchema.expression);\n      if (itemSchema.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n    });\n  }\n\n  result.expression = $(z)\n    .attr(identifiers.tuple)\n    .call($.array(...tupleElements));\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  result.expression = $(z).attr(identifiers.undefined).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { $ } from '~/ts-dsl';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n  result.expression = $(z).attr(identifiers.void).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '~/plugins';\nimport { shouldCoerceToBigInt } from '~/plugins/shared/utils/coerce';\n\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToNode } from './number';\nimport { objectToAst } from './object';\nimport { stringToNode } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport const irSchemaWithTypeToAst = ({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> => {\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return booleanToAst({\n        ...args,\n        schema: schema as SchemaWithType<'boolean'>,\n      });\n    case 'enum':\n      return enumToAst({\n        ...args,\n        schema: schema as SchemaWithType<'enum'>,\n      });\n    case 'integer':\n    case 'number':\n      return numberToNode({\n        ...args,\n        schema: schema as SchemaWithType<'integer' | 'number'>,\n      });\n    case 'never':\n      return neverToAst({\n        ...args,\n        schema: schema as SchemaWithType<'never'>,\n      });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return shouldCoerceToBigInt(schema.format)\n        ? numberToNode({\n            ...args,\n            schema: { ...schema, type: 'number' },\n          })\n        : stringToNode({\n            ...args,\n            schema: schema as SchemaWithType<'string'>,\n          });\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return undefinedToAst({\n        ...args,\n        schema: schema as SchemaWithType<'undefined'>,\n      });\n    case 'unknown':\n      return unknownToAst({\n        ...args,\n        schema: schema as SchemaWithType<'unknown'>,\n      });\n    case 'void':\n      return voidToAst({\n        ...args,\n        schema: schema as SchemaWithType<'void'>,\n      });\n  }\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport { fromRef, ref, refs } from '@hey-api/codegen-core';\n\nimport { deduplicateSchema } from '~/ir/schema';\nimport type { IR } from '~/ir/types';\nimport type { SchemaWithType } from '~/plugins';\nimport { maybeBigInt } from '~/plugins/shared/utils/coerce';\nimport { $ } from '~/ts-dsl';\nimport { applyNaming } from '~/utils/naming';\nimport { pathToJsonPointer, refToName } from '~/utils/ref';\n\nimport { identifiers } from '../constants';\nimport { exportAst } from '../shared/export';\nimport { getZodModule } from '../shared/module';\nimport { irOperationToAst } from '../shared/operation';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ZodPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport const irSchemaToAst = ({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast => {\n  let ast: Partial<Ast> = {};\n\n  const z = plugin.referenceSymbol({\n    category: 'external',\n    resource: 'zod.z',\n  });\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'zod',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      ast.expression = $(refSymbol);\n    } else {\n      ast.expression = $(z)\n        .attr(identifiers.lazy)\n        .call($.func().returns('any').do($(refSymbol).return()));\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression['~ref'] = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.hasLazyExpression = typeAst.hasLazyExpression;\n\n    if (plugin.config.metadata && schema.description) {\n      ast.expression = ast.expression\n        .attr(identifiers.register)\n        .call(\n          $(z).attr(identifiers.globalRegistry),\n          $.object()\n            .pretty()\n            .prop('description', $.literal(schema.description)),\n        );\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemSchemas = schema.items.map((item, index) =>\n        irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: ref([...fromRef(state.path), 'items', index]),\n          },\n        }),\n      );\n\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items[0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.merge()` as that does not exist on `.union()` and non-object schemas.\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          ast.expression = $(z)\n            .attr(identifiers.intersection)\n            .call(...itemSchemas.map((schema) => schema.expression));\n        } else {\n          ast.expression = itemSchemas[0]!.expression;\n          itemSchemas.slice(1).forEach((schema) => {\n            ast.expression = ast\n              .expression!.attr(identifiers.and)\n              .call(\n                schema.hasLazyExpression\n                  ? $(z)\n                      .attr(identifiers.lazy)\n                      .call($.func().do(schema.expression.return()))\n                  : schema.expression,\n              );\n          });\n        }\n      } else {\n        ast.expression = $(z)\n          .attr(identifiers.union)\n          .call(\n            $.array()\n              .pretty()\n              .elements(...itemSchemas.map((schema) => schema.expression)),\n          );\n      }\n    } else {\n      ast = irSchemaToAst({\n        plugin,\n        schema,\n        state,\n      });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n  }\n\n  if (ast.expression) {\n    if (schema.accessScope === 'read') {\n      ast.expression = ast.expression.attr(identifiers.readonly).call();\n    }\n\n    if (optional) {\n      ast.expression = $(z).attr(identifiers.optional).call(ast.expression);\n      ast.typeName = identifiers.ZodOptional;\n    }\n\n    if (schema.default !== undefined) {\n      ast.expression = ast.expression\n        .attr(identifiers.default)\n        .call(\n          schema.type === 'integer' || schema.type === 'number'\n            ? maybeBigInt(schema.default, schema.format)\n            : $.fromValue(schema.default),\n        );\n    }\n  }\n\n  return ast as Ast;\n};\n\nconst handleComponent = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void => {\n  const $ref = pathToJsonPointer(fromRef(state.path));\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.symbol(\n    applyNaming(baseName, plugin.config.definitions),\n    {\n      meta: {\n        category: 'schema',\n        path: fromRef(state.path),\n        resource: 'definition',\n        resourceId: $ref,\n        tags: fromRef(state.tags),\n        tool: 'zod',\n      },\n    },\n  );\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.symbol(\n        applyNaming(baseName, plugin.config.definitions.types.infer),\n        {\n          meta: {\n            category: 'type',\n            path: fromRef(state.path),\n            resource: 'definition',\n            resourceId: $ref,\n            tags: fromRef(state.tags),\n            tool: 'zod',\n            variant: 'infer',\n          },\n        },\n      )\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n};\n\nexport const handlerV4: ZodPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('z', {\n    external: getZodModule({ plugin }),\n    meta: {\n      category: 'external',\n      resource: 'zod.z',\n    },\n  });\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'webhook',\n    (event) => {\n      const state = refs<PluginState>({\n        hasLazyExpression: false,\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          irOperationToAst({\n            getAst: (schema, path) => {\n              const state = refs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'webhook':\n          irWebhookToAst({\n            getAst: (schema, path) => {\n              const state = refs<PluginState>({\n                hasLazyExpression: false,\n                path,\n                tags: event.tags,\n              });\n              return irSchemaToAst({ plugin, schema, state });\n            },\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n      }\n    },\n  );\n};\n","import { handlerMini } from './mini/plugin';\nimport type { ZodPlugin } from './types';\nimport { handlerV3 } from './v3/plugin';\nimport { handlerV4 } from './v4/plugin';\n\nexport const handler: ZodPlugin['Handler'] = (args) => {\n  const { plugin } = args;\n  switch (plugin.config.compatibilityVersion) {\n    case 3:\n      return handlerV3(args);\n    case 'mini':\n      return handlerMini(args);\n    case 4:\n    default:\n      return handlerV4(args);\n  }\n};\n","import colors from 'ansi-colors';\n\nimport { definePluginConfig, mappers } from '~/plugins/shared/utils/config';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { ZodPlugin } from './types';\n\ntype CompatibilityVersion = NonNullable<\n  ZodPlugin['Config']['config']['compatibilityVersion']\n>;\n\nexport const defaultConfig: ZodPlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    exportFromIndex: false,\n    metadata: false,\n  },\n  handler,\n  name: 'zod',\n  resolveConfig: (plugin, context) => {\n    const packageName = 'zod';\n    const version = context.package.getVersion(packageName);\n\n    const inferCompatibleVersion = (): CompatibilityVersion => {\n      if (version && (version.major === 4 || version.major === 3)) {\n        return version.major;\n      }\n\n      // default compatibility version\n      return 4;\n    };\n\n    const ensureCompatibleVersion = (\n      compatibilityVersion: CompatibilityVersion | undefined,\n    ): CompatibilityVersion => {\n      if (!compatibilityVersion) {\n        return inferCompatibleVersion();\n      }\n\n      if (!version) {\n        return compatibilityVersion;\n      }\n\n      if (\n        compatibilityVersion === 4 ||\n        compatibilityVersion === 3 ||\n        compatibilityVersion === 'mini'\n      ) {\n        if (!context.package.satisfies(version, '>=3.25.0 <5.0.0')) {\n          const compatibleVersion = inferCompatibleVersion();\n          console.warn(\n            `üîå ${colors.yellow('Warning:')} Installed ${colors.cyan(packageName)} ${colors.cyan(`v${version.version}`)} does not support compatibility version ${colors.yellow(String(compatibilityVersion))}, using ${colors.yellow(String(compatibleVersion))}.`,\n          );\n          return compatibleVersion;\n        }\n      }\n\n      return compatibilityVersion;\n    };\n\n    plugin.config.compatibilityVersion = ensureCompatibleVersion(\n      plugin.config.compatibilityVersion,\n    );\n\n    plugin.config.dates = context.valueToObject({\n      defaultValue: {\n        local: false,\n        offset: false,\n      },\n      value: plugin.config.dates,\n    });\n\n    plugin.config.types = context.valueToObject({\n      defaultValue: {\n        infer: {\n          case: 'PascalCase',\n          enabled: false,\n        },\n      },\n      mappers: {\n        object: (fields, defaultValue) => ({\n          ...fields,\n          infer: context.valueToObject({\n            defaultValue: {\n              ...(defaultValue.infer as Extract<\n                typeof defaultValue.infer,\n                Record<string, unknown>\n              >),\n              enabled:\n                fields.infer !== undefined\n                  ? Boolean(fields.infer)\n                  : (\n                      defaultValue.infer as Extract<\n                        typeof defaultValue.infer,\n                        Record<string, unknown>\n                      >\n                    ).enabled,\n            },\n            mappers,\n            value: fields.infer,\n          }),\n        }),\n      },\n      value: plugin.config.types,\n    });\n\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}ZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}Data',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}DataZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}Response',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}ResponseZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}WebhookRequest',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}WebhookRequestZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n  tags: ['validator'],\n};\n\n/**\n * Type helper for Zod plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Plugin } from '~/plugins';\nimport type { AngularCommonPlugin } from '~/plugins/@angular/common';\nimport { defaultConfig as angularCommon } from '~/plugins/@angular/common';\nimport type { HeyApiClientAngularPlugin } from '~/plugins/@hey-api/client-angular';\nimport { defaultConfig as heyApiClientAngular } from '~/plugins/@hey-api/client-angular';\nimport type { HeyApiClientAxiosPlugin } from '~/plugins/@hey-api/client-axios';\nimport { defaultConfig as heyApiClientAxios } from '~/plugins/@hey-api/client-axios';\nimport type { HeyApiClientFetchPlugin } from '~/plugins/@hey-api/client-fetch';\nimport { defaultConfig as heyApiClientFetch } from '~/plugins/@hey-api/client-fetch';\nimport type { HeyApiClientKyPlugin } from '~/plugins/@hey-api/client-ky';\nimport { defaultConfig as heyApiClientKy } from '~/plugins/@hey-api/client-ky';\nimport type { HeyApiClientNextPlugin } from '~/plugins/@hey-api/client-next';\nimport { defaultConfig as heyApiClientNext } from '~/plugins/@hey-api/client-next';\nimport type { HeyApiClientNuxtPlugin } from '~/plugins/@hey-api/client-nuxt';\nimport { defaultConfig as heyApiClientNuxt } from '~/plugins/@hey-api/client-nuxt';\nimport type { HeyApiClientOfetchPlugin } from '~/plugins/@hey-api/client-ofetch';\nimport { defaultConfig as heyApiClientOfetch } from '~/plugins/@hey-api/client-ofetch';\nimport type { HeyApiSchemasPlugin } from '~/plugins/@hey-api/schemas';\nimport { defaultConfig as heyApiSchemas } from '~/plugins/@hey-api/schemas';\nimport type { HeyApiSdkPlugin } from '~/plugins/@hey-api/sdk';\nimport { defaultConfig as heyApiSdk } from '~/plugins/@hey-api/sdk';\nimport type { HeyApiTransformersPlugin } from '~/plugins/@hey-api/transformers';\nimport { defaultConfig as heyApiTransformers } from '~/plugins/@hey-api/transformers';\nimport type { HeyApiTypeScriptPlugin } from '~/plugins/@hey-api/typescript';\nimport { defaultConfig as heyApiTypeScript } from '~/plugins/@hey-api/typescript';\nimport type { PiniaColadaPlugin } from '~/plugins/@pinia/colada';\nimport { defaultConfig as piniaColada } from '~/plugins/@pinia/colada';\nimport type { TanStackAngularQueryPlugin } from '~/plugins/@tanstack/angular-query-experimental';\nimport { defaultConfig as tanStackAngularQuery } from '~/plugins/@tanstack/angular-query-experimental';\nimport type { TanStackReactQueryPlugin } from '~/plugins/@tanstack/react-query';\nimport { defaultConfig as tanStackReactQuery } from '~/plugins/@tanstack/react-query';\nimport type { TanStackSolidQueryPlugin } from '~/plugins/@tanstack/solid-query';\nimport { defaultConfig as tanStackSolidQuery } from '~/plugins/@tanstack/solid-query';\nimport type { TanStackSvelteQueryPlugin } from '~/plugins/@tanstack/svelte-query';\nimport { defaultConfig as tanStackSvelteQuery } from '~/plugins/@tanstack/svelte-query';\nimport type { TanStackVueQueryPlugin } from '~/plugins/@tanstack/vue-query';\nimport { defaultConfig as tanStackVueQuery } from '~/plugins/@tanstack/vue-query';\nimport type { ArktypePlugin } from '~/plugins/arktype';\nimport { defaultConfig as arktype } from '~/plugins/arktype';\nimport type { FastifyPlugin } from '~/plugins/fastify';\nimport { defaultConfig as fastify } from '~/plugins/fastify';\nimport type { SwrPlugin } from '~/plugins/swr';\nimport { defaultConfig as swr } from '~/plugins/swr';\nimport type { PluginNames } from '~/plugins/types';\nimport type { ValibotPlugin } from '~/plugins/valibot';\nimport { defaultConfig as valibot } from '~/plugins/valibot';\nimport type { ZodPlugin } from '~/plugins/zod';\nimport { defaultConfig as zod } from '~/plugins/zod';\n\nexport interface PluginConfigMap {\n  '@angular/common': AngularCommonPlugin['Types'];\n  '@hey-api/client-angular': HeyApiClientAngularPlugin['Types'];\n  '@hey-api/client-axios': HeyApiClientAxiosPlugin['Types'];\n  '@hey-api/client-fetch': HeyApiClientFetchPlugin['Types'];\n  '@hey-api/client-ky': HeyApiClientKyPlugin['Types'];\n  '@hey-api/client-next': HeyApiClientNextPlugin['Types'];\n  '@hey-api/client-nuxt': HeyApiClientNuxtPlugin['Types'];\n  '@hey-api/client-ofetch': HeyApiClientOfetchPlugin['Types'];\n  '@hey-api/schemas': HeyApiSchemasPlugin['Types'];\n  '@hey-api/sdk': HeyApiSdkPlugin['Types'];\n  '@hey-api/transformers': HeyApiTransformersPlugin['Types'];\n  '@hey-api/typescript': HeyApiTypeScriptPlugin['Types'];\n  '@pinia/colada': PiniaColadaPlugin['Types'];\n  '@tanstack/angular-query-experimental': TanStackAngularQueryPlugin['Types'];\n  '@tanstack/react-query': TanStackReactQueryPlugin['Types'];\n  '@tanstack/solid-query': TanStackSolidQueryPlugin['Types'];\n  '@tanstack/svelte-query': TanStackSvelteQueryPlugin['Types'];\n  '@tanstack/vue-query': TanStackVueQueryPlugin['Types'];\n  arktype: ArktypePlugin['Types'];\n  fastify: FastifyPlugin['Types'];\n  swr: SwrPlugin['Types'];\n  valibot: ValibotPlugin['Types'];\n  zod: ZodPlugin['Types'];\n}\n\nexport const defaultPluginConfigs: {\n  [K in PluginNames]: Plugin.Config<PluginConfigMap[K]>;\n} = {\n  '@angular/common': angularCommon,\n  '@hey-api/client-angular': heyApiClientAngular,\n  '@hey-api/client-axios': heyApiClientAxios,\n  '@hey-api/client-fetch': heyApiClientFetch,\n  '@hey-api/client-ky': heyApiClientKy,\n  '@hey-api/client-next': heyApiClientNext,\n  '@hey-api/client-nuxt': heyApiClientNuxt,\n  '@hey-api/client-ofetch': heyApiClientOfetch,\n  '@hey-api/schemas': heyApiSchemas,\n  '@hey-api/sdk': heyApiSdk,\n  '@hey-api/transformers': heyApiTransformers,\n  '@hey-api/typescript': heyApiTypeScript,\n  '@pinia/colada': piniaColada,\n  '@tanstack/angular-query-experimental': tanStackAngularQuery,\n  '@tanstack/react-query': tanStackReactQuery,\n  '@tanstack/solid-query': tanStackSolidQuery,\n  '@tanstack/svelte-query': tanStackSvelteQuery,\n  '@tanstack/vue-query': tanStackVueQuery,\n  arktype,\n  fastify,\n  swr,\n  valibot,\n  zod,\n};\n","import { defaultPluginConfigs } from '~/plugins/config';\nimport type {\n  AnyPluginName,\n  PluginContext,\n  PluginNames,\n} from '~/plugins/types';\nimport type { Config, UserConfig } from '~/types/config';\n\nimport { valueToObject } from './utils/config';\nimport { packageFactory } from './utils/package';\n\n/**\n * Default plugins used to generate artifacts if plugins aren't specified.\n */\nexport const defaultPlugins = [\n  '@hey-api/typescript',\n  '@hey-api/sdk',\n] as const satisfies ReadonlyArray<PluginNames>;\n\nconst getPluginsConfig = ({\n  dependencies,\n  userPlugins,\n  userPluginsConfig,\n}: {\n  dependencies: Record<string, string>;\n  userPlugins: ReadonlyArray<AnyPluginName>;\n  userPluginsConfig: Config['plugins'];\n}): Pick<Config, 'plugins' | 'pluginOrder'> => {\n  const circularReferenceTracker = new Set<AnyPluginName>();\n  const pluginOrder = new Set<AnyPluginName>();\n  const plugins: Config['plugins'] = {};\n\n  const dfs = (name: AnyPluginName) => {\n    if (circularReferenceTracker.has(name)) {\n      throw new Error(`Circular reference detected at '${name}'`);\n    }\n\n    if (pluginOrder.has(name)) {\n      return;\n    }\n\n    circularReferenceTracker.add(name);\n\n    const defaultPlugin = defaultPluginConfigs[name as PluginNames];\n    const userPlugin = userPluginsConfig[name as PluginNames];\n\n    if (!defaultPlugin && !userPlugin) {\n      throw new Error(\n        `unknown plugin dependency \"${name}\" - do you need to register a custom plugin with this name?`,\n      );\n    }\n\n    const plugin = {\n      ...defaultPlugin,\n      ...userPlugin,\n      config: {\n        ...defaultPlugin?.config,\n        ...userPlugin?.config,\n      },\n      dependencies: new Set([\n        ...(defaultPlugin?.dependencies || []),\n        ...(userPlugin?.dependencies || []),\n      ]),\n    };\n\n    if (plugin.resolveConfig) {\n      const context: PluginContext = {\n        package: packageFactory(dependencies),\n        pluginByTag: (tag, props = {}) => {\n          const { defaultPlugin, errorMessage } = props;\n\n          for (const userPlugin of userPlugins) {\n            const defaultConfig =\n              defaultPluginConfigs[userPlugin as PluginNames] ||\n              userPluginsConfig[userPlugin as PluginNames];\n            if (\n              defaultConfig &&\n              defaultConfig.tags?.includes(tag) &&\n              userPlugin !== name\n            ) {\n              return userPlugin as any;\n            }\n          }\n\n          if (defaultPlugin) {\n            const defaultConfig =\n              defaultPluginConfigs[defaultPlugin as PluginNames] ||\n              userPluginsConfig[defaultPlugin as PluginNames];\n            if (\n              defaultConfig &&\n              defaultConfig.tags?.includes(tag) &&\n              defaultPlugin !== name\n            ) {\n              return defaultPlugin;\n            }\n          }\n\n          throw new Error(\n            errorMessage ||\n              `missing plugin - no plugin with tag \"${tag}\" found`,\n          );\n        },\n        valueToObject,\n      };\n      // @ts-expect-error\n      plugin.resolveConfig(plugin, context);\n    }\n\n    for (const dependency of plugin.dependencies) {\n      dfs(dependency);\n    }\n\n    circularReferenceTracker.delete(name);\n    pluginOrder.add(name);\n\n    // @ts-expect-error\n    plugins[name] = plugin;\n  };\n\n  for (const name of userPlugins) {\n    dfs(name);\n  }\n\n  return {\n    pluginOrder: Array.from(pluginOrder) as ReadonlyArray<PluginNames>,\n    plugins,\n  };\n};\n\nconst isPluginClient = (plugin: Required<UserConfig>['plugins'][number]) => {\n  if (typeof plugin === 'string') {\n    return plugin.startsWith('@hey-api/client');\n  }\n\n  return (\n    plugin.name.startsWith('@hey-api/client') ||\n    // @ts-expect-error\n    (plugin.tags && plugin.tags.includes('client'))\n  );\n};\n\nexport const getPlugins = ({\n  dependencies,\n  userConfig,\n}: {\n  dependencies: Record<string, string>;\n  userConfig: UserConfig;\n}): Pick<Config, 'plugins' | 'pluginOrder'> => {\n  const userPluginsConfig: Config['plugins'] = {};\n\n  let definedPlugins: UserConfig['plugins'] = defaultPlugins;\n\n  if (userConfig.plugins) {\n    userConfig.plugins = userConfig.plugins.filter(\n      (plugin) =>\n        (typeof plugin === 'string' && plugin) ||\n        (typeof plugin !== 'string' && plugin.name),\n    );\n    if (\n      userConfig.plugins.length === 1 &&\n      isPluginClient(userConfig.plugins[0]!)\n    ) {\n      definedPlugins = [...defaultPlugins, ...userConfig.plugins];\n    } else {\n      definedPlugins = userConfig.plugins;\n    }\n  }\n\n  const userPlugins = definedPlugins\n    .map((plugin) => {\n      if (typeof plugin === 'string') {\n        return plugin;\n      }\n\n      const pluginName = plugin.name;\n\n      if (pluginName) {\n        // @ts-expect-error\n        if (plugin.handler) {\n          // @ts-expect-error\n          userPluginsConfig[pluginName] = plugin;\n        } else {\n          // @ts-expect-error\n          userPluginsConfig[pluginName] = {\n            config: { ...plugin },\n          };\n          // @ts-expect-error\n          delete userPluginsConfig[pluginName]!.config.name;\n        }\n      }\n\n      return pluginName;\n    })\n    .filter(Boolean);\n\n  return getPluginsConfig({ dependencies, userPlugins, userPluginsConfig });\n};\n","import path from 'node:path';\n\nimport colors from 'ansi-colors';\n\nimport { ConfigError } from '~/error';\nimport type { Config, UserConfig } from '~/types/config';\nimport type { ArrayOnly } from '~/types/utils';\nimport type { Logger } from '~/utils/logger';\n\nimport { getInput } from './input';\nimport { getLogs } from './logs';\nimport { mergeConfigs } from './merge';\nimport { getOutput } from './output';\nimport { getProjectDependencies } from './packages';\nimport { getParser } from './parser';\nimport { getPlugins } from './plugins';\n\ntype ConfigResult = {\n  config: Config;\n  errors: ReadonlyArray<Error>;\n  jobIndex: number;\n};\n\nexport type Configs = {\n  dependencies: Record<string, string>;\n  results: ReadonlyArray<ConfigResult>;\n};\n\n/**\n * Detect if the current session is interactive based on TTY status and environment variables.\n * This is used as a fallback when the user doesn't explicitly set the interactive option.\n * @internal\n */\nexport const detectInteractiveSession = (): boolean =>\n  Boolean(\n    process.stdin.isTTY &&\n      process.stdout.isTTY &&\n      !process.env.CI &&\n      !process.env.NO_INTERACTIVE &&\n      !process.env.NO_INTERACTION,\n  );\n\n/**\n * @internal\n */\nexport const initConfigs = async ({\n  logger,\n  userConfigs,\n}: {\n  logger: Logger;\n  userConfigs: ReadonlyArray<UserConfig>;\n}): Promise<Configs> => {\n  const configs: Array<UserConfig> = [];\n  let dependencies: Record<string, string> = {};\n\n  const eventLoad = logger.timeEvent('load');\n  for (const userConfig of userConfigs) {\n    let configurationFile: string | undefined = undefined;\n    if (userConfig?.configFile) {\n      const parts = userConfig.configFile.split('.');\n      configurationFile = parts.slice(0, parts.length - 1).join('.');\n    }\n\n    const eventC12 = logger.timeEvent('c12');\n    // c12 is ESM-only since v3\n    const { loadConfig } = await import('c12');\n    const { config: configFromFile, configFile: loadedConfigFile } =\n      await loadConfig<UserConfig>({\n        configFile: configurationFile,\n        name: 'openapi-ts',\n      });\n    eventC12.timeEnd();\n\n    if (!Object.keys(dependencies).length) {\n      // TODO: handle dependencies for multiple configs properly?\n      dependencies = getProjectDependencies(\n        Object.keys(configFromFile).length ? loadedConfigFile : undefined,\n      );\n    }\n\n    const mergedConfigs =\n      configFromFile instanceof Array\n        ? configFromFile.map((config) => mergeConfigs(config, userConfig))\n        : [mergeConfigs(configFromFile, userConfig)];\n\n    for (const mergedConfig of mergedConfigs) {\n      const input = getInput(mergedConfig);\n\n      if (mergedConfig.output instanceof Array) {\n        const countInputs = input.length;\n        const countOutputs = mergedConfig.output.length;\n        if (countOutputs > 1) {\n          if (countInputs !== countOutputs) {\n            console.warn(\n              `‚öôÔ∏è ${colors.yellow('Warning:')} You provided ${colors.cyan(String(countInputs))} ${colors.cyan(countInputs === 1 ? 'input' : 'inputs')} and ${colors.yellow(String(countOutputs))} ${colors.yellow('outputs')}. This is probably not what you want as it will produce identical output in multiple locations. You most likely want to provide a single output or the same number of outputs as inputs.`,\n            );\n            for (const output of mergedConfig.output) {\n              configs.push({ ...mergedConfig, input, output });\n            }\n          } else {\n            mergedConfig.output.forEach((output, index) => {\n              configs.push({ ...mergedConfig, input: input[index]!, output });\n            });\n          }\n        } else {\n          configs.push({\n            ...mergedConfig,\n            input,\n            output: mergedConfig.output[0] ?? '',\n          });\n        }\n      } else {\n        configs.push({ ...mergedConfig, input });\n      }\n    }\n  }\n  eventLoad.timeEnd();\n\n  const results: Array<ArrayOnly<ConfigResult>> = [];\n\n  const eventBuild = logger.timeEvent('build');\n  for (const userConfig of configs) {\n    const logs = getLogs(userConfig);\n    const input = getInput(userConfig);\n    const output = getOutput(userConfig);\n    const parser = getParser(userConfig);\n\n    const errors: Array<Error> = [];\n\n    if (!input.length) {\n      errors.push(\n        new ConfigError(\n          'missing input - which OpenAPI specification should we use to generate your output?',\n        ),\n      );\n    }\n\n    if (!output.path) {\n      errors.push(\n        new ConfigError(\n          'missing output - where should we generate your output?',\n        ),\n      );\n    }\n\n    output.path = path.resolve(process.cwd(), output.path);\n\n    let plugins: Pick<Config, 'plugins' | 'pluginOrder'>;\n\n    try {\n      plugins = getPlugins({ dependencies, userConfig });\n    } catch (error) {\n      errors.push(error);\n      plugins = {\n        pluginOrder: [],\n        plugins: {},\n      };\n    }\n\n    const config: Config = {\n      configFile: userConfig.configFile ?? '',\n      dryRun: userConfig.dryRun ?? false,\n      input,\n      interactive: userConfig.interactive ?? detectInteractiveSession(),\n      logs,\n      output,\n      parser,\n      pluginOrder: plugins.pluginOrder,\n      plugins: plugins.plugins,\n    };\n\n    const jobIndex = results.length;\n\n    if (logs.level === 'debug') {\n      const jobPrefix = colors.gray(`[Job ${jobIndex + 1}] `);\n      console.warn(`${jobPrefix}${colors.cyan('config:')}`, config);\n    }\n\n    results.push({ config, errors, jobIndex });\n  }\n  eventBuild.timeEnd();\n\n  return { dependencies, results };\n};\n","type Slot = 'body' | 'headers' | 'path' | 'query';\n\nexport type Field =\n  | {\n      in: Exclude<Slot, 'body'>;\n      /**\n       * Field name. This is the name we want the user to see and use.\n       */\n      key: string;\n      /**\n       * Field mapped name. This is the name we want to use in the request.\n       * If omitted, we use the same value as `key`.\n       */\n      map?: string;\n    }\n  | {\n      in: Extract<Slot, 'body'>;\n      /**\n       * Key isn't required for bodies.\n       */\n      key?: string;\n      map?: string;\n    }\n  | {\n      /**\n       * Field name. This is the name we want the user to see and use.\n       */\n      key: string;\n      /**\n       * Field mapped name. This is the name we want to use in the request.\n       * If `in` is omitted, `map` aliases `key` to the transport layer.\n       */\n      map: Slot;\n    };\n\nexport interface Fields {\n  allowExtra?: Partial<Record<Slot, boolean>>;\n  args?: ReadonlyArray<Field>;\n}\n\nexport type FieldsConfig = ReadonlyArray<Field | Fields>;\n\nconst extraPrefixesMap: Record<string, Slot> = {\n  $body_: 'body',\n  $headers_: 'headers',\n  $path_: 'path',\n  $query_: 'query',\n};\nconst extraPrefixes = Object.entries(extraPrefixesMap);\n\ntype KeyMap = Map<\n  string,\n  | {\n      in: Slot;\n      map?: string;\n    }\n  | {\n      in?: never;\n      map: Slot;\n    }\n>;\n\nconst buildKeyMap = (fields: FieldsConfig, map?: KeyMap): KeyMap => {\n  if (!map) {\n    map = new Map();\n  }\n\n  for (const config of fields) {\n    if ('in' in config) {\n      if (config.key) {\n        map.set(config.key, {\n          in: config.in,\n          map: config.map,\n        });\n      }\n    } else if ('key' in config) {\n      map.set(config.key, {\n        map: config.map,\n      });\n    } else if (config.args) {\n      buildKeyMap(config.args, map);\n    }\n  }\n\n  return map;\n};\n\ninterface Params {\n  body: unknown;\n  headers: Record<string, unknown>;\n  path: Record<string, unknown>;\n  query: Record<string, unknown>;\n}\n\nconst stripEmptySlots = (params: Params) => {\n  for (const [slot, value] of Object.entries(params)) {\n    if (value && typeof value === 'object' && !Object.keys(value).length) {\n      delete params[slot as Slot];\n    }\n  }\n};\n\nexport const buildClientParams = (\n  args: ReadonlyArray<unknown>,\n  fields: FieldsConfig,\n) => {\n  const params: Params = {\n    body: {},\n    headers: {},\n    path: {},\n    query: {},\n  };\n\n  const map = buildKeyMap(fields);\n\n  let config: FieldsConfig[number] | undefined;\n\n  for (const [index, arg] of args.entries()) {\n    if (fields[index]) {\n      config = fields[index];\n    }\n\n    if (!config) {\n      continue;\n    }\n\n    if ('in' in config) {\n      if (config.key) {\n        const field = map.get(config.key)!;\n        const name = field.map || config.key;\n        if (field.in) {\n          (params[field.in] as Record<string, unknown>)[name] = arg;\n        }\n      } else {\n        params.body = arg;\n      }\n    } else {\n      for (const [key, value] of Object.entries(arg ?? {})) {\n        const field = map.get(key);\n\n        if (field) {\n          if (field.in) {\n            const name = field.map || key;\n            (params[field.in] as Record<string, unknown>)[name] = value;\n          } else {\n            params[field.map] = value;\n          }\n        } else {\n          const extra = extraPrefixes.find(([prefix]) =>\n            key.startsWith(prefix),\n          );\n\n          if (extra) {\n            const [prefix, slot] = extra;\n            (params[slot] as Record<string, unknown>)[\n              key.slice(prefix.length)\n            ] = value;\n          } else if ('allowExtra' in config && config.allowExtra) {\n            for (const [slot, allowed] of Object.entries(config.allowExtra)) {\n              if (allowed) {\n                (params[slot as Slot] as Record<string, unknown>)[key] = value;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  stripEmptySlots(params);\n\n  return params;\n};\n","interface SerializeOptions<T>\n  extends SerializePrimitiveOptions,\n    SerializerOptions<T> {}\n\ninterface SerializePrimitiveOptions {\n  allowReserved?: boolean;\n  name: string;\n}\n\nexport interface SerializerOptions<T> {\n  /**\n   * @default true\n   */\n  explode: boolean;\n  style: T;\n}\n\nexport type ArrayStyle = 'form' | 'spaceDelimited' | 'pipeDelimited';\nexport type ArraySeparatorStyle = ArrayStyle | MatrixStyle;\ntype MatrixStyle = 'label' | 'matrix' | 'simple';\nexport type ObjectStyle = 'form' | 'deepObject';\ntype ObjectSeparatorStyle = ObjectStyle | MatrixStyle;\n\ninterface SerializePrimitiveParam extends SerializePrimitiveOptions {\n  value: string;\n}\n\nexport const separatorArrayExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const separatorArrayNoExplode = (style: ArraySeparatorStyle) => {\n  switch (style) {\n    case 'form':\n      return ',';\n    case 'pipeDelimited':\n      return '|';\n    case 'spaceDelimited':\n      return '%20';\n    default:\n      return ',';\n  }\n};\n\nexport const separatorObjectExplode = (style: ObjectSeparatorStyle) => {\n  switch (style) {\n    case 'label':\n      return '.';\n    case 'matrix':\n      return ';';\n    case 'simple':\n      return ',';\n    default:\n      return '&';\n  }\n};\n\nexport const serializeArrayParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n}: SerializeOptions<ArraySeparatorStyle> & {\n  value: unknown[];\n}) => {\n  if (!explode) {\n    const joinedValues = (\n      allowReserved ? value : value.map((v) => encodeURIComponent(v as string))\n    ).join(separatorArrayNoExplode(style));\n    switch (style) {\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      case 'simple':\n        return joinedValues;\n      default:\n        return `${name}=${joinedValues}`;\n    }\n  }\n\n  const separator = separatorArrayExplode(style);\n  const joinedValues = value\n    .map((v) => {\n      if (style === 'label' || style === 'simple') {\n        return allowReserved ? v : encodeURIComponent(v as string);\n      }\n\n      return serializePrimitiveParam({\n        allowReserved,\n        name,\n        value: v as string,\n      });\n    })\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n\nexport const serializePrimitiveParam = ({\n  allowReserved,\n  name,\n  value,\n}: SerializePrimitiveParam) => {\n  if (value === undefined || value === null) {\n    return '';\n  }\n\n  if (typeof value === 'object') {\n    throw new Error(\n      'Deeply-nested arrays/objects aren‚Äôt supported. Provide your own `querySerializer()` to handle these.',\n    );\n  }\n\n  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;\n};\n\nexport const serializeObjectParam = ({\n  allowReserved,\n  explode,\n  name,\n  style,\n  value,\n  valueOnly,\n}: SerializeOptions<ObjectSeparatorStyle> & {\n  value: Record<string, unknown> | Date;\n  valueOnly?: boolean;\n}) => {\n  if (value instanceof Date) {\n    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;\n  }\n\n  if (style !== 'deepObject' && !explode) {\n    let values: string[] = [];\n    Object.entries(value).forEach(([key, v]) => {\n      values = [\n        ...values,\n        key,\n        allowReserved ? (v as string) : encodeURIComponent(v as string),\n      ];\n    });\n    const joinedValues = values.join(',');\n    switch (style) {\n      case 'form':\n        return `${name}=${joinedValues}`;\n      case 'label':\n        return `.${joinedValues}`;\n      case 'matrix':\n        return `;${name}=${joinedValues}`;\n      default:\n        return joinedValues;\n    }\n  }\n\n  const separator = separatorObjectExplode(style);\n  const joinedValues = Object.entries(value)\n    .map(([key, v]) =>\n      serializePrimitiveParam({\n        allowReserved,\n        name: style === 'deepObject' ? `${name}[${key}]` : key,\n        value: v as string,\n      }),\n    )\n    .join(separator);\n  return style === 'label' || style === 'matrix'\n    ? separator + joinedValues\n    : joinedValues;\n};\n","import { getAuthToken } from '../../client-core/bundle/auth';\nimport type { QuerySerializerOptions } from '../../client-core/bundle/bodySerializer';\nimport { jsonBodySerializer } from '../../client-core/bundle/bodySerializer';\nimport {\n  serializeArrayParam,\n  serializeObjectParam,\n  serializePrimitiveParam,\n} from '../../client-core/bundle/pathSerializer';\nimport { getUrl } from '../../client-core/bundle/utils';\nimport type { Client, ClientOptions, Config, RequestOptions } from './types';\n\nexport const createQuerySerializer = <T = unknown>({\n  parameters = {},\n  ...args\n}: QuerySerializerOptions = {}) => {\n  const querySerializer = (queryParams: T) => {\n    const search: string[] = [];\n    if (queryParams && typeof queryParams === 'object') {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n\n        if (value === undefined || value === null) {\n          continue;\n        }\n\n        const options = parameters[name] || args;\n\n        if (Array.isArray(value)) {\n          const serializedArray = serializeArrayParam({\n            allowReserved: options.allowReserved,\n            explode: true,\n            name,\n            style: 'form',\n            value,\n            ...options.array,\n          });\n          if (serializedArray) search.push(serializedArray);\n        } else if (typeof value === 'object') {\n          const serializedObject = serializeObjectParam({\n            allowReserved: options.allowReserved,\n            explode: true,\n            name,\n            style: 'deepObject',\n            value: value as Record<string, unknown>,\n            ...options.object,\n          });\n          if (serializedObject) search.push(serializedObject);\n        } else {\n          const serializedPrimitive = serializePrimitiveParam({\n            allowReserved: options.allowReserved,\n            name,\n            value: value as string,\n          });\n          if (serializedPrimitive) search.push(serializedPrimitive);\n        }\n      }\n    }\n    return search.join('&');\n  };\n  return querySerializer;\n};\n\n/**\n * Infers parseAs value from provided Content-Type header.\n */\nexport const getParseAs = (\n  contentType: string | null,\n): Exclude<Config['parseAs'], 'auto'> => {\n  if (!contentType) {\n    // If no Content-Type header is provided, the best we can do is return the raw response body,\n    // which is effectively the same as the 'stream' option.\n    return 'stream';\n  }\n\n  const cleanContent = contentType.split(';')[0]?.trim();\n\n  if (!cleanContent) {\n    return;\n  }\n\n  if (\n    cleanContent.startsWith('application/json') ||\n    cleanContent.endsWith('+json')\n  ) {\n    return 'json';\n  }\n\n  if (cleanContent === 'multipart/form-data') {\n    return 'formData';\n  }\n\n  if (\n    ['application/', 'audio/', 'image/', 'video/'].some((type) =>\n      cleanContent.startsWith(type),\n    )\n  ) {\n    return 'blob';\n  }\n\n  if (cleanContent.startsWith('text/')) {\n    return 'text';\n  }\n\n  return;\n};\n\nconst checkForExistence = (\n  options: Pick<RequestOptions, 'auth' | 'query'> & {\n    headers: Headers;\n  },\n  name?: string,\n): boolean => {\n  if (!name) {\n    return false;\n  }\n  if (\n    options.headers.has(name) ||\n    options.query?.[name] ||\n    options.headers.get('Cookie')?.includes(`${name}=`)\n  ) {\n    return true;\n  }\n  return false;\n};\n\nexport const setAuthParams = async ({\n  security,\n  ...options\n}: Pick<Required<RequestOptions>, 'security'> &\n  Pick<RequestOptions, 'auth' | 'query'> & {\n    headers: Headers;\n  }) => {\n  for (const auth of security) {\n    if (checkForExistence(options, auth.name)) {\n      continue;\n    }\n\n    const token = await getAuthToken(auth, options.auth);\n\n    if (!token) {\n      continue;\n    }\n\n    const name = auth.name ?? 'Authorization';\n\n    switch (auth.in) {\n      case 'query':\n        if (!options.query) {\n          options.query = {};\n        }\n        options.query[name] = token;\n        break;\n      case 'cookie':\n        options.headers.append('Cookie', `${name}=${token}`);\n        break;\n      case 'header':\n      default:\n        options.headers.set(name, token);\n        break;\n    }\n  }\n};\n\nexport const buildUrl: Client['buildUrl'] = (options) =>\n  getUrl({\n    baseUrl: options.baseUrl as string,\n    path: options.path,\n    query: options.query,\n    querySerializer:\n      typeof options.querySerializer === 'function'\n        ? options.querySerializer\n        : createQuerySerializer(options.querySerializer),\n    url: options.url,\n  });\n\nexport const mergeConfigs = (a: Config, b: Config): Config => {\n  const config = { ...a, ...b };\n  if (config.baseUrl?.endsWith('/')) {\n    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);\n  }\n  config.headers = mergeHeaders(a.headers, b.headers);\n  return config;\n};\n\nconst headersEntries = (headers: Headers): Array<[string, string]> => {\n  const entries: Array<[string, string]> = [];\n  headers.forEach((value, key) => {\n    entries.push([key, value]);\n  });\n  return entries;\n};\n\nexport const mergeHeaders = (\n  ...headers: Array<Required<Config>['headers'] | undefined>\n): Headers => {\n  const mergedHeaders = new Headers();\n  for (const header of headers) {\n    if (!header) {\n      continue;\n    }\n\n    const iterator =\n      header instanceof Headers\n        ? headersEntries(header)\n        : Object.entries(header);\n\n    for (const [key, value] of iterator) {\n      if (value === null) {\n        mergedHeaders.delete(key);\n      } else if (Array.isArray(value)) {\n        for (const v of value) {\n          mergedHeaders.append(key, v as string);\n        }\n      } else if (value !== undefined) {\n        // assume object headers are meant to be JSON stringified, i.e. their\n        // content value in OpenAPI specification is 'application/json'\n        mergedHeaders.set(\n          key,\n          typeof value === 'object' ? JSON.stringify(value) : (value as string),\n        );\n      }\n    }\n  }\n  return mergedHeaders;\n};\n\ntype ErrInterceptor<Err, Res, Req, Options> = (\n  error: Err,\n  response: Res,\n  request: Req,\n  options: Options,\n) => Err | Promise<Err>;\n\ntype ReqInterceptor<Req, Options> = (\n  request: Req,\n  options: Options,\n) => Req | Promise<Req>;\n\ntype ResInterceptor<Res, Req, Options> = (\n  response: Res,\n  request: Req,\n  options: Options,\n) => Res | Promise<Res>;\n\nclass Interceptors<Interceptor> {\n  fns: Array<Interceptor | null> = [];\n\n  clear(): void {\n    this.fns = [];\n  }\n\n  eject(id: number | Interceptor): void {\n    const index = this.getInterceptorIndex(id);\n    if (this.fns[index]) {\n      this.fns[index] = null;\n    }\n  }\n\n  exists(id: number | Interceptor): boolean {\n    const index = this.getInterceptorIndex(id);\n    return Boolean(this.fns[index]);\n  }\n\n  getInterceptorIndex(id: number | Interceptor): number {\n    if (typeof id === 'number') {\n      return this.fns[id] ? id : -1;\n    }\n    return this.fns.indexOf(id);\n  }\n\n  update(\n    id: number | Interceptor,\n    fn: Interceptor,\n  ): number | Interceptor | false {\n    const index = this.getInterceptorIndex(id);\n    if (this.fns[index]) {\n      this.fns[index] = fn;\n      return id;\n    }\n    return false;\n  }\n\n  use(fn: Interceptor): number {\n    this.fns.push(fn);\n    return this.fns.length - 1;\n  }\n}\n\nexport interface Middleware<Req, Res, Err, Options> {\n  error: Interceptors<ErrInterceptor<Err, Res, Req, Options>>;\n  request: Interceptors<ReqInterceptor<Req, Options>>;\n  response: Interceptors<ResInterceptor<Res, Req, Options>>;\n}\n\nexport const createInterceptors = <Req, Res, Err, Options>(): Middleware<\n  Req,\n  Res,\n  Err,\n  Options\n> => ({\n  error: new Interceptors<ErrInterceptor<Err, Res, Req, Options>>(),\n  request: new Interceptors<ReqInterceptor<Req, Options>>(),\n  response: new Interceptors<ResInterceptor<Res, Req, Options>>(),\n});\n\nconst defaultQuerySerializer = createQuerySerializer({\n  allowReserved: false,\n  array: {\n    explode: true,\n    style: 'form',\n  },\n  object: {\n    explode: true,\n    style: 'deepObject',\n  },\n});\n\nconst defaultHeaders = {\n  'Content-Type': 'application/json',\n};\n\nexport const createConfig = <T extends ClientOptions = ClientOptions>(\n  override: Config<Omit<ClientOptions, keyof T> & T> = {},\n): Config<Omit<ClientOptions, keyof T> & T> => ({\n  ...jsonBodySerializer,\n  headers: defaultHeaders,\n  parseAs: 'auto',\n  querySerializer: defaultQuerySerializer,\n  ...override,\n});\n","import { getResolvedInput, sendRequest } from '@hey-api/json-schema-ref-parser';\n\nimport { mergeHeaders } from '~/plugins/@hey-api/client-fetch/bundle';\nimport type { Input } from '~/types/input';\nimport type { WatchValues } from '~/types/types';\n\ntype SpecResponse = {\n  arrayBuffer: ArrayBuffer | undefined;\n  error?: never;\n  resolvedInput: ReturnType<typeof getResolvedInput>;\n  response?: never;\n};\n\ntype SpecError = {\n  arrayBuffer?: never;\n  error: 'not-modified' | 'not-ok';\n  resolvedInput?: never;\n  response: Response;\n};\n\n/**\n * @internal\n */\nexport const getSpec = async ({\n  fetchOptions,\n  inputPath,\n  timeout,\n  watch,\n}: {\n  fetchOptions?: RequestInit;\n  inputPath: Input['path'];\n  timeout: number | undefined;\n  watch: WatchValues;\n}): Promise<SpecResponse | SpecError> => {\n  const resolvedInput = getResolvedInput({ pathOrUrlOrSchema: inputPath });\n\n  let arrayBuffer: ArrayBuffer | undefined;\n  // boolean signals whether the file has **definitely** changed\n  let hasChanged: boolean | undefined;\n  let response: Response | undefined;\n\n  if (resolvedInput.type === 'url') {\n    // do NOT send HEAD request on first run or if unsupported\n    if (watch.lastValue && watch.isHeadMethodSupported !== false) {\n      try {\n        const request = await sendRequest({\n          fetchOptions: {\n            method: 'HEAD',\n            ...fetchOptions,\n            headers: mergeHeaders(fetchOptions?.headers, watch.headers),\n          },\n          timeout,\n          url: resolvedInput.path,\n        });\n\n        if (request.response.status >= 300) {\n          return {\n            error: 'not-ok',\n            response: request.response,\n          };\n        }\n\n        response = request.response;\n      } catch (error) {\n        return {\n          error: 'not-ok',\n          response: new Response(error.message),\n        };\n      }\n\n      if (!response.ok && watch.isHeadMethodSupported) {\n        // assume the server is no longer running\n        // do nothing, it might be restarted later\n        return {\n          error: 'not-ok',\n          response,\n        };\n      }\n\n      if (watch.isHeadMethodSupported === undefined) {\n        watch.isHeadMethodSupported = response.ok;\n      }\n\n      if (response.status === 304) {\n        return {\n          error: 'not-modified',\n          response,\n        };\n      }\n\n      if (hasChanged === undefined) {\n        const eTag = response.headers.get('ETag');\n        if (eTag) {\n          hasChanged = eTag !== watch.headers.get('If-None-Match');\n\n          if (hasChanged) {\n            watch.headers.set('If-None-Match', eTag);\n          }\n        }\n      }\n\n      if (hasChanged === undefined) {\n        const lastModified = response.headers.get('Last-Modified');\n        if (lastModified) {\n          hasChanged = lastModified !== watch.headers.get('If-Modified-Since');\n\n          if (hasChanged) {\n            watch.headers.set('If-Modified-Since', lastModified);\n          }\n        }\n      }\n\n      // we definitely know the input has not changed\n      if (hasChanged === false) {\n        return {\n          error: 'not-modified',\n          response,\n        };\n      }\n    }\n\n    try {\n      const request = await sendRequest({\n        fetchOptions: {\n          method: 'GET',\n          ...fetchOptions,\n        },\n        timeout,\n        url: resolvedInput.path,\n      });\n\n      if (request.response.status >= 300) {\n        return {\n          error: 'not-ok',\n          response: request.response,\n        };\n      }\n\n      response = request.response;\n    } catch (error) {\n      return {\n        error: 'not-ok',\n        response: new Response(error.message),\n      };\n    }\n\n    if (!response.ok) {\n      // assume the server is no longer running\n      // do nothing, it might be restarted later\n      return {\n        error: 'not-ok',\n        response,\n      };\n    }\n\n    arrayBuffer = response.body\n      ? await response.arrayBuffer()\n      : new ArrayBuffer(0);\n\n    if (hasChanged === undefined) {\n      const content = new TextDecoder().decode(arrayBuffer);\n      hasChanged = content !== watch.lastValue;\n      watch.lastValue = content;\n    }\n  } else {\n    // we do not support watch mode for files or raw spec data\n    if (!watch.lastValue) {\n      watch.lastValue = resolvedInput.type;\n    } else {\n      hasChanged = false;\n    }\n  }\n\n  if (hasChanged === false) {\n    return {\n      error: 'not-modified',\n      response: response!,\n    };\n  }\n\n  return {\n    arrayBuffer,\n    resolvedInput,\n  };\n};\n","export class MinHeap {\n  private heap: Array<string> = [];\n\n  constructor(public declIndex: Map<string, number>) {}\n\n  isEmpty(): boolean {\n    return !this.heap.length;\n  }\n\n  pop(): string | undefined {\n    const [top] = this.heap;\n    if (!this.heap.length) return;\n    const last = this.heap.pop()!;\n    if (!this.heap.length) return top;\n    this.heap[0] = last;\n    this.sinkDown(0);\n    return top;\n  }\n\n  push(item: string): void {\n    this.heap.push(item);\n    this.bubbleUp(this.heap.length - 1);\n  }\n\n  private bubbleUp(index: number): void {\n    const heap = this.heap;\n    while (index > 0) {\n      const parent = Math.floor((index - 1) / 2);\n      const parentVal = heap[parent]!;\n      const curVal = heap[index]!;\n      if (this.declIndex.get(parentVal)! <= this.declIndex.get(curVal)!) break;\n      heap[parent] = curVal;\n      heap[index] = parentVal;\n      index = parent;\n    }\n  }\n\n  private sinkDown(index: number): void {\n    const heap = this.heap;\n    const len = heap.length;\n    while (true) {\n      const left = 2 * index + 1;\n      const right = 2 * index + 2;\n      let smallest = index;\n      if (left < len) {\n        const leftVal = heap[left]!;\n        const smallestVal = heap[smallest]!;\n        if (this.declIndex.get(leftVal)! < this.declIndex.get(smallestVal)!)\n          smallest = left;\n      }\n      if (right < len) {\n        const rightVal = heap[right]!;\n        const smallestVal = heap[smallest]!;\n        if (this.declIndex.get(rightVal)! < this.declIndex.get(smallestVal)!)\n          smallest = right;\n      }\n      if (smallest === index) break;\n      const tmp = heap[smallest]!;\n      heap[smallest] = heap[index]!;\n      heap[index] = tmp;\n      index = smallest;\n    }\n  }\n}\n","import { MinHeap } from '~/utils/minHeap';\n\nimport type { GetPointerPriorityFn, WalkFn } from './types/walk';\n\n/**\n * Walk the nodes of the graph in declaration (insertion) order.\n * This is a cheap alternative to `walkTopological` when dependency ordering\n * is not required and the caller only wants nodes in the order they were\n * added to the graph.\n */\nconst walkDeclarations: WalkFn = (graph, callback, options) => {\n  const pointers = Array.from(graph.nodes.keys());\n\n  if (options?.preferGroups && options.preferGroups.length > 0) {\n    // emit nodes that match each preferred group in order, preserving insertion order\n    const emitted = new Set<string>();\n    if (options.matchPointerToGroup) {\n      for (const kind of options.preferGroups) {\n        for (const pointer of pointers) {\n          const result = options.matchPointerToGroup(pointer);\n          if (!result.matched) continue;\n          if (result.kind === kind) {\n            emitted.add(pointer);\n            callback(pointer, graph.nodes.get(pointer)!);\n          }\n        }\n      }\n    }\n\n    // emit anything not covered by the preferGroups (in declaration order)\n    for (const pointer of pointers) {\n      if (emitted.has(pointer)) continue;\n      callback(pointer, graph.nodes.get(pointer)!);\n    }\n    return;\n  }\n\n  // fallback: simple declaration order\n  for (const pointer of pointers) {\n    callback(pointer, graph.nodes.get(pointer)!);\n  }\n};\n\n/**\n * Walks the nodes of the graph in topological order (dependencies before dependents).\n * Calls the callback for each node pointer in order.\n * Nodes in cycles are grouped together and emitted in arbitrary order within the group.\n *\n * @param graph - The dependency graph\n * @param callback - Function to call for each node pointer\n */\nconst walkTopological: WalkFn = (graph, callback, options) => {\n  // stable Kahn's algorithm that respects declaration order as a tiebreaker.\n  const pointers = Array.from(graph.nodes.keys());\n  // base insertion order\n  const baseIndex = new Map<string, number>();\n  pointers.forEach((pointer, index) => baseIndex.set(pointer, index));\n\n  // composite decl index: group priority then base insertion order\n  const declIndex = new Map<string, number>();\n  for (const pointer of pointers) {\n    const priority = options?.getPointerPriority?.(pointer) ?? 10;\n    const composite = priority * 1_000_000 + (baseIndex.get(pointer) ?? 0);\n    declIndex.set(pointer, composite);\n  }\n\n  // build dependency sets for each pointer\n  const depsOf = new Map<string, Set<string>>();\n  for (const pointer of pointers) {\n    const raw = graph.subtreeDependencies?.get(pointer) ?? new Set();\n    const filtered = new Set<string>();\n    for (const rawPointer of raw) {\n      if (rawPointer === pointer) continue; // ignore self-dependencies for ordering\n      if (graph.nodes.has(rawPointer)) {\n        filtered.add(rawPointer);\n      }\n    }\n    depsOf.set(pointer, filtered);\n  }\n\n  // build inDegree and dependents adjacency\n  const inDegree = new Map<string, number>();\n  const dependents = new Map<string, Set<string>>();\n  for (const pointer of pointers) {\n    inDegree.set(pointer, 0);\n  }\n  for (const [pointer, deps] of depsOf) {\n    inDegree.set(pointer, deps.size);\n    for (const d of deps) {\n      if (!dependents.has(d)) {\n        dependents.set(d, new Set());\n      }\n      dependents.get(d)!.add(pointer);\n    }\n  }\n\n  // sort pointers by declaration order\n  const sortByDecl = (arr: Array<string>) =>\n    arr.sort((a, b) => declIndex.get(a)! - declIndex.get(b)!);\n\n  // initialize queue with zero-inDegree nodes in declaration order\n  // use min-heap prioritized by declaration index to avoid repeated full sorts\n  const heap = new MinHeap(declIndex);\n  for (const pointer of pointers) {\n    if ((inDegree.get(pointer) ?? 0) === 0) {\n      heap.push(pointer);\n    }\n  }\n\n  const emitted = new Set<string>();\n  const order: Array<string> = [];\n\n  while (!heap.isEmpty()) {\n    const cur = heap.pop()!;\n    if (emitted.has(cur)) continue;\n    emitted.add(cur);\n    order.push(cur);\n\n    const deps = dependents.get(cur);\n    if (!deps) continue;\n\n    for (const dep of deps) {\n      const v = (inDegree.get(dep) ?? 0) - 1;\n      inDegree.set(dep, v);\n      if (v === 0) {\n        heap.push(dep);\n      }\n    }\n  }\n\n  // emit remaining nodes (cycles) in declaration order\n  const remaining = pointers.filter((pointer) => !emitted.has(pointer));\n  sortByDecl(remaining);\n  for (const pointer of remaining) {\n    emitted.add(pointer);\n    order.push(pointer);\n  }\n\n  // prefer specified groups when safe\n  let finalOrder = order;\n  if (options?.preferGroups && options.preferGroups.length > 0) {\n    // build group priority map (lower = earlier)\n    const groupPriority = new Map<string, number>();\n    for (let i = 0; i < options.preferGroups.length; i++) {\n      const k = options.preferGroups[i];\n      if (k) {\n        groupPriority.set(k, i);\n      }\n    }\n\n    const getGroup: GetPointerPriorityFn = (pointer) => {\n      if (options.matchPointerToGroup) {\n        const result = options.matchPointerToGroup(pointer);\n        if (result.matched) {\n          return groupPriority.has(result.kind)\n            ? groupPriority.get(result.kind)!\n            : options.preferGroups!.length;\n        }\n      }\n      return options.preferGroups!.length;\n    };\n\n    // proposed order: sort by (groupPriority, originalIndex)\n    const proposed = [...order].sort((a, b) => {\n      const ga = getGroup(a);\n      const gb = getGroup(b);\n      return ga !== gb ? ga - gb : order.indexOf(a) - order.indexOf(b);\n    });\n\n    // build quick lookup of original index and proposed index\n    const proposedIndex = new Map<string, number>();\n    for (let i = 0; i < proposed.length; i++) {\n      proposedIndex.set(proposed[i]!, i);\n    }\n\n    // only validate edges where group(dep) > group(node)\n    const violated = (() => {\n      for (const [node, deps] of depsOf) {\n        for (const dep of deps) {\n          const gDep = getGroup(dep);\n          const gNode = getGroup(node);\n          if (gDep <= gNode) continue; // not a crossing edge, cannot be violated by grouping\n          const pDep = proposedIndex.get(dep)!;\n          const pNode = proposedIndex.get(node)!;\n          if (pDep >= pNode) {\n            return true;\n          }\n        }\n      }\n      return false;\n    })();\n\n    if (!violated) {\n      finalOrder = proposed;\n    }\n  }\n\n  for (const pointer of finalOrder) {\n    callback(pointer, graph.nodes.get(pointer)!);\n  }\n};\n\nexport const walk: WalkFn = (graph, callback, options) => {\n  if (options?.order === 'topological') {\n    return walkTopological(graph, callback, options);\n  }\n  return walkDeclarations(graph, callback, options);\n};\n","import type { GetPointerPriorityFn, MatchPointerToGroupFn } from '~/graph';\n\nexport const irTopLevelKinds = [\n  'operation',\n  'parameter',\n  'requestBody',\n  'schema',\n  'server',\n  'webhook',\n] as const;\n\nexport type IrTopLevelKind = (typeof irTopLevelKinds)[number];\n\n/**\n * Checks if a pointer matches a known top-level IR component (schema, parameter, etc) and returns match info.\n *\n * @param pointer - The IR pointer string (e.g. '#/components/schemas/Foo')\n * @param kind - (Optional) The component kind to check\n * @returns { matched: true, kind: IrTopLevelKind } | { matched: false } - Whether it matched, and the matched kind if so\n */\nexport const matchIrPointerToGroup: MatchPointerToGroupFn<IrTopLevelKind> = (\n  pointer,\n  kind,\n) => {\n  const patterns: Record<IrTopLevelKind, RegExp> = {\n    operation:\n      /^#\\/paths\\/[^/]+\\/(get|put|post|delete|options|head|patch|trace)$/,\n    parameter: /^#\\/components\\/parameters\\/[^/]+$/,\n    requestBody: /^#\\/components\\/requestBodies\\/[^/]+$/,\n    schema: /^#\\/components\\/schemas\\/[^/]+$/,\n    server: /^#\\/servers\\/(\\d+|[^/]+)$/,\n    webhook:\n      /^#\\/webhooks\\/[^/]+\\/(get|put|post|delete|options|head|patch|trace)$/,\n  };\n  if (kind) {\n    return patterns[kind].test(pointer)\n      ? { kind, matched: true }\n      : { matched: false };\n  }\n  for (const key of Object.keys(patterns)) {\n    const kind = key as IrTopLevelKind;\n    if (patterns[kind].test(pointer)) {\n      return { kind, matched: true };\n    }\n  }\n  return { matched: false };\n};\n\n// default grouping preference (earlier groups emitted first when safe)\nexport const preferGroups = [\n  'server',\n  'schema',\n  'parameter',\n  'requestBody',\n  'operation',\n  'webhook',\n] satisfies ReadonlyArray<IrTopLevelKind>;\n\ntype KindPriority = Record<IrTopLevelKind, number>;\n\n// default group priority (lower = earlier)\n// built from `preferGroups` so the priority order stays in sync with the prefer-groups array.\nconst kindPriority: KindPriority = (() => {\n  const partial: Partial<KindPriority> = {};\n  for (let i = 0; i < preferGroups.length; i++) {\n    const k = preferGroups[i];\n    if (k) partial[k] = i;\n  }\n  // Ensure all known kinds exist in the map (fall back to a high index).\n  for (const k of irTopLevelKinds) {\n    if (partial[k] === undefined) {\n      partial[k] = preferGroups.length;\n    }\n  }\n  return partial as KindPriority;\n})();\n\nconst defaultPriority = 10;\n\nexport const getIrPointerPriority: GetPointerPriorityFn = (pointer) => {\n  const result = matchIrPointerToGroup(pointer);\n  if (result.matched) {\n    return kindPriority[result.kind] ?? defaultPriority;\n  }\n  return defaultPriority;\n};\n","import path from 'node:path';\n\nimport type {\n  IProject,\n  Node,\n  Symbol,\n  SymbolIdentifier,\n  SymbolIn,\n  SymbolMeta,\n} from '@hey-api/codegen-core';\n\nimport { HeyApiError } from '~/error';\nimport type { MatchPointerToGroupFn, WalkOptions } from '~/graph';\nimport { walk } from '~/graph';\nimport type { Context } from '~/ir/context';\nimport type { IrTopLevelKind } from '~/ir/graph';\nimport {\n  getIrPointerPriority,\n  irTopLevelKinds,\n  matchIrPointerToGroup,\n  preferGroups,\n} from '~/ir/graph';\nimport type { IR } from '~/ir/types';\nimport type { OpenApi } from '~/openApi/types';\nimport type { Hooks } from '~/parser/types/hooks';\nimport type { Plugin } from '~/plugins';\nimport type { PluginConfigMap } from '~/plugins/config';\nimport type { TsDsl } from '~/ts-dsl';\nimport { jsonPointerToPath } from '~/utils/ref';\n\nimport type { BaseEvent, WalkEvent } from '../types/instance';\n\nconst defaultGetFilePath = (symbol: Symbol): string | undefined => {\n  if (!symbol.meta?.pluginName || typeof symbol.meta.pluginName !== 'string') {\n    return;\n  }\n  if (symbol.meta.pluginName.startsWith('@hey-api/client-')) {\n    return 'client';\n  }\n  if (symbol.meta.pluginName === '@hey-api/typescript') {\n    return 'types';\n  }\n  if (symbol.meta.pluginName.startsWith('@hey-api/')) {\n    return symbol.meta.pluginName.split('/')[1];\n  }\n  return symbol.meta.pluginName;\n};\n\nconst defaultGetKind: Required<Required<Hooks>['operations']>['getKind'] = (\n  operation,\n) => {\n  switch (operation.method) {\n    case 'delete':\n    case 'patch':\n    case 'post':\n    case 'put':\n      return ['mutation'];\n    case 'get':\n      return ['query'];\n    default:\n      return;\n  }\n};\n\ntype EventHooks = {\n  [K in keyof Required<NonNullable<Hooks['events']>>]: Array<\n    NonNullable<NonNullable<Hooks['events']>[K]>\n  >;\n};\n\nexport class PluginInstance<T extends Plugin.Types = Plugin.Types> {\n  api: T['api'];\n  config: Omit<T['resolvedConfig'], 'name'>;\n  context: Context;\n  dependencies: Required<Plugin.Config<T>>['dependencies'] = [];\n  private eventHooks: EventHooks;\n  gen: IProject;\n  private handler: Plugin.Config<T>['handler'];\n  name: T['resolvedConfig']['name'];\n  /**\n   * The package metadata and utilities for the current context, constructed\n   * from the provided dependencies. Used for managing package-related\n   * information such as name, version, and dependency resolution during\n   * code generation.\n   */\n  package: Context['package'];\n\n  constructor(\n    props: Pick<\n      Required<Plugin.Config<T>>,\n      'config' | 'dependencies' | 'handler'\n    > & {\n      api?: T['api'];\n      context: Context<OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X>;\n      gen: IProject;\n      name: string;\n    },\n  ) {\n    this.api = props.api ?? {};\n    this.config = props.config;\n    this.context = props.context;\n    this.dependencies = props.dependencies;\n    this.eventHooks = this.buildEventHooks();\n    this.gen = props.gen;\n    this.handler = props.handler;\n    this.name = props.name;\n    this.package = props.context.package;\n  }\n\n  external(\n    resource: Required<SymbolMeta>['resource'],\n    meta?: Omit<SymbolMeta, 'category' | 'resource'>,\n  ): Symbol {\n    return this.gen.symbols.reference({\n      ...meta,\n      category: 'external',\n      resource,\n    });\n  }\n\n  /**\n   * Iterates over various input elements as specified by the event types, in\n   * a specific order: servers, schemas, parameters, request bodies, then\n   * operations.\n   *\n   * This ensures, for example, that schemas are always processed before\n   * operations, which may reference them.\n   *\n   * @template TKind - The event type(s) to yield. Defaults to all event types.\n   * @param events - The event types to walk over. If none are provided, all event types are included.\n   * @param callback - Function to execute for each event.\n   *\n   * @example\n   * // Iterate over all operations and schemas\n   * plugin.forEach('operation', 'schema', (event) => {\n   *   if (event.type === 'operation') {\n   *     // handle operation\n   *   } else if (event.type === 'schema') {\n   *     // handle schema\n   *   }\n   * });\n   */\n  forEach<TKind extends IrTopLevelKind = IrTopLevelKind>(\n    ...args: [\n      ...events: ReadonlyArray<TKind>,\n      callback: (event: WalkEvent<TKind>) => void,\n    ]\n  ): void;\n  forEach<TKind extends IrTopLevelKind = IrTopLevelKind>(\n    ...args: [\n      ...events: ReadonlyArray<TKind>,\n      callback: (event: WalkEvent<TKind>) => void,\n      options: WalkOptions<TKind>,\n    ]\n  ): void;\n  forEach<TKind extends IrTopLevelKind = IrTopLevelKind>(\n    ...args: [\n      ...events: ReadonlyArray<TKind>,\n      callback: (event: WalkEvent<TKind>) => void,\n      options: any,\n    ]\n  ): void {\n    if (!this.context.graph) {\n      throw new Error('No graph available in context');\n    }\n\n    let callback: (event: WalkEvent<TKind>) => void;\n    let events: ReadonlyArray<TKind>;\n    let options: WalkOptions<TKind> = {\n      getPointerPriority: getIrPointerPriority,\n      // default functions operate on the full union of kinds; cast them\n      // to the WalkOptions generic to keep strict typing for callers.\n      matchPointerToGroup:\n        matchIrPointerToGroup as unknown as MatchPointerToGroupFn<TKind>,\n      order: 'topological',\n      preferGroups: preferGroups as unknown as ReadonlyArray<TKind>,\n    };\n    if (typeof args[args.length - 1] === 'function') {\n      events = args.slice(0, -1);\n      callback = args[args.length - 1];\n    } else {\n      events = args.slice(0, -2);\n      callback = args[args.length - 2];\n      options = {\n        ...options,\n        ...args[args.length - 1],\n      };\n    }\n    const eventSet = new Set(events.length ? events : irTopLevelKinds);\n\n    walk(\n      this.context.graph,\n      (pointer, nodeInfo) => {\n        const result = matchIrPointerToGroup(pointer);\n        if (!result.matched || !eventSet.has(result.kind)) return;\n        let event: WalkEvent | undefined;\n        const baseEvent: BaseEvent = {\n          _path: jsonPointerToPath(pointer),\n          pointer,\n          tags: nodeInfo.tags ? Array.from(nodeInfo.tags) : undefined,\n        };\n        switch (result.kind) {\n          case 'operation':\n            event = {\n              ...baseEvent,\n              method: nodeInfo.key as keyof IR.PathItemObject,\n              operation: nodeInfo.node as IR.OperationObject,\n              path: baseEvent._path[1] as string,\n              type: result.kind,\n            } satisfies WalkEvent<'operation'>;\n            break;\n          case 'parameter':\n            event = {\n              ...baseEvent,\n              name: nodeInfo.key as string,\n              parameter: nodeInfo.node as IR.ParameterObject,\n              type: result.kind,\n            } satisfies WalkEvent<'parameter'>;\n            break;\n          case 'requestBody':\n            event = {\n              ...baseEvent,\n              name: nodeInfo.key as string,\n              requestBody: nodeInfo.node as IR.RequestBodyObject,\n              type: result.kind,\n            } satisfies WalkEvent<'requestBody'>;\n            break;\n          case 'schema':\n            event = {\n              ...baseEvent,\n              name: nodeInfo.key as string,\n              schema: nodeInfo.node as IR.SchemaObject,\n              type: result.kind,\n            } satisfies WalkEvent<'schema'>;\n            break;\n          case 'server':\n            event = {\n              ...baseEvent,\n              server: nodeInfo.node as IR.ServerObject,\n              type: result.kind,\n            } satisfies WalkEvent<'server'>;\n            break;\n          case 'webhook':\n            event = {\n              ...baseEvent,\n              key: baseEvent._path[1] as string,\n              method: nodeInfo.key as keyof IR.PathItemObject,\n              operation: nodeInfo.node as IR.OperationObject,\n              type: result.kind,\n            } satisfies WalkEvent<'webhook'>;\n            break;\n        }\n        if (event) {\n          try {\n            callback(event as WalkEvent<TKind>);\n          } catch (error) {\n            this.forEachError(error, event);\n          }\n        }\n      },\n      options,\n    );\n  }\n\n  /**\n   * Retrieves a registered plugin instance by its name from the context. This\n   * allows plugins to access other plugins that have been registered in the\n   * same context, enabling cross-plugin communication and dependencies.\n   *\n   * @param name Plugin name as defined in the configuration.\n   * @returns The plugin instance if found, undefined otherwise.\n   */\n  getPlugin<TName extends keyof PluginConfigMap>(\n    name: TName,\n  ): TName extends any\n    ? PluginInstance<PluginConfigMap[TName]> | undefined\n    : never {\n    return this.context.plugins[name] as any;\n  }\n\n  /**\n   * Retrieves a registered plugin instance by its name from the context. This\n   * allows plugins to access other plugins that have been registered in the\n   * same context, enabling cross-plugin communication and dependencies.\n   *\n   * @param name Plugin name as defined in the configuration.\n   * @returns The plugin instance if found, throw otherwise.\n   */\n  getPluginOrThrow<TName extends keyof PluginConfigMap>(\n    name: TName,\n  ): TName extends any ? PluginInstance<PluginConfigMap[TName]> : never {\n    const plugin = this.getPlugin(name);\n    if (!plugin) throw new Error(`plugin not found ${name}`);\n    return plugin as any;\n  }\n\n  getSymbol(identifier: SymbolIdentifier): Symbol | undefined {\n    return this.gen.symbols.get(identifier);\n  }\n\n  hooks = {\n    operation: {\n      isMutation: (operation: IR.OperationObject): boolean =>\n        this.isOperationKind(operation, 'mutation'),\n      isQuery: (operation: IR.OperationObject): boolean =>\n        this.isOperationKind(operation, 'query'),\n    },\n  };\n\n  isSymbolRegistered(identifier: SymbolIdentifier): boolean {\n    return this.gen.symbols.isRegistered(identifier);\n  }\n\n  /**\n   * Sets or adds a node to the project graph.\n   *\n   * @param node The node to be added or updated in the project graph.\n   * @param index The index at which to update the node. If undefined, the node will be added.\n   * @returns The index of the added node or void if updated.\n   */\n  node<T extends number | undefined = undefined>(\n    node: Node | null,\n    index?: T,\n  ): T extends number ? void : number {\n    for (const hook of this.eventHooks['node:set:before']) {\n      hook({ node, plugin: this });\n    }\n    const result =\n      index !== undefined\n        ? this.gen.nodes.update(index, node)\n        : this.gen.nodes.add(node);\n    for (const hook of this.eventHooks['node:set:after']) {\n      hook({ node, plugin: this });\n    }\n    return result as T extends number ? void : number;\n  }\n\n  querySymbol(filter: SymbolMeta): Symbol<TsDsl> | undefined {\n    return this.gen.symbols.query(filter)[0] as Symbol<TsDsl> | undefined;\n  }\n\n  referenceSymbol(meta: SymbolMeta): Symbol<TsDsl> {\n    return this.gen.symbols.reference(meta) as Symbol<TsDsl>;\n  }\n\n  /**\n   * @deprecated use `plugin.symbol()` instead\n   */\n  registerSymbol(symbol: SymbolIn): Symbol<TsDsl> {\n    return this.symbol(symbol.name, symbol) as Symbol<TsDsl>;\n  }\n\n  /**\n   * Executes plugin's handler function.\n   */\n  async run(): Promise<void> {\n    for (const hook of this.eventHooks['plugin:handler:before']) {\n      hook({ plugin: this });\n    }\n    await this.handler({ plugin: this });\n    for (const hook of this.eventHooks['plugin:handler:after']) {\n      hook({ plugin: this });\n    }\n  }\n\n  symbol(\n    name: SymbolIn['name'],\n    symbol?: Omit<SymbolIn, 'name'>,\n  ): Symbol<TsDsl> {\n    const symbolIn: SymbolIn = {\n      ...symbol,\n      exportFrom:\n        symbol?.exportFrom ??\n        (!symbol?.external &&\n        this.context.config.output.indexFile &&\n        this.config.exportFromIndex\n          ? ['index']\n          : undefined),\n      getFilePath: symbol?.getFilePath ?? this.getSymbolFilePath.bind(this),\n      meta: {\n        pluginName: path.isAbsolute(this.name) ? 'custom' : this.name,\n        ...symbol?.meta,\n      },\n      name,\n    };\n    for (const hook of this.eventHooks['symbol:register:before']) {\n      hook({ plugin: this, symbol: symbolIn });\n    }\n    const symbolOut = this.gen.symbols.register(symbolIn);\n    for (const hook of this.eventHooks['symbol:register:after']) {\n      hook({ plugin: this, symbol: symbolOut });\n    }\n    return symbolOut as Symbol<TsDsl>;\n  }\n\n  /**\n   * Registers a symbol only if it does not already exist based on the provided\n   * metadata. This prevents duplicate symbols from being created in the project.\n   */\n  symbolOnce(name: SymbolIn['name'], symbol?: Omit<SymbolIn, 'name'>): Symbol {\n    const meta = {\n      ...symbol?.meta,\n    };\n    if (symbol?.external) {\n      meta.category = 'external';\n      meta.resource = symbol.external;\n    }\n    const existing = this.querySymbol(meta);\n    if (existing) return existing;\n    return this.symbol(name, { ...symbol, meta });\n  }\n\n  private buildEventHooks(): EventHooks {\n    const result: EventHooks = {\n      'node:set:after': [],\n      'node:set:before': [],\n      'plugin:handler:after': [],\n      'plugin:handler:before': [],\n      'symbol:register:after': [],\n      'symbol:register:before': [],\n    };\n    const scopes = [\n      this.config['~hooks']?.events,\n      this.context.config.parser.hooks.events,\n    ];\n    for (const scope of scopes) {\n      if (!scope) continue;\n      for (const [key, value] of Object.entries(scope)) {\n        if (value) {\n          result[key as keyof typeof result].push(value.bind(scope) as any);\n        }\n      }\n    }\n    return result;\n  }\n\n  private forEachError(error: unknown, event: WalkEvent) {\n    const originalError =\n      error instanceof Error ? error : new Error(String(error));\n    throw new HeyApiError({\n      args: [event],\n      error: originalError,\n      event: event.type,\n      name: 'Error',\n      pluginName: this.name,\n    });\n  }\n\n  private getSymbolFilePath(symbol: Symbol): string | undefined {\n    const hooks = [\n      this.config['~hooks']?.symbols,\n      this.context.config.parser.hooks.symbols,\n    ];\n    for (const hook of hooks) {\n      const result = hook?.getFilePath?.(symbol);\n      if (result !== undefined) return result;\n    }\n    return defaultGetFilePath(symbol);\n  }\n\n  private isOperationKind(\n    operation: IR.OperationObject,\n    kind: 'mutation' | 'query',\n  ): boolean {\n    const method = kind === 'query' ? 'isQuery' : 'isMutation';\n    const hooks = [\n      this.config['~hooks']?.operations?.[method],\n      this.config['~hooks']?.operations?.getKind,\n      this.context.config.parser.hooks.operations?.[method],\n      this.context.config.parser.hooks.operations?.getKind,\n      defaultGetKind,\n    ];\n    for (const hook of hooks) {\n      if (hook) {\n        const result = hook(operation);\n        if (result !== undefined) {\n          return typeof result === 'boolean' ? result : result.includes(kind);\n        }\n      }\n    }\n    return false;\n  }\n}\n","import { Project } from '@hey-api/codegen-core';\n\nimport type { Package } from '~/config/utils/package';\nimport { packageFactory } from '~/config/utils/package';\nimport type { Graph } from '~/graph';\nimport type { PluginConfigMap } from '~/plugins/config';\nimport { PluginInstance } from '~/plugins/shared/utils/instance';\nimport type { PluginNames } from '~/plugins/types';\nimport { TypeScriptRenderer } from '~/ts-dsl';\nimport type { Config } from '~/types/config';\nimport type { Logger } from '~/utils/logger';\nimport { applyNaming } from '~/utils/naming';\nimport { resolveRef } from '~/utils/ref';\n\nimport type { IR } from './types';\n\nexport class Context<Spec extends Record<string, any> = any> {\n  /**\n   * Configuration for parsing and generating the output. This\n   * is a mix of user-provided and default values.\n   */\n  config: Config;\n  /**\n   * The code generation project instance used to manage files, symbols,\n   */\n  gen: Project;\n  /**\n   * The dependency graph built from the intermediate representation.\n   */\n  graph: Graph | undefined;\n  /**\n   * Intermediate representation model obtained from `spec`.\n   */\n  ir: IR.Model = {};\n  /**\n   * Logger instance.\n   */\n  logger: Logger;\n  /**\n   * The package metadata and utilities for the current context, constructed\n   * from the provided dependencies. Used for managing package-related\n   * information such as name, version, and dependency resolution during\n   * code generation.\n   */\n  package: Package;\n  /**\n   * A map of registered plugin instances, keyed by plugin name. Plugins are\n   * registered through the `registerPlugin` method and can be accessed by\n   * their configured name from the config.\n   */\n  plugins: Partial<\n    Record<PluginNames, PluginInstance<PluginConfigMap[keyof PluginConfigMap]>>\n  > = {};\n  /**\n   * Resolved specification from `input`.\n   */\n  spec: Spec;\n\n  constructor({\n    config,\n    dependencies,\n    logger,\n    spec,\n  }: {\n    config: Config;\n    dependencies: Record<string, string>;\n    logger: Logger;\n    spec: Spec;\n  }) {\n    this.config = config;\n    // TODO: allow overriding via config\n    this.gen = new Project({\n      defaultFileName: 'index',\n      fileName: (base) => {\n        const name = applyNaming(base, config.output.fileName);\n        const { suffix } = config.output.fileName;\n        if (!suffix) {\n          return name;\n        }\n        return name === 'index' || name.endsWith(suffix)\n          ? name\n          : `${name}${suffix}`;\n      },\n      nameConflictResolvers: config.output.nameConflictResolver\n        ? {\n            typescript: config.output.nameConflictResolver,\n          }\n        : undefined,\n      renderers: [\n        new TypeScriptRenderer({\n          header: config.output.header,\n          preferExportAll: config.output.preferExportAll,\n          preferFileExtension: config.output.importFileExtension || undefined,\n          resolveModuleName: config.output.resolveModuleName,\n        }),\n      ],\n      root: config.output.path,\n    });\n    this.logger = logger;\n    this.package = packageFactory(dependencies);\n    this.spec = spec;\n  }\n\n  /**\n   * Returns a resolved and dereferenced schema from `spec`.\n   */\n  dereference<T>(schema: { $ref: string }) {\n    const resolved = this.resolveRef<T>(schema.$ref);\n    const dereferenced = {\n      ...schema,\n      ...resolved,\n    } as T;\n    // @ts-expect-error\n    delete dereferenced.$ref;\n    return dereferenced;\n  }\n\n  /**\n   * Registers a new plugin to the global context.\n   *\n   * @param name Plugin name.\n   * @returns Registered plugin instance.\n   */\n  private registerPlugin<T extends PluginNames>(\n    name: T,\n  ): PluginInstance<PluginConfigMap[T]> {\n    const plugin = this.config.plugins[name]!;\n    const instance = new PluginInstance({\n      api: plugin.api,\n      config: plugin.config as any,\n      context: this as any,\n      dependencies: plugin.dependencies ?? [],\n      gen: this.gen,\n      handler: plugin.handler,\n      name: plugin.name,\n    });\n    this.plugins[instance.name] = instance;\n    return instance;\n  }\n\n  /**\n   * Registers all plugins in the order specified by the configuration and returns\n   * an array of the registered PluginInstance objects. Each plugin is instantiated\n   * and added to the context's plugins map.\n   *\n   * @returns {ReadonlyArray<PluginInstance>} An array of registered plugin instances in order.\n   */\n  registerPlugins(): ReadonlyArray<PluginInstance> {\n    return this.config.pluginOrder.map((name) => this.registerPlugin(name));\n  }\n\n  // TODO: parser - works the same as resolveRef, but for IR schemas.\n  // for now, they map 1:1, but if they diverge (like with OpenAPI 2.0),\n  // we will want to rewrite $refs at parse time, so they continue pointing\n  // to the correct IR location\n  resolveIrRef<T>($ref: string) {\n    return resolveRef<T>({\n      $ref,\n      spec: this.ir,\n    });\n  }\n\n  /**\n   * Returns a resolved reference from `spec`.\n   */\n  resolveRef<T>($ref: string) {\n    return resolveRef<T>({\n      $ref,\n      spec: this.spec,\n    });\n  }\n}\n","import type { Context } from '~/ir/context';\nimport { createOperationKey } from '~/ir/operation';\nimport { toCase } from '~/utils/naming';\n\nimport type { State } from '../types/state';\n\nexport const httpMethods = [\n  'delete',\n  'get',\n  'head',\n  'options',\n  'patch',\n  'post',\n  'put',\n  'trace',\n] as const;\n\n/**\n * Sanitizes namespace identifiers so they are valid TypeScript identifiers of a certain form.\n *\n * 1: Remove any leading characters that are illegal as starting character of a typescript identifier.\n * 2: Replace illegal characters in remaining part of type name with hyphen (-).\n *\n * Step 1 should perhaps instead also replace illegal characters with underscore, or prefix with it, like sanitizeEnumName\n * does. The way this is now one could perhaps end up removing all characters, if all are illegal start characters. It\n * would be sort of a breaking change to do so, though, previously generated code might change then.\n *\n * JavaScript identifier regexp pattern retrieved from https://developer.mozilla.org/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n *\n * The output of this is expected to be converted to PascalCase\n *\n * @deprecated\n */\nexport const sanitizeNamespaceIdentifier = (name: string) =>\n  name\n    .replace(/^[^\\p{ID_Start}]+/u, '')\n    .replace(/[^$\\u200c\\u200d\\p{ID_Continue}]/gu, '-')\n    .replace(/[$+]/g, '-');\n\n/**\n * Returns an operation ID to use across the application. By default, we try\n * to use the provided ID. If it's not provided or the SDK is configured\n * to exclude it, we generate operation ID from its location.\n *\n * @deprecated\n */\nexport const operationToId = ({\n  context,\n  count = 1,\n  id,\n  method,\n  path,\n  state,\n}: {\n  context: Context;\n  count?: number;\n  id: string | undefined;\n  method: string;\n  path: string;\n  state: Pick<State, 'ids'>;\n}): string => {\n  let result: string;\n\n  const { output } = context.config;\n  const targetCase =\n    (output !== undefined && typeof output === 'object' && 'case' in output\n      ? output.case\n      : undefined) ?? 'camelCase';\n\n  if (\n    id &&\n    (!context.config.plugins['@hey-api/sdk'] ||\n      // TODO: needs to be refactored...\n      (context.config.plugins['@hey-api/sdk'].config.operations &&\n        typeof context.config.plugins['@hey-api/sdk'].config.operations !==\n          'function' &&\n        typeof context.config.plugins['@hey-api/sdk'].config.operations ===\n          'object' &&\n        context.config.plugins['@hey-api/sdk'].config.operations.nesting ===\n          'operationId'))\n  ) {\n    result = toCase(sanitizeNamespaceIdentifier(id), targetCase);\n  } else {\n    const pathWithoutPlaceholders = path\n      .replace(/{(.*?)}/g, 'by-$1')\n      // replace slashes with hyphens for camelcase method at the end\n      .replace(/[/:+]/g, '-');\n\n    result = toCase(`${method}-${pathWithoutPlaceholders}`, targetCase);\n  }\n\n  if (count > 1) {\n    result = `${result}${count}`;\n  }\n\n  if (state.ids.has(result)) {\n    return operationToId({\n      context,\n      count: count + 1,\n      id,\n      method,\n      path,\n      state,\n    });\n  }\n\n  state.ids.set(result, createOperationKey({ method, path }));\n\n  return result;\n};\n","import { createOperationKey } from '~/ir/operation';\nimport type { PathItemObject, PathsObject } from '~/openApi/3.1.x/types/spec';\nimport type { OpenApi } from '~/openApi/types';\nimport type { Logger } from '~/utils/logger';\n\nimport type { Config } from '../../../types/config';\nimport type { ResourceMetadata } from '../graph/meta';\nimport { httpMethods } from './operation';\n\ntype FilterNamespace =\n  | 'body'\n  | 'operation'\n  | 'parameter'\n  | 'response'\n  | 'schema'\n  | 'unknown';\n\nconst namespaceNeedle = '/';\n\nexport const addNamespace = (\n  namespace: FilterNamespace,\n  value: string = '',\n): string => `${namespace}${namespaceNeedle}${value}`;\n\nexport const removeNamespace = (\n  key: string,\n): {\n  name: string;\n  namespace: FilterNamespace;\n} => {\n  const index = key.indexOf(namespaceNeedle);\n  const name = key.slice(index + 1);\n  return {\n    name,\n    namespace: key.slice(0, index)! as FilterNamespace,\n  };\n};\n\n/**\n * Converts reference strings from OpenAPI $ref keywords into namespaces.\n *\n * @example '#/components/schemas/Foo' -> 'schema'\n */\nexport const stringToNamespace = (value: string): FilterNamespace => {\n  switch (value) {\n    case 'parameters':\n      return 'parameter';\n    case 'requestBodies':\n      return 'body';\n    case 'responses':\n      return 'response';\n    case 'definitions':\n    case 'schemas':\n      return 'schema';\n    default:\n      return 'unknown';\n  }\n};\n\ntype FiltersConfigToState<T> = {\n  [K in keyof T]-?: NonNullable<T[K]> extends ReadonlyArray<infer U>\n    ? Set<U>\n    : NonNullable<T[K]> extends object\n      ? FiltersConfigToState<NonNullable<T[K]>>\n      : T[K];\n};\n\nexport type Filters = FiltersConfigToState<\n  NonNullable<Config['parser']['filters']>\n>;\n\ninterface SetAndRegExps {\n  regexps: Array<RegExp>;\n  set: Set<string>;\n}\n\nconst createFiltersSetAndRegExps = (\n  type: FilterNamespace,\n  filters: ReadonlyArray<string> | undefined,\n): SetAndRegExps => {\n  const keys: Array<string> = [];\n  const regexps: Array<RegExp> = [];\n  if (filters) {\n    for (const value of filters) {\n      if (value.startsWith('/') && value.endsWith('/')) {\n        regexps.push(new RegExp(value.slice(1, value.length - 1)));\n      } else {\n        keys.push(addNamespace(type, value));\n      }\n    }\n  }\n  return {\n    regexps,\n    set: new Set(keys),\n  };\n};\n\ninterface CollectFiltersSetFromRegExps {\n  excludeOperations: SetAndRegExps;\n  excludeParameters: SetAndRegExps;\n  excludeRequestBodies: SetAndRegExps;\n  excludeResponses: SetAndRegExps;\n  excludeSchemas: SetAndRegExps;\n  includeOperations: SetAndRegExps;\n  includeParameters: SetAndRegExps;\n  includeRequestBodies: SetAndRegExps;\n  includeResponses: SetAndRegExps;\n  includeSchemas: SetAndRegExps;\n}\n\nconst collectFiltersSetFromRegExpsOpenApiV2 = ({\n  excludeOperations,\n  excludeSchemas,\n  includeOperations,\n  includeSchemas,\n  spec,\n}: CollectFiltersSetFromRegExps & {\n  spec: OpenApi.V2_0_X;\n}) => {\n  if (\n    (excludeOperations.regexps.length || includeOperations.regexps.length) &&\n    spec.paths\n  ) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const key = createOperationKey({ method, path });\n        if (excludeOperations.regexps.some((regexp) => regexp.test(key))) {\n          excludeOperations.set.add(addNamespace('operation', key));\n        }\n        if (includeOperations.regexps.some((regexp) => regexp.test(key))) {\n          includeOperations.set.add(addNamespace('operation', key));\n        }\n      }\n    }\n  }\n\n  if (spec.definitions) {\n    // TODO: add parameters\n\n    if (excludeSchemas.regexps.length || includeSchemas.regexps.length) {\n      for (const key of Object.keys(spec.definitions)) {\n        if (excludeSchemas.regexps.some((regexp) => regexp.test(key))) {\n          excludeSchemas.set.add(addNamespace('schema', key));\n        }\n        if (includeSchemas.regexps.some((regexp) => regexp.test(key))) {\n          includeSchemas.set.add(addNamespace('schema', key));\n        }\n      }\n    }\n  }\n};\n\nconst collectFiltersSetFromRegExpsOpenApiV3 = ({\n  excludeOperations,\n  excludeParameters,\n  excludeRequestBodies,\n  excludeResponses,\n  excludeSchemas,\n  includeOperations,\n  includeParameters,\n  includeRequestBodies,\n  includeResponses,\n  includeSchemas,\n  spec,\n}: CollectFiltersSetFromRegExps & {\n  spec: OpenApi.V3_0_X | OpenApi.V3_1_X;\n}) => {\n  if (\n    (excludeOperations.regexps.length || includeOperations.regexps.length) &&\n    spec.paths\n  ) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const key = createOperationKey({ method, path });\n        if (excludeOperations.regexps.some((regexp) => regexp.test(key))) {\n          excludeOperations.set.add(addNamespace('operation', key));\n        }\n        if (includeOperations.regexps.some((regexp) => regexp.test(key))) {\n          includeOperations.set.add(addNamespace('operation', key));\n        }\n      }\n    }\n  }\n\n  if (spec.components) {\n    if (\n      (excludeParameters.regexps.length || includeParameters.regexps.length) &&\n      spec.components.parameters\n    ) {\n      for (const key of Object.keys(spec.components.parameters)) {\n        if (excludeParameters.regexps.some((regexp) => regexp.test(key))) {\n          excludeParameters.set.add(addNamespace('parameter', key));\n        }\n        if (includeParameters.regexps.some((regexp) => regexp.test(key))) {\n          includeParameters.set.add(addNamespace('parameter', key));\n        }\n      }\n    }\n\n    if (\n      (excludeRequestBodies.regexps.length ||\n        includeRequestBodies.regexps.length) &&\n      spec.components.requestBodies\n    ) {\n      for (const key of Object.keys(spec.components.requestBodies)) {\n        if (excludeRequestBodies.regexps.some((regexp) => regexp.test(key))) {\n          excludeRequestBodies.set.add(addNamespace('body', key));\n        }\n        if (includeRequestBodies.regexps.some((regexp) => regexp.test(key))) {\n          includeRequestBodies.set.add(addNamespace('body', key));\n        }\n      }\n    }\n\n    if (\n      (excludeResponses.regexps.length || includeResponses.regexps.length) &&\n      spec.components.responses\n    ) {\n      for (const key of Object.keys(spec.components.responses)) {\n        if (excludeResponses.regexps.some((regexp) => regexp.test(key))) {\n          excludeResponses.set.add(addNamespace('response', key));\n        }\n        if (includeResponses.regexps.some((regexp) => regexp.test(key))) {\n          includeResponses.set.add(addNamespace('response', key));\n        }\n      }\n    }\n\n    if (\n      (excludeSchemas.regexps.length || includeSchemas.regexps.length) &&\n      spec.components.schemas\n    ) {\n      for (const key of Object.keys(spec.components.schemas)) {\n        if (excludeSchemas.regexps.some((regexp) => regexp.test(key))) {\n          excludeSchemas.set.add(addNamespace('schema', key));\n        }\n        if (includeSchemas.regexps.some((regexp) => regexp.test(key))) {\n          includeSchemas.set.add(addNamespace('schema', key));\n        }\n      }\n    }\n  }\n};\n\nconst collectFiltersSetFromRegExps = ({\n  spec,\n  ...filters\n}: CollectFiltersSetFromRegExps & {\n  spec: OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X;\n}): void => {\n  if ('swagger' in spec) {\n    collectFiltersSetFromRegExpsOpenApiV2({ ...filters, spec });\n  } else {\n    collectFiltersSetFromRegExpsOpenApiV3({ ...filters, spec });\n  }\n};\n\nexport const createFilters = (\n  config: Config['parser']['filters'],\n  spec: OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X,\n  logger: Logger,\n): Filters => {\n  const eventCreateFilters = logger.timeEvent('create-filters');\n  const excludeOperations = createFiltersSetAndRegExps(\n    'operation',\n    config?.operations?.exclude,\n  );\n  const includeOperations = createFiltersSetAndRegExps(\n    'operation',\n    config?.operations?.include,\n  );\n  const excludeParameters = createFiltersSetAndRegExps(\n    'parameter',\n    config?.parameters?.exclude,\n  );\n  const includeParameters = createFiltersSetAndRegExps(\n    'parameter',\n    config?.parameters?.include,\n  );\n  const excludeRequestBodies = createFiltersSetAndRegExps(\n    'body',\n    config?.requestBodies?.exclude,\n  );\n  const includeRequestBodies = createFiltersSetAndRegExps(\n    'body',\n    config?.requestBodies?.include,\n  );\n  const excludeResponses = createFiltersSetAndRegExps(\n    'response',\n    config?.responses?.exclude,\n  );\n  const includeResponses = createFiltersSetAndRegExps(\n    'response',\n    config?.responses?.include,\n  );\n  const excludeSchemas = createFiltersSetAndRegExps(\n    'schema',\n    config?.schemas?.exclude,\n  );\n  const includeSchemas = createFiltersSetAndRegExps(\n    'schema',\n    config?.schemas?.include,\n  );\n\n  collectFiltersSetFromRegExps({\n    excludeOperations,\n    excludeParameters,\n    excludeRequestBodies,\n    excludeResponses,\n    excludeSchemas,\n    includeOperations,\n    includeParameters,\n    includeRequestBodies,\n    includeResponses,\n    includeSchemas,\n    spec,\n  });\n\n  const filters: Filters = {\n    deprecated: config?.deprecated ?? true,\n    operations: {\n      exclude: excludeOperations.set,\n      include: includeOperations.set,\n    },\n    orphans: config?.orphans ?? false,\n    parameters: {\n      exclude: excludeParameters.set,\n      include: includeParameters.set,\n    },\n    preserveOrder: config?.preserveOrder ?? false,\n    requestBodies: {\n      exclude: excludeRequestBodies.set,\n      include: includeRequestBodies.set,\n    },\n    responses: {\n      exclude: excludeResponses.set,\n      include: includeResponses.set,\n    },\n    schemas: {\n      exclude: excludeSchemas.set,\n      include: includeSchemas.set,\n    },\n    tags: {\n      exclude: new Set(config?.tags?.exclude),\n      include: new Set(config?.tags?.include),\n    },\n  };\n  eventCreateFilters.timeEnd();\n  return filters;\n};\n\nexport const hasFilters = (config: Config['parser']['filters']): boolean => {\n  if (!config) {\n    return false;\n  }\n\n  // we explicitly want to strip orphans or deprecated\n  if (config.orphans === false || config.deprecated === false) {\n    return true;\n  }\n\n  return Boolean(\n    config.operations?.exclude?.length ||\n      config.operations?.include?.length ||\n      config.parameters?.exclude?.length ||\n      config.parameters?.include?.length ||\n      config.requestBodies?.exclude?.length ||\n      config.requestBodies?.include?.length ||\n      config.responses?.exclude?.length ||\n      config.responses?.include?.length ||\n      config.schemas?.exclude?.length ||\n      config.schemas?.include?.length ||\n      config.tags?.exclude?.length ||\n      config.tags?.include?.length,\n  );\n};\n\n/**\n * Collect operations that satisfy the include/exclude filters and schema dependencies.\n */\nconst collectOperations = ({\n  filters,\n  parameters,\n  requestBodies,\n  resourceMetadata,\n  responses,\n  schemas,\n}: {\n  filters: Filters;\n  parameters: Set<string>;\n  requestBodies: Set<string>;\n  resourceMetadata: ResourceMetadata;\n  responses: Set<string>;\n  schemas: Set<string>;\n}): {\n  operations: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.operations.include.size\n    ? filters.operations.include\n    : new Set(resourceMetadata.operations.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.operations.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.operations.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    if (\n      filters.tags.exclude.size &&\n      node.tags.size &&\n      [...filters.tags.exclude].some((tag) => node.tags.has(tag))\n    ) {\n      continue;\n    }\n\n    if (\n      filters.tags.include.size &&\n      !new Set([...filters.tags.include].filter((tag) => node.tags.has(tag)))\n        .size\n    ) {\n      continue;\n    }\n\n    // skip operation if it references any component not included\n    if (\n      [...node.dependencies].some((dependency) => {\n        const { namespace } = removeNamespace(dependency);\n        switch (namespace) {\n          case 'body':\n            return !requestBodies.has(dependency);\n          case 'parameter':\n            return !parameters.has(dependency);\n          case 'response':\n            return !responses.has(dependency);\n          case 'schema':\n            return !schemas.has(dependency);\n          default:\n            return false;\n        }\n      })\n    ) {\n      continue;\n    }\n\n    finalSet.add(key);\n  }\n  return { operations: finalSet };\n};\n\n/**\n * Collect parameters that satisfy the include/exclude filters and schema dependencies.\n */\nconst collectParameters = ({\n  filters,\n  resourceMetadata,\n  schemas,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  schemas: Set<string>;\n}): {\n  parameters: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.parameters.include.size\n    ? filters.parameters.include\n    : new Set(resourceMetadata.parameters.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.parameters.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.parameters.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    if (!node.dependencies.size) {\n      continue;\n    }\n\n    for (const dependency of node.dependencies) {\n      const { namespace } = removeNamespace(dependency);\n      switch (namespace) {\n        case 'body': {\n          if (filters.requestBodies.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!finalSet.has(dependency)) {\n            stack.push(dependency);\n          }\n          break;\n        }\n        case 'schema': {\n          if (filters.schemas.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!schemas.has(dependency)) {\n            schemas.add(dependency);\n          }\n          break;\n        }\n      }\n    }\n  }\n  return { parameters: finalSet };\n};\n\n/**\n * Collect request bodies that satisfy the include/exclude filters and schema dependencies.\n */\nconst collectRequestBodies = ({\n  filters,\n  resourceMetadata,\n  schemas,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  schemas: Set<string>;\n}): {\n  requestBodies: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.requestBodies.include.size\n    ? filters.requestBodies.include\n    : new Set(resourceMetadata.requestBodies.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.requestBodies.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.requestBodies.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    if (!node.dependencies.size) {\n      continue;\n    }\n\n    for (const dependency of node.dependencies) {\n      const { namespace } = removeNamespace(dependency);\n      switch (namespace) {\n        case 'body': {\n          if (filters.requestBodies.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!finalSet.has(dependency)) {\n            stack.push(dependency);\n          }\n          break;\n        }\n        case 'schema': {\n          if (filters.schemas.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!schemas.has(dependency)) {\n            schemas.add(dependency);\n          }\n          break;\n        }\n      }\n    }\n  }\n  return { requestBodies: finalSet };\n};\n\n/**\n * Collect responses that satisfy the include/exclude filters and schema dependencies.\n */\nconst collectResponses = ({\n  filters,\n  resourceMetadata,\n  schemas,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  schemas: Set<string>;\n}): {\n  responses: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.responses.include.size\n    ? filters.responses.include\n    : new Set(resourceMetadata.responses.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.responses.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.responses.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    if (!node.dependencies.size) {\n      continue;\n    }\n\n    for (const dependency of node.dependencies) {\n      const { namespace } = removeNamespace(dependency);\n      switch (namespace) {\n        case 'body': {\n          if (filters.requestBodies.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!finalSet.has(dependency)) {\n            stack.push(dependency);\n          }\n          break;\n        }\n        case 'schema': {\n          if (filters.schemas.exclude.has(dependency)) {\n            finalSet.delete(key);\n          } else if (!schemas.has(dependency)) {\n            schemas.add(dependency);\n          }\n          break;\n        }\n      }\n    }\n  }\n  return { responses: finalSet };\n};\n\n/**\n * Collect schemas that satisfy the include/exclude filters.\n */\nconst collectSchemas = ({\n  filters,\n  resourceMetadata,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n}): {\n  schemas: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = filters.schemas.include.size\n    ? filters.schemas.include\n    : new Set(resourceMetadata.schemas.keys());\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (filters.schemas.exclude.has(key) || finalSet.has(key)) {\n      continue;\n    }\n\n    const node = resourceMetadata.schemas.get(key);\n\n    if (!node) {\n      continue;\n    }\n\n    if (!filters.deprecated && node.deprecated) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    if (!node.dependencies.size) {\n      continue;\n    }\n\n    for (const dependency of node.dependencies) {\n      const { namespace } = removeNamespace(dependency);\n      switch (namespace) {\n        case 'schema': {\n          if (\n            !finalSet.has(dependency) &&\n            !filters.schemas.exclude.has(dependency)\n          ) {\n            stack.push(dependency);\n          }\n          break;\n        }\n      }\n    }\n  }\n  return { schemas: finalSet };\n};\n\n/**\n * Drop parameters that depend on already excluded parameters.\n */\nconst dropExcludedParameters = ({\n  filters,\n  parameters,\n  resourceMetadata,\n}: {\n  filters: Filters;\n  parameters: Set<string>;\n  resourceMetadata: ResourceMetadata;\n}): void => {\n  if (!filters.parameters.exclude.size) {\n    return;\n  }\n\n  for (const key of parameters) {\n    const node = resourceMetadata.parameters.get(key);\n\n    if (!node?.dependencies.size) {\n      continue;\n    }\n\n    for (const excludedKey of filters.parameters.exclude) {\n      if (node.dependencies.has(excludedKey)) {\n        parameters.delete(key);\n        break;\n      }\n    }\n  }\n};\n\n/**\n * Drop request bodies that depend on already excluded request bodies.\n */\nconst dropExcludedRequestBodies = ({\n  filters,\n  requestBodies,\n  resourceMetadata,\n}: {\n  filters: Filters;\n  requestBodies: Set<string>;\n  resourceMetadata: ResourceMetadata;\n}): void => {\n  if (!filters.requestBodies.exclude.size) {\n    return;\n  }\n\n  for (const key of requestBodies) {\n    const node = resourceMetadata.requestBodies.get(key);\n\n    if (!node?.dependencies.size) {\n      continue;\n    }\n\n    for (const excludedKey of filters.requestBodies.exclude) {\n      if (node.dependencies.has(excludedKey)) {\n        requestBodies.delete(key);\n        break;\n      }\n    }\n  }\n};\n\n/**\n * Drop responses that depend on already excluded responses.\n */\nconst dropExcludedResponses = ({\n  filters,\n  resourceMetadata,\n  responses,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  responses: Set<string>;\n}): void => {\n  if (!filters.responses.exclude.size) {\n    return;\n  }\n\n  for (const key of responses) {\n    const node = resourceMetadata.responses.get(key);\n\n    if (!node?.dependencies.size) {\n      continue;\n    }\n\n    for (const excludedKey of filters.responses.exclude) {\n      if (node.dependencies.has(excludedKey)) {\n        responses.delete(key);\n        break;\n      }\n    }\n  }\n};\n\n/**\n * Drop schemas that depend on already excluded schemas.\n */\nconst dropExcludedSchemas = ({\n  filters,\n  resourceMetadata,\n  schemas,\n}: {\n  filters: Filters;\n  resourceMetadata: ResourceMetadata;\n  schemas: Set<string>;\n}): void => {\n  if (!filters.schemas.exclude.size) {\n    return;\n  }\n\n  for (const key of schemas) {\n    const node = resourceMetadata.schemas.get(key);\n\n    if (!node?.dependencies.size) {\n      continue;\n    }\n\n    for (const excludedKey of filters.schemas.exclude) {\n      if (node.dependencies.has(excludedKey)) {\n        schemas.delete(key);\n        break;\n      }\n    }\n  }\n};\n\nconst dropOrphans = ({\n  operationDependencies,\n  parameters,\n  requestBodies,\n  responses,\n  schemas,\n}: {\n  operationDependencies: Set<string>;\n  parameters: Set<string>;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n}) => {\n  for (const key of schemas) {\n    if (!operationDependencies.has(key)) {\n      schemas.delete(key);\n    }\n  }\n  for (const key of parameters) {\n    if (!operationDependencies.has(key)) {\n      parameters.delete(key);\n    }\n  }\n  for (const key of requestBodies) {\n    if (!operationDependencies.has(key)) {\n      requestBodies.delete(key);\n    }\n  }\n  for (const key of responses) {\n    if (!operationDependencies.has(key)) {\n      responses.delete(key);\n    }\n  }\n};\n\nconst collectOperationDependencies = ({\n  operations,\n  resourceMetadata,\n}: {\n  operations: Set<string>;\n  resourceMetadata: ResourceMetadata;\n}): {\n  operationDependencies: Set<string>;\n} => {\n  const finalSet = new Set<string>();\n  const initialSet = new Set(\n    [...operations].flatMap((key) => [\n      ...(resourceMetadata.operations.get(key)?.dependencies ?? []),\n    ]),\n  );\n  const stack = [...initialSet];\n  while (stack.length) {\n    const key = stack.pop()!;\n\n    if (finalSet.has(key)) {\n      continue;\n    }\n\n    finalSet.add(key);\n\n    const { namespace } = removeNamespace(key);\n    let dependencies: Set<string> | undefined;\n    if (namespace === 'body') {\n      dependencies = resourceMetadata.requestBodies.get(key)?.dependencies;\n    } else if (namespace === 'operation') {\n      dependencies = resourceMetadata.operations.get(key)?.dependencies;\n    } else if (namespace === 'parameter') {\n      dependencies = resourceMetadata.parameters.get(key)?.dependencies;\n    } else if (namespace === 'response') {\n      dependencies = resourceMetadata.responses.get(key)?.dependencies;\n    } else if (namespace === 'schema') {\n      dependencies = resourceMetadata.schemas.get(key)?.dependencies;\n    }\n\n    if (!dependencies?.size) {\n      continue;\n    }\n\n    for (const dependency of dependencies) {\n      if (!finalSet.has(dependency)) {\n        stack.push(dependency);\n      }\n    }\n  }\n  return { operationDependencies: finalSet };\n};\n\nexport const createFilteredDependencies = ({\n  filters,\n  logger,\n  resourceMetadata,\n}: {\n  filters: Filters;\n  logger: Logger;\n  resourceMetadata: ResourceMetadata;\n}): {\n  operations: Set<string>;\n  parameters: Set<string>;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n} => {\n  const eventCreateFilteredDependencies = logger.timeEvent(\n    'create-filtered-dependencies',\n  );\n  const { schemas } = collectSchemas({ filters, resourceMetadata });\n  const { parameters } = collectParameters({\n    filters,\n    resourceMetadata,\n    schemas,\n  });\n  const { requestBodies } = collectRequestBodies({\n    filters,\n    resourceMetadata,\n    schemas,\n  });\n  const { responses } = collectResponses({\n    filters,\n    resourceMetadata,\n    schemas,\n  });\n\n  dropExcludedSchemas({ filters, resourceMetadata, schemas });\n  dropExcludedParameters({ filters, parameters, resourceMetadata });\n  dropExcludedRequestBodies({ filters, requestBodies, resourceMetadata });\n  dropExcludedResponses({ filters, resourceMetadata, responses });\n\n  // collect operations after dropping components\n  const { operations } = collectOperations({\n    filters,\n    parameters,\n    requestBodies,\n    resourceMetadata,\n    responses,\n    schemas,\n  });\n\n  if (!filters.orphans && operations.size) {\n    const { operationDependencies } = collectOperationDependencies({\n      operations,\n      resourceMetadata,\n    });\n    dropOrphans({\n      operationDependencies,\n      parameters,\n      requestBodies,\n      responses,\n      schemas,\n    });\n  }\n\n  eventCreateFilteredDependencies.timeEnd();\n  return {\n    operations,\n    parameters,\n    requestBodies,\n    responses,\n    schemas,\n  };\n};\n","import type { Graph } from '~/graph';\nimport { createOperationKey } from '~/ir/operation';\nimport type { Logger } from '~/utils/logger';\nimport { jsonPointerToPath } from '~/utils/ref';\n\nimport { addNamespace, stringToNamespace } from '../utils/filter';\nimport { httpMethods } from '../utils/operation';\n\nexport type ResourceMetadata = {\n  operations: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n      tags: Set<string>;\n    }\n  >;\n  parameters: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n    }\n  >;\n  requestBodies: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n    }\n  >;\n  responses: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n    }\n  >;\n  schemas: Map<\n    string,\n    {\n      dependencies: Set<string>;\n      deprecated: boolean;\n    }\n  >;\n};\n\n/**\n * Builds a resource metadata map from a Graph, matching the old Graph interface\n * for compatibility with filtering code.\n */\nexport const buildResourceMetadata = (\n  graph: Graph,\n  logger: Logger,\n): {\n  resourceMetadata: ResourceMetadata;\n} => {\n  const eventBuildResourceMetadata = logger.timeEvent(\n    'build-resource-metadata',\n  );\n  const resourceMetadata: ResourceMetadata = {\n    operations: new Map(),\n    parameters: new Map(),\n    requestBodies: new Map(),\n    responses: new Map(),\n    schemas: new Map(),\n  };\n\n  const getDependencies = (pointer: string): Set<string> => {\n    const dependencies = new Set<string>();\n    const nodeDependencies = graph.transitiveDependencies.get(pointer);\n    if (nodeDependencies?.size) {\n      for (const dependency of nodeDependencies) {\n        const path = jsonPointerToPath(dependency);\n        const type = path[path.length - 2];\n        const name = path[path.length - 1];\n        if (type && name) {\n          const namespace = stringToNamespace(type);\n          if (namespace === 'unknown') {\n            console.warn(`unsupported type: ${type}`);\n          }\n          dependencies.add(addNamespace(namespace, name));\n        }\n      }\n    }\n    return dependencies;\n  };\n\n  // Process each node to find top-level resources\n  for (const [pointer, nodeInfo] of graph.nodes) {\n    // const node = nodeInfo.node as Record<string, unknown>;\n    const path = jsonPointerToPath(pointer);\n\n    // OpenAPI 3.x\n    if (path[0] === 'components') {\n      if (path.length === 3) {\n        if (path[1] === 'schemas') {\n          // Schema: #/components/schemas/{name}\n          const name = path[path.length - 1]!;\n          resourceMetadata.schemas.set(addNamespace('schema', name), {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n          });\n        } else if (path[1] === 'parameters') {\n          // Parameter: #/components/parameters/{name}\n          const name = path[path.length - 1]!;\n          resourceMetadata.parameters.set(addNamespace('parameter', name), {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n          });\n        } else if (path[1] === 'requestBodies') {\n          // RequestBody: #/components/requestBodies/{name}\n          const name = path[path.length - 1]!;\n          resourceMetadata.requestBodies.set(addNamespace('body', name), {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n          });\n        } else if (path[1] === 'responses') {\n          // Response: #/components/responses/{name}\n          const name = path[path.length - 1]!;\n          resourceMetadata.responses.set(addNamespace('response', name), {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n          });\n        }\n      }\n      continue;\n    }\n\n    if (path[0] === 'paths') {\n      if (\n        path.length === 3 &&\n        httpMethods.includes(path[2] as (typeof httpMethods)[number])\n      ) {\n        // Operation: #/paths/{path}/{method}\n        const method = path[path.length - 1]!;\n        const operationPath = path.slice(1, -1).join('/');\n        const operationKey = createOperationKey({\n          method,\n          path: operationPath,\n        });\n        resourceMetadata.operations.set(\n          addNamespace('operation', operationKey),\n          {\n            dependencies: getDependencies(pointer),\n            deprecated: nodeInfo.deprecated ?? false,\n            tags: nodeInfo.tags ?? new Set(),\n          },\n        );\n      }\n      continue;\n    }\n\n    // OpenAPI 2.0\n    if (path[0] === 'definitions') {\n      if (path.length === 2) {\n        // Schema: #/definitions/{name}\n        const name = path[path.length - 1]!;\n        resourceMetadata.schemas.set(addNamespace('schema', name), {\n          dependencies: getDependencies(pointer),\n          deprecated: nodeInfo.deprecated ?? false,\n        });\n      }\n      continue;\n    }\n  }\n\n  eventBuildResourceMetadata.timeEnd();\n  return { resourceMetadata };\n};\n","export const deepClone = <T>(obj: T): T => JSON.parse(JSON.stringify(obj));\n","export const childSchemaRelationships = [\n  ['additionalProperties', 'single'],\n  ['allOf', 'array'],\n  ['anyOf', 'array'],\n  ['contains', 'single'],\n  ['dependentSchemas', 'objectMap'],\n  ['else', 'single'],\n  ['if', 'single'],\n  ['items', 'singleOrArray'],\n  ['oneOf', 'array'],\n  ['patternProperties', 'objectMap'],\n  ['properties', 'objectMap'],\n  ['propertyNames', 'single'],\n  ['then', 'single'],\n] as const;\n","export const getSchemasObject = (\n  spec: unknown,\n): Record<string, unknown> | undefined => {\n  if (hasComponentsSchemasObject(spec)) {\n    return (spec as any).components.schemas;\n  }\n  if (hasDefinitionsObject(spec)) {\n    return (spec as any).definitions;\n  }\n  return;\n};\n\n/**\n * Checks if the given spec has a valid OpenAPI 3.x components.schemas object.\n * Returns true if present, false otherwise.\n */\nexport const hasComponentsSchemasObject = (spec: unknown): boolean =>\n  typeof spec === 'object' &&\n  spec !== null &&\n  'components' in spec &&\n  typeof (spec as any).components === 'object' &&\n  (spec as any).components !== null &&\n  'schemas' in (spec as any).components &&\n  typeof (spec as any).components.schemas === 'object' &&\n  (spec as any).components.schemas !== null;\n\n/**\n * Checks if the given spec has a valid OpenAPI 2.0 definitions object.\n * Returns true if present, false otherwise.\n */\nexport const hasDefinitionsObject = (spec: unknown): boolean =>\n  typeof spec === 'object' &&\n  spec !== null &&\n  'definitions' in spec &&\n  typeof (spec as any).definitions === 'object' &&\n  (spec as any).definitions !== null;\n","type Obj =\n  | Record<string, unknown>\n  | Set<string>\n  | ReadonlyArray<string | undefined>;\n\nconst hasName = (obj: Obj, value: string): boolean => {\n  if (obj instanceof Set) {\n    return obj.has(value);\n  }\n  if (obj instanceof Array) {\n    return obj.includes(value);\n  }\n  return value in obj;\n};\n\nexport const getUniqueComponentName = ({\n  base,\n  components,\n  extraComponents,\n}: {\n  base: string;\n  /**\n   * Input components.\n   */\n  components: Obj;\n  /**\n   * Temporary input components, waiting to be inserted for example.\n   */\n  extraComponents?: Obj;\n}): string => {\n  let index = 2;\n  let name = base;\n  while (\n    hasName(components, name) ||\n    (extraComponents && hasName(extraComponents, name))\n  ) {\n    name = `${base}${index}`;\n    index += 1;\n  }\n  return name;\n};\n\nexport const isPathRootSchema = (path: ReadonlyArray<string | number>) =>\n  (path.length === 3 && path[0] === 'components' && path[1] === 'schemas') ||\n  (path.length === 2 && path[0] === 'definitions');\n\nexport const specToSchemasPointerNamespace = (spec: unknown): string => {\n  if (spec && typeof spec === 'object') {\n    if ('swagger' in spec) {\n      // #/definitions/SchemaName\n      return '#/definitions/';\n    }\n\n    if ('openapi' in spec) {\n      // #/components/schemas/SchemaName\n      return '#/components/schemas/';\n    }\n  }\n\n  return '';\n};\n","import { applyNaming } from '~/utils/naming';\nimport { jsonPointerToPath } from '~/utils/ref';\n\nimport type { Config } from '../../../types/config';\nimport { deepClone } from '../utils/schema';\nimport { childSchemaRelationships } from '../utils/schemaChildRelationships';\nimport { getSchemasObject } from '../utils/transforms';\nimport {\n  getUniqueComponentName,\n  isPathRootSchema,\n  specToSchemasPointerNamespace,\n} from './utils';\n\ntype EnumsConfig = Config['parser']['transforms']['enums'];\n\n/**\n * Generate a unique, structural signature for an enum schema for deduplication.\n * Only considers 'type' and sorted 'enum' values, ignoring other fields.\n *\n * @param schema - The schema object to analyze\n * @returns A string signature if the schema is an enum, otherwise undefined\n */\nconst getEnumSignature = (schema: unknown): string | undefined => {\n  if (\n    !schema ||\n    typeof schema !== 'object' ||\n    !('enum' in schema) ||\n    !(schema.enum instanceof Array)\n  ) {\n    return;\n  }\n  // Use type + sorted enum values for signature\n  const type = ('type' in schema ? schema.type : undefined) || '';\n  const values = [...schema.enum].sort();\n  return JSON.stringify({ type, values });\n};\n\ntype NodeInfo = {\n  key: string | number | null;\n  node: unknown;\n  parent: unknown;\n  path: ReadonlyArray<string | number>;\n};\n\n/**\n * Recursively walk all schemas in the OpenAPI spec, visiting every object/array\n * that could contain an enum. Calls the visitor with node info for each.\n *\n * @param key - The key of the current node\n * @param node - The current node\n * @param parent - The parent node\n * @param path - The path to the current node\n * @param visitor - Function to call for each visited node\n */\nconst walkSchemas = ({\n  key,\n  node,\n  parent,\n  path,\n  visitor,\n}: NodeInfo & {\n  visitor: (nodeInfo: NodeInfo) => void;\n}) => {\n  if (!node || typeof node !== 'object' || node instanceof Array) return;\n\n  const value = node as Record<string, unknown>;\n\n  if (\n    'type' in value ||\n    'enum' in value ||\n    childSchemaRelationships.some(([keyword]) => keyword in value)\n  ) {\n    visitor({ key, node, parent, path });\n  }\n\n  for (const [k, v] of Object.entries(value)) {\n    if (typeof v === 'object' && v !== null) {\n      if (v instanceof Array) {\n        v.forEach((item, index) =>\n          walkSchemas({\n            key: index,\n            node: item,\n            parent: v,\n            path: [...path, k, index],\n            visitor,\n          }),\n        );\n      } else {\n        walkSchemas({\n          key: k,\n          node: v,\n          parent: node,\n          path: [...path, k],\n          visitor,\n        });\n      }\n    }\n  }\n};\n\n/**\n * Inlines all root/top-level enums by replacing $refs to them with the actual enum schema,\n * and then removes the now-unreferenced root enums from the schemas object.\n *\n * @param spec - The OpenAPI spec object to transform\n */\nconst inlineMode = ({ spec }: { spec: unknown }) => {\n  const schemasObj = getSchemasObject(spec);\n  if (!schemasObj) {\n    return;\n  }\n\n  const schemasPointerNamespace = specToSchemasPointerNamespace(spec);\n\n  // Collect all root enums\n  const rootEnums: Record<string, unknown> = {};\n  for (const [name, schema] of Object.entries(schemasObj)) {\n    const signature = getEnumSignature(schema);\n    if (signature) {\n      rootEnums[`${schemasPointerNamespace}${name}`] = schema;\n    }\n  }\n\n  // Walk the spec and replace $refs to root enums with inline enum schemas\n  const replaceEnumRefs = (node: unknown) => {\n    if (node instanceof Array) {\n      node.forEach(replaceEnumRefs);\n    } else if (node && typeof node === 'object') {\n      for (const [k, v] of Object.entries(node)) {\n        if (k === '$ref' && typeof v === 'string' && v in rootEnums) {\n          // Replace $ref with a deep clone of the enum schema\n          Object.assign(node, deepClone(rootEnums[v]));\n          delete (node as Record<string, unknown>)['$ref'];\n        } else {\n          replaceEnumRefs(v);\n        }\n      }\n    }\n  };\n  replaceEnumRefs(spec);\n\n  // Remove unreferenced root enums\n  for (const pointer of Object.keys(rootEnums)) {\n    const path = jsonPointerToPath(pointer);\n    const name = path[path.length - 1]!;\n    if (name) {\n      delete schemasObj[name];\n    }\n  }\n};\n\n/**\n * Promotes all inline enums to reusable root components (if mode is 'root'),\n * deduplicates by signature, and replaces inline enums with $refs.\n *\n * Naming, casing, and deduplication are controlled by the enums transform config.\n * Existing root enums are reused if structurally identical.\n *\n * @param spec - The OpenAPI spec object to transform\n * @param config - The enums transform config\n */\nconst rootMode = ({ config, spec }: { config: EnumsConfig; spec: unknown }) => {\n  const schemasObj = getSchemasObject(spec);\n  if (!schemasObj) {\n    return;\n  }\n\n  // Build a map of existing root enum signatures to their names for deduplication\n  const rootEnumSignatures: Record<string, string> = {};\n  for (const [name, schema] of Object.entries(schemasObj)) {\n    const signature = getEnumSignature(schema);\n    if (signature) {\n      rootEnumSignatures[signature] = name;\n    }\n  }\n\n  // Collect all inline enums (not at root schemas)\n  const inlineEnums: Array<{\n    key: string | number | null;\n    node: unknown;\n    parent: unknown;\n    path: ReadonlyArray<string | number>;\n    signature: string;\n  }> = [];\n\n  walkSchemas({\n    key: null,\n    node: spec,\n    parent: null,\n    path: [],\n    visitor: (nodeInfo) => {\n      if (!isPathRootSchema(nodeInfo.path)) {\n        const signature = getEnumSignature(nodeInfo.node);\n        if (signature) {\n          inlineEnums.push({ ...nodeInfo, signature });\n        }\n      }\n    },\n  });\n\n  // Deduplicate and assign unique names for promoted enums\n  const signatureToName: Record<string, string | undefined> = {};\n  const signatureToSchema: Record<string, unknown> = {};\n\n  for (const { key, node, signature } of inlineEnums) {\n    if (signature in signatureToName) {\n      // Already handled\n      continue;\n    }\n\n    // Use existing root enum if available\n    if (signature in rootEnumSignatures) {\n      signatureToName[signature] = rootEnumSignatures[signature];\n      continue;\n    }\n\n    // Generate a unique name for the new root enum using config\n    const base = applyNaming(\n      typeof node === 'object' &&\n        node &&\n        'title' in node &&\n        typeof node.title === 'string'\n        ? node.title\n        : String(key),\n      config,\n    );\n    const name = getUniqueComponentName({\n      base,\n      components: schemasObj,\n      extraComponents: Object.values(signatureToName),\n    });\n    signatureToName[signature] = name;\n    signatureToSchema[signature] = node;\n  }\n\n  // Add new root enums to the schemas object\n  for (const [signature, name] of Object.entries(signatureToName)) {\n    // Only add if not already present\n    const schema = signatureToSchema[signature];\n    if (name && !(name in schemasObj) && schema && typeof schema === 'object') {\n      schemasObj[name] = schema;\n    }\n  }\n\n  // Replace inline enums with $ref to the new root enum\n  const schemasPointerNamespace = specToSchemasPointerNamespace(spec);\n  for (const { key, parent, signature } of inlineEnums) {\n    const name = signatureToName[signature];\n    if (name && key != null && parent && typeof parent === 'object') {\n      (parent as Record<string, unknown>)[key] = {\n        $ref: `${schemasPointerNamespace}${name}`,\n      };\n    }\n  }\n};\n\n/**\n * Applies the enums transform according to the configured mode ('inline' or 'root').\n *\n * - In 'inline' mode, all root enums are inlined and removed.\n * - In 'root' mode, all inline enums are promoted to root components and deduplicated.\n *\n * @param config - The enums transform config\n * @param spec - The OpenAPI spec object to transform\n */\nexport const enumsTransform = ({\n  config,\n  spec,\n}: {\n  config: EnumsConfig;\n  spec: unknown;\n}) => {\n  if (config.mode === 'inline') {\n    inlineMode({ spec });\n    return;\n  }\n\n  if (config.mode === 'root') {\n    rootMode({ config, spec });\n    return;\n  }\n};\n","import { childSchemaRelationships } from '../utils/schemaChildRelationships';\n\ntype NodeInfo = {\n  key: string | number | null;\n  node: unknown;\n  parent: unknown;\n  path: ReadonlyArray<string | number>;\n};\n\n/**\n * Recursively walk all schemas in the OpenAPI spec, visiting every object.\n * Calls the visitor with node info for each.\n *\n * @param key - The key of the current node\n * @param node - The current node\n * @param parent - The parent node\n * @param path - The path to the current node\n * @param visitor - Function to call for each visited node\n */\nconst walkSchemas = ({\n  key,\n  node,\n  parent,\n  path,\n  visitor,\n}: NodeInfo & {\n  visitor: (nodeInfo: NodeInfo) => void;\n}) => {\n  if (!node || typeof node !== 'object' || node instanceof Array) return;\n\n  const value = node as Record<string, unknown>;\n\n  if (\n    'type' in value ||\n    childSchemaRelationships.some(([keyword]) => keyword in value)\n  ) {\n    visitor({ key, node, parent, path });\n  }\n\n  for (const [k, v] of Object.entries(value)) {\n    if (typeof v === 'object' && v !== null) {\n      if (v instanceof Array) {\n        v.forEach((item, index) =>\n          walkSchemas({\n            key: index,\n            node: item,\n            parent: v,\n            path: [...path, k, index],\n            visitor,\n          }),\n        );\n      } else {\n        walkSchemas({\n          key: k,\n          node: v,\n          parent: node,\n          path: [...path, k],\n          visitor,\n        });\n      }\n    }\n  }\n};\n\n/**\n * Applies the properties required by default transform\n *\n * @param spec - The OpenAPI spec object to transform\n */\nexport const propertiesRequiredByDefaultTransform = ({\n  spec,\n}: {\n  spec: unknown;\n}) => {\n  walkSchemas({\n    key: null,\n    node: spec,\n    parent: null,\n    path: [],\n    visitor: (nodeInfo) => {\n      if (\n        nodeInfo.node &&\n        typeof nodeInfo.node === 'object' &&\n        'type' in nodeInfo.node &&\n        nodeInfo.node.type === 'object' &&\n        'properties' in nodeInfo.node &&\n        nodeInfo.node.properties &&\n        typeof nodeInfo.node.properties === 'object' &&\n        !('required' in nodeInfo.node)\n      ) {\n        const propKeys = Object.keys(\n          nodeInfo.node.properties as Record<string, unknown>,\n        );\n        if (propKeys.length > 0) {\n          (nodeInfo.node as Record<string, unknown>).required = propKeys;\n        }\n      }\n    },\n  });\n};\n","/**\n * Deep equality for JSON-compatible values (objects, arrays, primitives).\n * Used to determine whether read/write pruned variants actually differ.\n */\nconst deepEqual = (a: unknown, b: unknown): boolean => {\n  if (a === b) return true;\n  if (a === null || b === null) return a === b;\n  const typeA = typeof a;\n  const typeB = typeof b;\n  if (typeA !== typeB) return false;\n  if (typeA !== 'object') return false;\n\n  // Arrays\n  if (Array.isArray(a) || Array.isArray(b)) {\n    if (!Array.isArray(a) || !Array.isArray(b)) return false;\n    if (a.length !== b.length) return false;\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n    return true;\n  }\n\n  // Plain objects\n  const objA = a as Record<string, unknown>;\n  const objB = b as Record<string, unknown>;\n  const keysA = Object.keys(objA).sort();\n  const keysB = Object.keys(objB).sort();\n  if (keysA.length !== keysB.length) return false;\n  for (let i = 0; i < keysA.length; i++) {\n    if (keysA[i] !== keysB[i]) return false;\n  }\n  for (const key of keysA) {\n    if (!deepEqual(objA[key], objB[key])) return false;\n  }\n  return true;\n};\n\nexport default deepEqual;\n","import type { Graph, NodeInfo } from '~/graph';\nimport type { Logger } from '~/utils/logger';\nimport { normalizeJsonPointer, pathToJsonPointer } from '~/utils/ref';\n\nimport { childSchemaRelationships } from './schemaChildRelationships';\n\n/**\n * Represents the possible access scopes for OpenAPI nodes.\n * - 'normal': Default scope for regular nodes.\n * - 'read': Node is read-only (e.g., readOnly: true).\n * - 'write': Node is write-only (e.g., writeOnly: true).\n */\nexport type Scope = 'normal' | 'read' | 'write';\n\n/**\n * Ensures every relevant child node (e.g., properties, items) in the graph has a `scopes` property.\n * If a node does not have its own scopes, it inherits from its parent if available.\n *\n * @param nodes - Map of JSON Pointer to NodeInfo.\n */\nexport const annotateChildScopes = (nodes: Graph['nodes']): void => {\n  for (const [, nodeInfo] of nodes) {\n    if (nodeInfo.scopes) continue;\n\n    if (nodeInfo.parentPointer) {\n      const parentInfo = nodes.get(nodeInfo.parentPointer);\n      if (parentInfo?.scopes) {\n        nodeInfo.scopes = new Set(parentInfo.scopes);\n      }\n    }\n  }\n};\n\ninterface Cache {\n  parentToChildren: Map<string, Array<string>>;\n  subtreeDependencies: Map<string, Set<string>>;\n  transitiveDependencies: Map<string, Set<string>>;\n}\n\ntype PointerDependenciesResult = {\n  subtreeDependencies: Set<string>;\n  transitiveDependencies: Set<string>;\n};\n\n/**\n * Recursively collects all $ref dependencies in the subtree rooted at `pointer`.\n */\nconst collectPointerDependencies = ({\n  cache,\n  graph,\n  pointer,\n  visited,\n}: {\n  cache: Cache;\n  graph: Graph;\n  pointer: string;\n  visited: Set<string>;\n}): PointerDependenciesResult => {\n  const cached = cache.transitiveDependencies.get(pointer);\n  if (cached) {\n    return {\n      subtreeDependencies: cache.subtreeDependencies.get(pointer)!,\n      transitiveDependencies: cached,\n    };\n  }\n\n  if (visited.has(pointer)) {\n    return {\n      subtreeDependencies: new Set(),\n      transitiveDependencies: new Set(),\n    };\n  }\n  visited.add(pointer);\n\n  const nodeInfo = graph.nodes.get(pointer);\n  if (!nodeInfo) {\n    return {\n      subtreeDependencies: new Set(),\n      transitiveDependencies: new Set(),\n    };\n  }\n\n  const transitiveDependencies = new Set<string>();\n  const subtreeDependencies = new Set<string>();\n\n  // Add direct $ref dependencies for this node\n  // (from the dependencies map, or by checking nodeInfo.node directly)\n  // We'll use the dependencies map for consistency:\n  const nodeDependencies = graph.nodeDependencies.get(pointer);\n  if (nodeDependencies) {\n    for (const depPointer of nodeDependencies) {\n      transitiveDependencies.add(depPointer);\n      subtreeDependencies.add(depPointer);\n      // Recursively collect dependencies of the referenced node\n      const depResult = collectPointerDependencies({\n        cache,\n        graph,\n        pointer: depPointer,\n        visited,\n      });\n      for (const dependency of depResult.transitiveDependencies) {\n        transitiveDependencies.add(dependency);\n      }\n    }\n  }\n\n  const children = cache.parentToChildren.get(pointer) ?? [];\n  for (const childPointer of children) {\n    let childResult: Partial<PointerDependenciesResult> = {\n      subtreeDependencies: cache.subtreeDependencies.get(childPointer),\n      transitiveDependencies: cache.transitiveDependencies.get(childPointer),\n    };\n    if (\n      !childResult.subtreeDependencies ||\n      !childResult.transitiveDependencies\n    ) {\n      childResult = collectPointerDependencies({\n        cache,\n        graph,\n        pointer: childPointer,\n        visited,\n      });\n      cache.transitiveDependencies.set(\n        childPointer,\n        childResult.transitiveDependencies!,\n      );\n      cache.subtreeDependencies.set(\n        childPointer,\n        childResult.subtreeDependencies!,\n      );\n    }\n    for (const dependency of childResult.transitiveDependencies!) {\n      transitiveDependencies.add(dependency);\n    }\n    for (const dependency of childResult.subtreeDependencies!) {\n      subtreeDependencies.add(dependency);\n    }\n  }\n\n  cache.transitiveDependencies.set(pointer, transitiveDependencies);\n  cache.subtreeDependencies.set(pointer, subtreeDependencies);\n  return {\n    subtreeDependencies,\n    transitiveDependencies,\n  };\n};\n\n/**\n * Propagates scopes through the graph using a worklist algorithm.\n * Each node's scopes will be updated to include any scopes inherited via $ref dependencies, combinator/child relationships, and parent relationships.\n * Handles cycles and deep chains efficiently.\n *\n * Whenever a node's scopes change, all dependents are notified:\n *   - Its parent (if any)\n *   - All nodes that reference it via $ref (reverse dependencies)\n *   - Combinator parents (allOf/anyOf/oneOf) if applicable\n *\n * @param graph - The Graph structure containing nodes, dependencies, and reverseNodeDependencies.\n */\nexport const propagateScopes = (graph: Graph): void => {\n  const worklist: Set<string> = new Set(\n    Array.from(graph.nodes.entries())\n      .filter(([, nodeInfo]) => nodeInfo.scopes && nodeInfo.scopes.size > 0)\n      .map(([pointer]) => pointer),\n  );\n\n  /**\n   * Notifies all dependents of a node that its scopes may have changed.\n   * Dependents include:\n   *   - The parent node (if any)\n   *   - All nodes that reference this node via $ref (reverse dependencies)\n   *   - Combinator parents (allOf/anyOf/oneOf) if this node is a combinator child\n   *\n   * @param pointer - The JSON pointer of the node whose dependents to notify\n   * @param nodeInfo - The NodeInfo of the node\n   * @param childPointer - (Optional) The pointer of the child, used to detect combinator parents\n   */\n  const notifyAllDependents = (\n    pointer: string,\n    nodeInfo: NodeInfo,\n    childPointer?: string,\n  ) => {\n    if (nodeInfo.parentPointer) {\n      worklist.add(nodeInfo.parentPointer);\n    }\n    const reverseNodeDependencies = graph.reverseNodeDependencies.get(pointer);\n    if (reverseNodeDependencies) {\n      for (const dependentPointer of reverseNodeDependencies) {\n        worklist.add(dependentPointer);\n      }\n    }\n    if (childPointer) {\n      // If this is a combinator child, notify the combinator parent\n      const combinatorChildMatch = childPointer.match(\n        /(.*)\\/(allOf|anyOf|oneOf)\\/\\d+$/,\n      );\n      if (combinatorChildMatch) {\n        const combinatorParentPointer = combinatorChildMatch[1];\n        if (combinatorParentPointer) {\n          worklist.add(combinatorParentPointer);\n        }\n      }\n    }\n  };\n\n  /**\n   * Propagates scopes from a child node to its parent node.\n   * If the parent's scopes change, notifies all dependents.\n   *\n   * @param pointer - The parent node's pointer\n   * @param nodeInfo - The parent node's NodeInfo\n   * @param childPointer - The child node's pointer\n   */\n  const propagateChildScopes = (\n    pointer: string,\n    nodeInfo: NodeInfo,\n    childPointer: string,\n  ): void => {\n    if (!nodeInfo?.scopes) return;\n    const childInfo = graph.nodes.get(childPointer);\n    if (!childInfo?.scopes) return;\n    const changed = propagateScopesToNode(childInfo, nodeInfo);\n    if (changed) {\n      notifyAllDependents(pointer, nodeInfo, childPointer);\n    }\n  };\n\n  while (worklist.size > 0) {\n    const pointer = worklist.values().next().value!;\n    worklist.delete(pointer);\n\n    const nodeInfo = graph.nodes.get(pointer);\n    if (!nodeInfo) continue;\n\n    if (!nodeInfo.scopes) {\n      nodeInfo.scopes = new Set();\n    }\n\n    const node = nodeInfo.node as Record<string, unknown>;\n\n    // Propagate scopes from all child schema relationships (combinators, properties, etc.)\n    for (const [keyword, type] of childSchemaRelationships) {\n      if (!node || typeof node !== 'object' || !(keyword in node)) continue;\n      const value = node[keyword];\n      if (type === 'array' && value instanceof Array) {\n        for (let index = 0; index < value.length; index++) {\n          const childPointer = `${pointer}/${keyword}/${index}`;\n          propagateChildScopes(pointer, nodeInfo, childPointer);\n        }\n      } else if (\n        type === 'objectMap' &&\n        typeof value === 'object' &&\n        value !== null &&\n        !(value instanceof Array)\n      ) {\n        for (const key of Object.keys(value)) {\n          const childPointer = `${pointer}/${keyword}/${key}`;\n          propagateChildScopes(pointer, nodeInfo, childPointer);\n        }\n      } else if (\n        type === 'single' &&\n        typeof value === 'object' &&\n        value !== null\n      ) {\n        const childPointer = `${pointer}/${keyword}`;\n        propagateChildScopes(pointer, nodeInfo, childPointer);\n      } else if (type === 'singleOrArray') {\n        if (value instanceof Array) {\n          for (let index = 0; index < value.length; index++) {\n            const childPointer = `${pointer}/${keyword}/${index}`;\n            propagateChildScopes(pointer, nodeInfo, childPointer);\n          }\n        } else if (typeof value === 'object' && value !== null) {\n          const childPointer = `${pointer}/${keyword}`;\n          propagateChildScopes(pointer, nodeInfo, childPointer);\n        }\n      }\n    }\n\n    // Propagate scopes from $ref dependencies\n    const nodeDependencies = graph.nodeDependencies.get(pointer);\n    if (nodeDependencies) {\n      for (const depPointer of nodeDependencies) {\n        const depNode = graph.nodes.get(depPointer);\n        if (depNode?.scopes) {\n          const changed = propagateScopesToNode(depNode, nodeInfo);\n          if (changed) {\n            notifyAllDependents(pointer, nodeInfo);\n          }\n        }\n      }\n    }\n\n    // Propagate scopes up the parent chain\n    if (nodeInfo.parentPointer) {\n      const parentInfo = graph.nodes.get(nodeInfo.parentPointer);\n      if (parentInfo) {\n        const changed = propagateScopesToNode(nodeInfo, parentInfo);\n        if (changed) {\n          notifyAllDependents(nodeInfo.parentPointer, parentInfo);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Propagates scopes from one node to another.\n * Adds any scopes from fromNodeInfo to toNodeInfo that are not already present.\n * Returns true if any scopes were added, false otherwise.\n *\n * @param fromNodeInfo - The node to propagate scopes from\n * @param toNodeInfo - The node to propagate scopes to\n * @returns boolean - Whether any scopes were added\n */\nconst propagateScopesToNode = (\n  fromNodeInfo: NodeInfo,\n  toNodeInfo: NodeInfo,\n): boolean => {\n  if (!fromNodeInfo.scopes) {\n    return false;\n  }\n\n  if (!toNodeInfo.scopes) {\n    toNodeInfo.scopes = new Set();\n  }\n\n  let changed = false;\n\n  for (const scope of fromNodeInfo.scopes) {\n    if (!toNodeInfo.scopes.has(scope)) {\n      toNodeInfo.scopes.add(scope);\n      changed = true;\n    }\n  }\n\n  return changed;\n};\n\n/**\n * Seeds each node in the graph with its local access scope(s) based on its own properties.\n * - 'read' if readOnly: true\n * - 'write' if writeOnly: true\n * - 'normal' if node is an object property\n *\n * Only non-array objects are considered for scope seeding.\n *\n * @param nodes - Map of JSON Pointer to NodeInfo.\n */\nexport const seedLocalScopes = (nodes: Graph['nodes']): void => {\n  for (const [pointer, nodeInfo] of nodes) {\n    const { node } = nodeInfo;\n\n    if (typeof node !== 'object' || node === null || node instanceof Array) {\n      continue;\n    }\n\n    if ('readOnly' in node && node.readOnly === true) {\n      nodeInfo.scopes = new Set(['read']);\n    } else if ('writeOnly' in node && node.writeOnly === true) {\n      nodeInfo.scopes = new Set(['write']);\n    } else if (pointer.match(/\\/properties\\/[^/]+$/)) {\n      nodeInfo.scopes = new Set(['normal']);\n    }\n  }\n};\n\n/**\n * Builds a graph of all nodes in an OpenAPI spec, indexed by normalized JSON Pointer,\n * and tracks all $ref dependencies and reverse dependencies between nodes.\n *\n * - All keys in the returned maps are normalized JSON Pointers (RFC 6901, always starting with '#').\n * - The `nodes` map allows fast lookup of any node and its parent/key context.\n * - The `dependencies` map records, for each node, the set of normalized pointers it references via $ref.\n * - The `reverseNodeDependencies` map records, for each node, the set of nodes that reference it via $ref.\n * - After construction, all nodes will have their local and propagated scopes annotated.\n *\n * @param root The root object (e.g., the OpenAPI spec)\n * @returns An object with:\n *   - nodes: Map from normalized JSON Pointer string to NodeInfo\n *   - dependencies: Map from normalized JSON Pointer string to Set of referenced normalized JSON Pointers\n *   - reverseNodeDependencies: Map from normalized JSON Pointer string to Set of referencing normalized JSON Pointers\n */\nexport const buildGraph = (\n  root: unknown,\n  logger: Logger,\n): {\n  graph: Graph;\n} => {\n  const eventBuildGraph = logger.timeEvent('build-graph');\n  const graph: Graph = {\n    nodeDependencies: new Map(),\n    nodes: new Map(),\n    reverseNodeDependencies: new Map(),\n    subtreeDependencies: new Map(),\n    transitiveDependencies: new Map(),\n  };\n\n  const walk = ({\n    key,\n    node,\n    parentPointer,\n    path,\n  }: NodeInfo & {\n    path: ReadonlyArray<string | number>;\n  }) => {\n    if (typeof node !== 'object' || node === null) {\n      return;\n    }\n\n    const pointer = pathToJsonPointer(path);\n\n    let deprecated: boolean | undefined;\n    let tags: Set<string> | undefined;\n\n    if (typeof node === 'object' && node !== null) {\n      // Check for deprecated property\n      if ('deprecated' in node && typeof node.deprecated === 'boolean') {\n        deprecated = Boolean(node.deprecated);\n      }\n      // If this node has a $ref, record the dependency\n      if ('$ref' in node && typeof node.$ref === 'string') {\n        const refPointer = normalizeJsonPointer(node.$ref);\n        if (!graph.nodeDependencies.has(pointer)) {\n          graph.nodeDependencies.set(pointer, new Set());\n        }\n        graph.nodeDependencies.get(pointer)!.add(refPointer);\n      }\n      // Check for tags property (should be an array of strings)\n      if ('tags' in node && node.tags instanceof Array) {\n        tags = new Set(node.tags.filter((tag) => typeof tag === 'string'));\n      }\n    }\n\n    graph.nodes.set(pointer, { deprecated, key, node, parentPointer, tags });\n\n    if (node instanceof Array) {\n      node.forEach((item, index) =>\n        walk({\n          key: index,\n          node: item,\n          parentPointer: pointer,\n          path: [...path, index],\n        }),\n      );\n    } else {\n      for (const [childKey, value] of Object.entries(node)) {\n        walk({\n          key: childKey,\n          node: value,\n          parentPointer: pointer,\n          path: [...path, childKey],\n        });\n      }\n    }\n  };\n\n  walk({\n    key: null,\n    node: root,\n    parentPointer: null,\n    path: [],\n  });\n\n  const cache: Cache = {\n    parentToChildren: new Map(),\n    subtreeDependencies: new Map(),\n    transitiveDependencies: new Map(),\n  };\n\n  for (const [pointer, nodeInfo] of graph.nodes) {\n    const parent = nodeInfo.parentPointer;\n    if (!parent) continue;\n    if (!cache.parentToChildren.has(parent)) {\n      cache.parentToChildren.set(parent, []);\n    }\n    cache.parentToChildren.get(parent)!.push(pointer);\n  }\n\n  for (const [pointerFrom, pointers] of graph.nodeDependencies) {\n    for (const pointerTo of pointers) {\n      if (!graph.reverseNodeDependencies.has(pointerTo)) {\n        graph.reverseNodeDependencies.set(pointerTo, new Set());\n      }\n      graph.reverseNodeDependencies.get(pointerTo)!.add(pointerFrom);\n    }\n  }\n\n  seedLocalScopes(graph.nodes);\n  propagateScopes(graph);\n  annotateChildScopes(graph.nodes);\n\n  for (const pointer of graph.nodes.keys()) {\n    const result = collectPointerDependencies({\n      cache,\n      graph,\n      pointer,\n      visited: new Set(),\n    });\n    graph.transitiveDependencies.set(pointer, result.transitiveDependencies);\n    graph.subtreeDependencies.set(pointer, result.subtreeDependencies);\n  }\n\n  eventBuildGraph.timeEnd();\n\n  // functions creating data for debug scripts located in `dev/`\n  // const { maxChildren, maxDepth, totalNodes } = debugTools.graph.analyzeStructure(graph);\n  // const nodesForViz = debugTools.graph.exportForVisualization(graph);\n  // fs.writeFileSync('dev/graph.json', JSON.stringify(nodesForViz, null, 2));\n\n  return { graph };\n};\n","import type { Graph } from '~/graph';\nimport type { Logger } from '~/utils/logger';\nimport { applyNaming } from '~/utils/naming';\nimport { jsonPointerToPath } from '~/utils/ref';\n\nimport type { Config } from '../../../types/config';\nimport deepEqual from '../utils/deepEqual';\nimport { buildGraph, type Scope } from '../utils/graph';\nimport { deepClone } from '../utils/schema';\nimport { childSchemaRelationships } from '../utils/schemaChildRelationships';\nimport {\n  getSchemasObject,\n  hasComponentsSchemasObject,\n  hasDefinitionsObject,\n} from '../utils/transforms';\nimport {\n  getUniqueComponentName,\n  isPathRootSchema,\n  specToSchemasPointerNamespace,\n} from './utils';\n\ntype OriginalSchemas = Record<string, unknown>;\n\ntype SplitSchemas = {\n  /** Key is the original schema pointer. */\n  mapping: Record<\n    string,\n    {\n      read?: string;\n      write?: string;\n    }\n  >;\n  /** splitPointer -> originalPointer */\n  reverseMapping: Record<string, string>;\n  /** name -> schema object */\n  schemas: Record<string, unknown>;\n};\n\ntype ReadWriteConfig = Config['parser']['transforms']['readWrite'];\n\nconst schemaKeys = new Set([\n  'additionalProperties',\n  'allOf',\n  'anyOf',\n  'items',\n  'not',\n  'oneOf',\n  'patternProperties',\n  'properties',\n  'schema',\n]);\n\nconst getComponentContext = (\n  path: ReadonlyArray<string | number>,\n): Scope | undefined => {\n  // OpenAPI 3.x: #/components/{type}/{name}\n  if (path.length === 3 && path[0] === 'components') {\n    const type = path[1];\n    if (type === 'parameters') return 'write';\n    if (type === 'requestBodies') return 'write';\n    if (type === 'responses') return 'read';\n    if (type === 'headers') return 'read';\n  }\n  // OpenAPI 2.x: #/parameters/{name}, #/responses/{name}\n  if (path.length === 2) {\n    const type = path[0];\n    if (type === 'parameters') return 'write';\n    if (type === 'responses') return 'read';\n  }\n  return;\n};\n\n/**\n * Capture the original schema objects by pointer before splitting.\n * This is used to safely remove only the true originals after splitting,\n * even if names are swapped or overwritten by split variants.\n */\nconst captureOriginalSchemas = (\n  spec: unknown,\n  logger: Logger,\n): OriginalSchemas => {\n  const event = logger.timeEvent('capture-original-schemas');\n  const originals: OriginalSchemas = {};\n  if (hasComponentsSchemasObject(spec)) {\n    for (const [name, obj] of Object.entries(\n      (spec as any).components.schemas,\n    )) {\n      originals[`#/components/schemas/${name}`] = obj;\n    }\n  } else if (hasDefinitionsObject(spec)) {\n    for (const [name, obj] of Object.entries((spec as any).definitions)) {\n      originals[`#/definitions/${name}`] = obj;\n    }\n  }\n  event.timeEnd();\n  return originals;\n};\n\n/**\n * Inserts split schemas into the spec at the correct location (OpenAPI 3.x or 2.0).\n * This function is robust to spec version and will assign all split schemas\n * to either components.schemas (OAS3) or definitions (OAS2).\n *\n * @param spec - The OpenAPI spec object\n * @param split - The split schemas (from splitSchemas)\n */\nconst insertSplitSchemasIntoSpec = ({\n  logger,\n  spec,\n  split,\n}: {\n  logger: Logger;\n  spec: unknown;\n  split: Pick<SplitSchemas, 'schemas'>;\n}) => {\n  const event = logger.timeEvent('insert-split-schemas-into-spec');\n  if (hasComponentsSchemasObject(spec)) {\n    Object.assign((spec as any).components.schemas, split.schemas);\n  } else if (hasDefinitionsObject(spec)) {\n    Object.assign((spec as any).definitions, split.schemas);\n  }\n  event.timeEnd();\n};\n\n/**\n * Prunes a schema by removing all child schemas (in any structural keyword)\n * that are marked with the given scope (readOnly/writeOnly), or that are $ref to a schema\n * that is exclusively the excluded scope (according to the graph).\n *\n * Uses childSchemaRelationships for parity with graph traversal.\n * Returns true if the schema itself should be removed from its parent.\n *\n * @param graph - The Graph containing all nodes and their scopes\n * @param schema - The schema object to prune\n * @param scope - The scope to exclude ('readOnly' or 'writeOnly')\n * @returns boolean - Whether the schema should be removed from its parent\n */\nconst pruneSchemaByScope = (\n  graph: Graph,\n  schema: unknown,\n  scope: 'readOnly' | 'writeOnly',\n): boolean => {\n  if (schema && typeof schema === 'object') {\n    // Handle $ref schemas\n    if ('$ref' in schema && typeof schema.$ref === 'string') {\n      const nodeInfo = graph.nodes.get(schema.$ref);\n      if (nodeInfo?.scopes) {\n        // Only remove $ref if the referenced schema is *exclusively* the excluded scope.\n        // This ensures 'normal' or multi-scope schemas are always kept.\n        if (\n          (scope === 'writeOnly' &&\n            nodeInfo.scopes.size === 1 &&\n            nodeInfo.scopes.has('write')) ||\n          (scope === 'readOnly' &&\n            nodeInfo.scopes.size === 1 &&\n            nodeInfo.scopes.has('read'))\n        ) {\n          delete (schema as Record<string, unknown>)['$ref'];\n          // If the schema is now empty, remove it\n          if (\n            !childSchemaRelationships.some(([keyword]) => keyword in schema)\n          ) {\n            return true;\n          }\n        }\n      }\n    }\n    // Recursively prune all child schemas according to childSchemaRelationships\n    for (const [keyword, type] of childSchemaRelationships) {\n      if (!(keyword in schema)) {\n        continue;\n      }\n      const value = (schema as Record<string, unknown>)[keyword];\n      if (type === 'array' && value instanceof Array) {\n        for (let index = value.length - 1; index >= 0; index--) {\n          const item = value[index];\n          if (\n            item &&\n            typeof item === 'object' &&\n            (item as Record<string, unknown>)[scope] === true\n          ) {\n            value.splice(index, 1);\n          } else {\n            const shouldRemove = pruneSchemaByScope(graph, item, scope);\n            if (shouldRemove) value.splice(index, 1);\n          }\n        }\n        if (!value.length) {\n          delete (schema as Record<string, unknown>)[keyword];\n        }\n      } else if (\n        type === 'objectMap' &&\n        typeof value === 'object' &&\n        value !== null &&\n        !(value instanceof Array)\n      ) {\n        const objMap = value as Record<string, unknown>;\n        // Track removed properties for object schemas to update required array\n        const removedProperties = new Set<string>();\n\n        for (const key of Object.keys(objMap)) {\n          const prop = objMap[key];\n          if (\n            prop &&\n            typeof prop === 'object' &&\n            (prop as Record<string, unknown>)[scope] === true\n          ) {\n            delete objMap[key];\n            // Track removed properties for object schemas\n            if (keyword === 'properties') {\n              removedProperties.add(key);\n            }\n          } else {\n            const shouldRemove = pruneSchemaByScope(graph, prop, scope);\n            if (shouldRemove) {\n              delete objMap[key];\n              // Track removed properties for object schemas\n              if (keyword === 'properties') {\n                removedProperties.add(key);\n              }\n            }\n          }\n        }\n\n        // Update required array if properties were removed\n        if (\n          removedProperties.size > 0 &&\n          keyword === 'properties' &&\n          'required' in schema &&\n          Array.isArray((schema as Record<string, unknown>).required)\n        ) {\n          const required = (schema as Record<string, unknown>)\n            .required as string[];\n          const filteredRequired = required.filter(\n            (prop) => !removedProperties.has(prop),\n          );\n\n          if (!filteredRequired.length) {\n            delete (schema as Record<string, unknown>).required;\n          } else {\n            (schema as Record<string, unknown>).required = filteredRequired;\n          }\n        }\n\n        if (!Object.keys(objMap).length) {\n          delete (schema as Record<string, unknown>)[keyword];\n        }\n      } else if (\n        type === 'single' &&\n        typeof value === 'object' &&\n        value !== null\n      ) {\n        if ((value as Record<string, unknown>)[scope] === true) {\n          delete (schema as Record<string, unknown>)[keyword];\n        } else {\n          const shouldRemove = pruneSchemaByScope(graph, value, scope);\n          if (shouldRemove) {\n            delete (schema as Record<string, unknown>)[keyword];\n          }\n        }\n      } else if (type === 'singleOrArray') {\n        if (value instanceof Array) {\n          for (let index = value.length - 1; index >= 0; index--) {\n            const item = value[index];\n            if (\n              item &&\n              typeof item === 'object' &&\n              (item as Record<string, unknown>)[scope] === true\n            ) {\n              value.splice(index, 1);\n            } else {\n              const shouldRemove = pruneSchemaByScope(graph, item, scope);\n              if (shouldRemove) value.splice(index, 1);\n            }\n          }\n          if (!value.length) {\n            delete (schema as Record<string, unknown>)[keyword];\n          }\n        } else if (typeof value === 'object' && value !== null) {\n          if ((value as Record<string, unknown>)[scope] === true) {\n            delete (schema as Record<string, unknown>)[keyword];\n          } else {\n            const shouldRemove = pruneSchemaByScope(graph, value, scope);\n            if (shouldRemove) {\n              delete (schema as Record<string, unknown>)[keyword];\n            }\n          }\n        }\n      }\n    }\n    // After all removals, if this is type: object and has no structural fields, remove it\n    if (\n      (schema as Record<string, unknown>).type === 'object' &&\n      !childSchemaRelationships.some(([keyword]) => keyword in schema)\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Remove only the true original schemas that were split, by object identity.\n * This is robust to swaps, overwrites, and name collisions.\n *\n * @param originalSchemas - Map of original pointers to their schema objects (captured before splitting)\n * @param spec - The OpenAPI spec object\n * @param split - The split mapping (from splitSchemas)\n */\nconst removeOriginalSplitSchemas = ({\n  logger,\n  originalSchemas,\n  spec,\n  split,\n}: {\n  logger: Logger;\n  originalSchemas: OriginalSchemas;\n  spec: unknown;\n  split: Pick<SplitSchemas, 'mapping'>;\n}) => {\n  const event = logger.timeEvent('remove-original-split-schemas');\n  const schemasObj = getSchemasObject(spec);\n\n  for (const originalPointer of Object.keys(split.mapping)) {\n    const path = jsonPointerToPath(originalPointer);\n    const name = path[path.length - 1]!;\n    if (\n      typeof name === 'string' &&\n      schemasObj &&\n      Object.prototype.hasOwnProperty.call(schemasObj, name) &&\n      schemasObj[name] === originalSchemas[originalPointer]\n    ) {\n      delete schemasObj[name];\n    }\n  }\n  event.timeEnd();\n};\n\n/**\n * Splits schemas with both 'read' and 'write' scopes into read/write variants.\n * Returns the new schemas and a mapping from original pointer to new variant pointers.\n *\n * @param config - The readWrite transform config\n * @param graph - The Graph containing all nodes and their scopes\n * @param spec - The OpenAPI spec object\n * @returns SplitSchemas - The split schemas and pointer mappings\n */\nexport const splitSchemas = ({\n  config,\n  graph,\n  logger,\n  spec,\n}: {\n  config: ReadWriteConfig;\n  graph: Graph;\n  logger: Logger;\n  spec: unknown;\n}): SplitSchemas => {\n  const event = logger.timeEvent('split-schemas');\n  const existingNames = new Set<string>();\n  const split: SplitSchemas = {\n    mapping: {},\n    reverseMapping: {},\n    schemas: {},\n  };\n\n  const schemasPointerNamespace = specToSchemasPointerNamespace(spec);\n  const schemasNamespaceSegments =\n    schemasPointerNamespace.split('/').length - 1;\n\n  /**\n   * Extracts the schema name from pointer, but only if it's a top-level schema\n   * pointer. Returns an empty string if it's a nested pointer.\n   * @param pointer\n   * @returns Schema's base name.\n   */\n  const pointerToSchema = (pointer: string): string => {\n    if (pointer.startsWith(schemasPointerNamespace)) {\n      const path = jsonPointerToPath(pointer);\n      if (path.length === schemasNamespaceSegments) {\n        return path[schemasNamespaceSegments - 1] || '';\n      }\n    }\n    return '';\n  };\n\n  // Collect all existing schema names\n  for (const pointer of graph.nodes.keys()) {\n    const name = pointerToSchema(pointer);\n    if (name) existingNames.add(name);\n  }\n\n  for (const [pointer, nodeInfo] of graph.nodes) {\n    const name = pointerToSchema(pointer);\n    // Only split top-level schemas, with either read-only or write-only scopes (or both).\n    if (\n      !name ||\n      !(nodeInfo.scopes?.has('read') || nodeInfo.scopes?.has('write')) ||\n      !nodeInfo.scopes?.has('normal')\n    ) {\n      continue;\n    }\n\n    // read variant\n    const readSchema = deepClone<unknown>(nodeInfo.node);\n    pruneSchemaByScope(graph, readSchema, 'writeOnly');\n    const readBase = applyNaming(name, config.responses);\n    const readName =\n      readBase === name\n        ? readBase\n        : getUniqueComponentName({\n            base: readBase,\n            components: existingNames,\n          });\n    existingNames.add(readName);\n    split.schemas[readName] = readSchema;\n    const readPointer = `${schemasPointerNamespace}${readName}`;\n\n    // write variant\n    const writeSchema = deepClone<unknown>(nodeInfo.node);\n    pruneSchemaByScope(graph, writeSchema, 'readOnly');\n\n    // Check if this schema (or any of its descendants) references any schema that\n    // will need read/write variants. This is determined by checking transitive\n    // dependencies for schemas with both 'normal' and ('read' or 'write') scopes.\n    const transitiveDeps =\n      graph.transitiveDependencies.get(pointer) || new Set();\n    const referencesReadWriteSchemas = Array.from(transitiveDeps).some(\n      (depPointer) => {\n        const depNodeInfo = graph.nodes.get(depPointer);\n        return (\n          depNodeInfo?.scopes?.has('normal') &&\n          (depNodeInfo.scopes.has('read') || depNodeInfo.scopes.has('write'))\n        );\n      },\n    );\n\n    // If pruning did not change anything (both variants equal and equal to original),\n    // and the schema doesn't reference any schemas that will have read/write variants,\n    // skip splitting and keep the original single schema.\n    if (\n      !referencesReadWriteSchemas &&\n      deepEqual(readSchema, writeSchema) &&\n      deepEqual(readSchema, nodeInfo.node)\n    ) {\n      continue;\n    }\n    const writeBase = applyNaming(name, config.requests);\n    const writeName =\n      writeBase === name && writeBase !== readName\n        ? writeBase\n        : getUniqueComponentName({\n            base: writeBase,\n            components: existingNames,\n          });\n    existingNames.add(writeName);\n    split.schemas[writeName] = writeSchema;\n    const writePointer = `${schemasPointerNamespace}${writeName}`;\n\n    split.mapping[pointer] = {\n      read: readPointer,\n      write: writePointer,\n    };\n    split.reverseMapping[readPointer] = pointer;\n    split.reverseMapping[writePointer] = pointer;\n  }\n\n  event.timeEnd();\n  return split;\n};\n\ntype WalkArgs = {\n  context: Scope | null;\n  currentPointer: string | null;\n  inSchema: boolean;\n  node: unknown;\n  path: ReadonlyArray<string | number>;\n  visited?: Set<string>;\n};\n\n/**\n * Recursively updates $ref fields in the spec to point to the correct read/write variant\n * according to the current context (read/write), using the split mapping.\n *\n * @param spec - The OpenAPI spec object\n * @param split - The split mapping (from splitSchemas)\n */\nexport const updateRefsInSpec = ({\n  logger,\n  spec,\n  split,\n}: {\n  logger: Logger;\n  spec: unknown;\n  split: Omit<SplitSchemas, 'schemas'>;\n}): void => {\n  const event = logger.timeEvent('update-refs-in-spec');\n  const schemasPointerNamespace = specToSchemasPointerNamespace(spec);\n\n  const walk = ({\n    context,\n    currentPointer,\n    inSchema,\n    node,\n    path,\n    visited = new Set(),\n  }: WalkArgs): void => {\n    if (node instanceof Array) {\n      node.forEach((item, index) =>\n        walk({\n          context,\n          currentPointer,\n          inSchema,\n          node: item,\n          path: [...path, index],\n          visited,\n        }),\n      );\n    } else if (node && typeof node === 'object') {\n      // Detect if we're entering a split schema variant\n      let nextPointer = currentPointer;\n      let nextContext = context;\n      if (isPathRootSchema(path)) {\n        // Use the last path segment instead of a fixed index (path[2]) because\n        // path depth varies across OAS2/OAS3 and contexts; fixed indexing is brittle.\n        const nameSegment = path[path.length - 1] as string;\n        nextPointer = `${schemasPointerNamespace}${nameSegment}`;\n        const originalPointer = split.reverseMapping[nextPointer];\n        if (originalPointer) {\n          const mapping = split.mapping[originalPointer];\n          if (mapping?.read === nextPointer) {\n            nextContext = 'read';\n          } else if (mapping?.write === nextPointer) {\n            nextContext = 'write';\n          }\n        }\n        // For schemas that are not split variants, keep the inherited context.\n        // This ensures that $refs inside these schemas are resolved based on\n        // where the schema is actually used (requestBody vs responses), not\n        // based on the schema's own scopes which track readOnly/writeOnly fields.\n      }\n\n      const compContext = getComponentContext(path);\n      if (compContext !== undefined) {\n        // For each component, walk with the correct context\n        for (const key in node) {\n          if (!Object.prototype.hasOwnProperty.call(node, key)) {\n            continue;\n          }\n          walk({\n            context: compContext,\n            currentPointer: nextPointer,\n            inSchema: false,\n            node: (node as Record<string, unknown>)[key],\n            path: [...path, key],\n            visited,\n          });\n        }\n        return;\n      }\n\n      for (const key in node) {\n        if (!Object.prototype.hasOwnProperty.call(node, key)) {\n          continue;\n        }\n        const value = (node as Record<string, unknown>)[key];\n\n        // Only treat context switches at the OpenAPI structure level (not inside schemas)\n        if (!inSchema) {\n          if (key === 'requestBody') {\n            walk({\n              context: 'write',\n              currentPointer: nextPointer,\n              inSchema: false,\n              node: value,\n              path: [...path, key],\n              visited,\n            });\n            continue;\n          }\n          if (key === 'responses') {\n            walk({\n              context: 'read',\n              currentPointer: nextPointer,\n              inSchema: false,\n              node: value,\n              path: [...path, key],\n              visited,\n            });\n            continue;\n          }\n          if (key === 'parameters' && Array.isArray(value)) {\n            value.forEach((param, index) => {\n              if (param && typeof param === 'object' && 'schema' in param) {\n                walk({\n                  context: 'write',\n                  currentPointer: nextPointer,\n                  inSchema: true,\n                  node: param.schema,\n                  path: [...path, key, index, 'schema'],\n                  visited,\n                });\n              }\n              // Also handle content (OpenAPI 3.x)\n              if (param && typeof param === 'object' && 'content' in param) {\n                walk({\n                  context: 'write',\n                  currentPointer: nextPointer,\n                  inSchema: false,\n                  node: param.content,\n                  path: [...path, key, index, 'content'],\n                  visited,\n                });\n              }\n            });\n            continue;\n          }\n          // OpenAPI 3.x: headers in responses\n          if (\n            key === 'headers' &&\n            typeof value === 'object' &&\n            value !== null\n          ) {\n            for (const headerKey in value) {\n              if (!Object.prototype.hasOwnProperty.call(value, headerKey)) {\n                continue;\n              }\n              walk({\n                context: 'read',\n                currentPointer: nextPointer,\n                inSchema: false,\n                node: (value as Record<string, unknown>)[headerKey],\n                path: [...path, key, headerKey],\n                visited,\n              });\n            }\n            continue;\n          }\n        }\n\n        // Entering a schema context\n        if (schemaKeys.has(key)) {\n          walk({\n            context: nextContext,\n            currentPointer: nextPointer,\n            inSchema: true,\n            node: value,\n            path: [...path, key],\n            visited,\n          });\n        } else if (key === '$ref' && typeof value === 'string') {\n          // Prefer exact match first\n          const map = split.mapping[value];\n          if (map) {\n            if (nextContext === 'read' && map.read) {\n              (node as Record<string, unknown>)[key] = map.read;\n            } else if (nextContext === 'write' && map.write) {\n              (node as Record<string, unknown>)[key] = map.write;\n            } else if (!nextContext && map.read) {\n              // For schemas with no context (unused in operations), default to read variant\n              // This ensures $refs in unused schemas don't point to removed originals\n              (node as Record<string, unknown>)[key] = map.read;\n            }\n          }\n        } else {\n          walk({\n            context: nextContext,\n            currentPointer: nextPointer,\n            inSchema,\n            node: value,\n            path: [...path, key],\n            visited,\n          });\n        }\n      }\n    }\n  };\n  walk({\n    context: null,\n    currentPointer: null,\n    inSchema: false,\n    node: spec,\n    path: [],\n  });\n  event.timeEnd();\n};\n\n/**\n * Orchestrates the full read/write transform:\n * - Captures original schemas\n * - Splits schemas into read/write variants\n * - Inserts split schemas into the spec\n * - Updates $refs throughout the spec\n * - Removes original schemas that were split\n *\n * @param config - The readWrite transform config\n * @param spec - The OpenAPI spec object\n */\nexport const readWriteTransform = ({\n  config,\n  logger,\n  spec,\n}: {\n  config: ReadWriteConfig;\n  logger: Logger;\n  spec: unknown;\n}) => {\n  const { graph } = buildGraph(spec, logger);\n  const originalSchemas = captureOriginalSchemas(spec, logger);\n  const split = splitSchemas({ config, graph, logger, spec });\n  insertSplitSchemasIntoSpec({ logger, spec, split });\n  updateRefsInSpec({ logger, spec, split });\n  removeOriginalSplitSchemas({ logger, originalSchemas, spec, split });\n};\n","import type { Context } from '~/ir/context';\n\nimport { enumsTransform } from './enums';\nimport { propertiesRequiredByDefaultTransform } from './propertiesRequiredByDefault';\nimport { readWriteTransform } from './readWrite';\n\nexport const transformOpenApiSpec = ({ context }: { context: Context }) => {\n  const { logger } = context;\n  const eventTransformOpenApiSpec = logger.timeEvent('transform-openapi-spec');\n  if (context.config.parser.transforms.enums.enabled) {\n    enumsTransform({\n      config: context.config.parser.transforms.enums,\n      spec: context.spec,\n    });\n  }\n\n  if (context.config.parser.transforms.propertiesRequiredByDefault) {\n    propertiesRequiredByDefaultTransform({ spec: context.spec });\n  }\n\n  if (context.config.parser.transforms.readWrite.enabled) {\n    readWriteTransform({\n      config: context.config.parser.transforms.readWrite,\n      logger,\n      spec: context.spec,\n    });\n  }\n  eventTransformOpenApiSpec.timeEnd();\n};\n","import type { IR } from '~/ir/types';\n\nexport const mergeParametersObjects = ({\n  source,\n  target,\n}: {\n  source: IR.ParametersObject | undefined;\n  target: IR.ParametersObject | undefined;\n}): IR.ParametersObject | undefined => {\n  const result = { ...target };\n\n  if (source) {\n    if (source.cookie) {\n      if (result.cookie) {\n        result.cookie = {\n          ...result.cookie,\n          ...source.cookie,\n        };\n      } else {\n        result.cookie = source.cookie;\n      }\n    }\n\n    if (source.header) {\n      if (result.header) {\n        result.header = {\n          ...result.header,\n          ...source.header,\n        };\n      } else {\n        result.header = source.header;\n      }\n    }\n\n    if (source.path) {\n      if (result.path) {\n        result.path = {\n          ...result.path,\n          ...source.path,\n        };\n      } else {\n        result.path = source.path;\n      }\n    }\n\n    if (source.query) {\n      if (result.query) {\n        result.query = {\n          ...result.query,\n          ...source.query,\n        };\n      } else {\n        result.query = source.query;\n      }\n    }\n  }\n\n  if (!Object.keys(result).length) {\n    return;\n  }\n\n  return result;\n};\n","import colors from 'ansi-colors';\n\nimport type { Context } from '~/ir/context';\n\nexport interface ValidatorIssue {\n  /**\n   * Machine-readable issue code\n   *\n   * @example\n   * 'invalid_type'\n   */\n  code: 'duplicate_key' | 'invalid_type' | 'missing_required_field';\n  /**\n   * Optional additional data.\n   *\n   * @example\n   * 'expectedType'\n   */\n  context?: Record<string, any>;\n  /**\n   * Human-readable issue summary.\n   */\n  message: string;\n  /**\n   * JSONPath-like array to issue location.\n   */\n  path: ReadonlyArray<string | number>;\n  /**\n   * Error severity.\n   */\n  severity: 'error' | 'warning';\n}\n\nexport interface ValidatorResult {\n  issues: ReadonlyArray<ValidatorIssue>;\n  valid: boolean;\n}\n\nconst isSimpleKey = (key: string) => /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(key);\n\nconst formatPath = (path: ReadonlyArray<string | number>): string =>\n  path\n    .map((segment, i) => {\n      if (typeof segment === 'number') {\n        return `[${segment}]`;\n      }\n\n      if (i === 0) {\n        // first segment no dot or brackets\n        return segment;\n      }\n\n      return isSimpleKey(segment)\n        ? `.${segment}`\n        : `['${segment.replace(/\"/g, \"\\\\'\")}']`;\n    })\n    .join('');\n\nconst formatValidatorIssue = (issue: ValidatorIssue): string => {\n  const pathStr = formatPath(issue.path);\n  const level =\n    issue.severity === 'error' ? colors.bold.red : colors.bold.yellow;\n\n  const highlightedMessage = issue.message.replace(/`([^`]+)`/g, (_, code) =>\n    colors.yellow(`\\`${code}\\``),\n  );\n\n  return `${level(`[${issue.severity.toUpperCase()}]`)} ${colors.cyan(pathStr)}: ${highlightedMessage}`;\n};\n\nconst shouldPrint = ({\n  context,\n  issue,\n}: {\n  context: Context;\n  issue: ValidatorIssue;\n}) => {\n  if (context.config.logs.level === 'silent') {\n    return false;\n  }\n\n  if (issue.severity === 'error') {\n    return context.config.logs.level !== 'warn';\n  }\n\n  return true;\n};\n\nexport const handleValidatorResult = ({\n  context,\n  result,\n}: {\n  context: Context;\n  result: ValidatorResult;\n}) => {\n  for (const issue of result.issues) {\n    if (shouldPrint({ context, issue })) {\n      console.log(formatValidatorIssue(issue));\n    }\n  }\n\n  if (!result.valid) {\n    process.exit(1);\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { addNamespace, removeNamespace } from '~/openApi/shared/utils/filter';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type { Logger } from '~/utils/logger';\n\nimport type {\n  OpenApiV2_0_X,\n  OperationObject,\n  PathItemObject,\n  PathsObject,\n} from '../types/spec';\n\n/**\n * Replace source spec with filtered version.\n */\nexport const filterSpec = ({\n  logger,\n  operations,\n  preserveOrder,\n  schemas,\n  spec,\n}: {\n  logger: Logger;\n  operations: Set<string>;\n  parameters: Set<string>;\n  preserveOrder: boolean;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n  spec: OpenApiV2_0_X;\n}) => {\n  const eventFilterSpec = logger.timeEvent('filter-spec');\n  if (spec.definitions) {\n    const filtered: typeof spec.definitions = {};\n\n    if (preserveOrder) {\n      for (const [name, source] of Object.entries(spec.definitions)) {\n        if (schemas.has(addNamespace('schema', name))) {\n          filtered[name] = source;\n        }\n      }\n    } else {\n      for (const key of schemas) {\n        const { name } = removeNamespace(key);\n        const source = spec.definitions[name];\n        if (source) {\n          filtered[name] = source;\n        }\n      }\n    }\n\n    spec.definitions = filtered;\n  }\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n\n      for (const method of httpMethods) {\n        // @ts-expect-error\n        const operation = pathItem[method] as OperationObject;\n        if (!operation) {\n          continue;\n        }\n\n        const key = addNamespace(\n          'operation',\n          createOperationKey({ method, path }),\n        );\n        if (!operations.has(key)) {\n          // @ts-expect-error\n          delete pathItem[method];\n        }\n      }\n\n      // remove paths that have no operations left\n      if (!Object.keys(pathItem).length) {\n        delete spec.paths[path];\n      }\n    }\n  }\n  eventFilterSpec.timeEnd();\n};\n","const fileLikeRegExp =\n  /^(application\\/(pdf|rtf|msword|vnd\\.(ms-|openxmlformats-officedocument\\.)|zip|x-(7z|tar|rar|zip|iso)|octet-stream|gzip|x-msdownload|json\\+download|xml|x-yaml|x-7z-compressed|x-tar)|text\\/(yaml|css|javascript)|audio\\/(mpeg|wav)|video\\/(mp4|x-matroska)|image\\/(vnd\\.adobe\\.photoshop|svg\\+xml))(; ?charset=[^;]+)?$/i;\nconst jsonMimeRegExp = /^application\\/(.*\\+)?json(;.*)?$/i;\nconst multipartFormDataMimeRegExp = /^multipart\\/form-data(;.*)?$/i;\nconst textMimeRegExp = /^text\\/[a-z0-9.+-]+(;.*)?$/i;\nconst xWwwFormUrlEncodedMimeRegExp =\n  /^application\\/x-www-form-urlencoded(;.*)?$/i;\nconst octetStreamMimeRegExp = /^application\\/octet-stream(;.*)?$/i;\n\nexport type IRMediaType =\n  | 'form-data'\n  | 'json'\n  | 'text'\n  | 'url-search-params'\n  | 'octet-stream';\n\nexport const isMediaTypeFileLike = ({\n  mediaType,\n}: {\n  mediaType: string;\n}): boolean => {\n  fileLikeRegExp.lastIndex = 0;\n  return fileLikeRegExp.test(mediaType);\n};\n\nexport const mediaTypeToIrMediaType = ({\n  mediaType,\n}: {\n  mediaType: string;\n}): IRMediaType | undefined => {\n  jsonMimeRegExp.lastIndex = 0;\n  if (jsonMimeRegExp.test(mediaType)) {\n    return 'json';\n  }\n\n  multipartFormDataMimeRegExp.lastIndex = 0;\n  if (multipartFormDataMimeRegExp.test(mediaType)) {\n    return 'form-data';\n  }\n\n  textMimeRegExp.lastIndex = 0;\n  if (textMimeRegExp.test(mediaType)) {\n    return 'text';\n  }\n\n  xWwwFormUrlEncodedMimeRegExp.lastIndex = 0;\n  if (xWwwFormUrlEncodedMimeRegExp.test(mediaType)) {\n    return 'url-search-params';\n  }\n\n  octetStreamMimeRegExp.lastIndex = 0;\n  if (octetStreamMimeRegExp.test(mediaType)) {\n    return 'octet-stream';\n  }\n\n  return;\n};\n","import type { IRMediaType } from '~/ir/mediaType';\nimport { isMediaTypeFileLike, mediaTypeToIrMediaType } from '~/ir/mediaType';\n\nimport type {\n  ReferenceObject,\n  ResponseObject,\n  SchemaObject,\n} from '../types/spec';\n\ninterface Content {\n  mediaType: string;\n  schema: SchemaObject | ReferenceObject | undefined;\n  type: IRMediaType | undefined;\n}\n\nexport const contentToSchema = ({\n  content,\n}: {\n  content: Content;\n}): SchemaObject | undefined => {\n  const { mediaType, schema } = content;\n\n  if (schema && '$ref' in schema) {\n    return {\n      allOf: [{ ...schema }],\n    };\n  }\n\n  if (!schema) {\n    if (isMediaTypeFileLike({ mediaType })) {\n      return {\n        format: 'binary',\n        type: 'string',\n      };\n    }\n    return;\n  }\n\n  if (\n    schema.type === 'string' &&\n    !schema.format &&\n    isMediaTypeFileLike({ mediaType })\n  ) {\n    return {\n      ...schema,\n      format: 'binary',\n    };\n  }\n\n  return schema;\n};\n\nexport const mediaTypeObjects = ({\n  mimeTypes,\n  response,\n}: {\n  mimeTypes: ReadonlyArray<string> | undefined;\n  response: Pick<ResponseObject, 'schema'>;\n}): ReadonlyArray<Content> => {\n  const objects: Array<Content> = [];\n\n  for (const mediaType of mimeTypes ?? []) {\n    objects.push({\n      mediaType,\n      schema: response.schema,\n      type: mediaTypeToIrMediaType({ mediaType }),\n    });\n  }\n\n  return objects;\n};\n","import type { Config } from '~/types/config';\n\nimport type { IR } from './types';\n\nexport function getPaginationKeywordsRegExp(\n  pagination: Config['parser']['pagination'],\n): RegExp {\n  const pattern = `^(${pagination.keywords.join('|')})$`;\n  return new RegExp(pattern);\n}\n\nexport interface Pagination {\n  in: 'body' | 'cookie' | 'header' | 'path' | 'query';\n  name: string;\n  schema: IR.SchemaObject;\n}\n","import { refToName } from '~/utils/ref';\n\nexport const discriminatorValues = (\n  $ref: string,\n  mapping?: Record<string, string>,\n  shouldUseRefAsValue?: () => boolean,\n): ReadonlyArray<string> => {\n  const values: Array<string> = [];\n\n  for (const name in mapping) {\n    if (mapping[name] === $ref) {\n      values.push(name);\n    }\n  }\n\n  if (!values.length && (!shouldUseRefAsValue || shouldUseRefAsValue())) {\n    return [refToName($ref)];\n  }\n\n  return values;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { addItemsToSchema } from '~/ir/utils';\nimport type {\n  SchemaState,\n  SchemaType,\n  SchemaWithRequired,\n} from '~/openApi/shared/types/schema';\nimport { discriminatorValues } from '~/openApi/shared/utils/discriminator';\nimport { refToName } from '~/utils/ref';\n\nimport type { SchemaObject } from '../types/spec';\n\nexport const getSchemaType = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): SchemaType<SchemaObject> | undefined => {\n  if (schema.type) {\n    return schema.type;\n  }\n\n  // infer object based on the presence of properties\n  if (schema.properties) {\n    return 'object';\n  }\n\n  return;\n};\n\nconst parseSchemaJsDoc = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.example) {\n    irSchema.example = schema.example;\n  }\n\n  if (schema.description) {\n    irSchema.description = schema.description;\n  }\n\n  if (schema.title) {\n    irSchema.title = schema.title;\n  }\n};\n\nconst parseSchemaMeta = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.default !== undefined) {\n    irSchema.default = schema.default;\n  }\n\n  if (schema.exclusiveMaximum) {\n    if (schema.maximum !== undefined) {\n      irSchema.exclusiveMaximum = schema.maximum;\n    }\n  } else if (schema.maximum !== undefined) {\n    irSchema.maximum = schema.maximum;\n  }\n\n  if (schema.exclusiveMinimum) {\n    if (schema.minimum !== undefined) {\n      irSchema.exclusiveMinimum = schema.minimum;\n    }\n  } else if (schema.minimum !== undefined) {\n    irSchema.minimum = schema.minimum;\n  }\n\n  if (schema.format) {\n    irSchema.format = schema.format;\n  }\n\n  if (schema.maxItems !== undefined) {\n    irSchema.maxItems = schema.maxItems;\n  }\n\n  if (schema.maxLength !== undefined) {\n    irSchema.maxLength = schema.maxLength;\n  }\n\n  if (schema.minItems !== undefined) {\n    irSchema.minItems = schema.minItems;\n  }\n\n  if (schema.minLength !== undefined) {\n    irSchema.minLength = schema.minLength;\n  }\n\n  if (schema.pattern) {\n    irSchema.pattern = schema.pattern;\n  }\n\n  if (schema.readOnly) {\n    irSchema.accessScope = 'read';\n  }\n};\n\nconst parseArray = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (schema.maxItems && schema.maxItems === schema.minItems) {\n    irSchema.type = 'tuple';\n  } else {\n    irSchema.type = 'array';\n  }\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n\n  if (schema.items) {\n    const irItemsSchema = schemaToIrSchema({\n      context,\n      schema: schema.items,\n      state,\n    });\n\n    if (\n      !schemaItems.length &&\n      schema.maxItems &&\n      schema.maxItems === schema.minItems\n    ) {\n      schemaItems = Array(schema.maxItems).fill(irItemsSchema);\n    } else {\n      if ('$ref' in schema.items) {\n        schemaItems.push(irItemsSchema);\n      } else {\n        const ofArray = schema.items.allOf;\n        if (ofArray && ofArray.length > 1 && !schema.items['x-nullable']) {\n          // bring composition up to avoid incorrectly nested arrays\n          irSchema = {\n            ...irSchema,\n            ...irItemsSchema,\n          };\n        } else {\n          schemaItems.push(irItemsSchema);\n        }\n      }\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseBoolean = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'boolean';\n\n  return irSchema;\n};\n\nconst parseNumber = ({\n  irSchema = {},\n  schema,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = schema.type;\n\n  return irSchema;\n};\n\nconst parseObject = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'object';\n\n  const schemaProperties: Record<string, IR.SchemaObject> = {};\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    if (typeof property === 'boolean') {\n      // TODO: parser - handle boolean properties\n    } else {\n      const irPropertySchema = schemaToIrSchema({\n        context,\n        schema: property,\n        state,\n      });\n      schemaProperties[name] = irPropertySchema;\n    }\n  }\n\n  if (Object.keys(schemaProperties).length) {\n    irSchema.properties = schemaProperties;\n  }\n\n  if (schema.additionalProperties === undefined) {\n    if (!irSchema.properties) {\n      irSchema.additionalProperties = {\n        type: 'unknown',\n      };\n    }\n  } else if (typeof schema.additionalProperties === 'boolean') {\n    // Avoid [key: string]: never for empty objects with additionalProperties: false inside allOf\n    // This would override inherited properties from other schemas in the composition\n    const isEmptyObjectInAllOf =\n      state.inAllOf &&\n      schema.additionalProperties === false &&\n      (!schema.properties || !Object.keys(schema.properties).length);\n\n    if (!isEmptyObjectInAllOf) {\n      irSchema.additionalProperties = {\n        type: schema.additionalProperties ? 'unknown' : 'never',\n      };\n    }\n  } else {\n    const irAdditionalPropertiesSchema = schemaToIrSchema({\n      context,\n      schema: schema.additionalProperties,\n      state,\n    });\n    irSchema.additionalProperties = irAdditionalPropertiesSchema;\n  }\n\n  if (schema.required) {\n    irSchema.required = schema.required;\n  }\n\n  return irSchema;\n};\n\nconst parseString = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'string';\n\n  return irSchema;\n};\n\nexport const parseExtensions = ({\n  source,\n  target,\n}: {\n  source: object;\n  target: object;\n}) => {\n  for (const key in source) {\n    if (key.startsWith('x-')) {\n      (target as Record<string, unknown>)[key] = (\n        source as Record<string, unknown>\n      )[key];\n    }\n  }\n};\n\nconst initIrSchema = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {};\n\n  parseSchemaJsDoc({\n    irSchema,\n    schema,\n  });\n\n  parseExtensions({\n    source: schema,\n    target: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseAllOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'allOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaType = getSchemaType({ schema });\n\n  const compositionSchemas = schema.allOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    const originalInAllOf = state.inAllOf;\n    // Don't propagate inAllOf flag to $ref schemas to avoid issues with reusable components\n    if (!('$ref' in compositionSchema)) {\n      state.inAllOf = true;\n    }\n    const irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n    state.inAllOf = originalInAllOf;\n    if (state.inAllOf === undefined) {\n      delete state.inAllOf;\n    }\n\n    if (schema.required) {\n      if (irCompositionSchema.required) {\n        irCompositionSchema.required = [\n          ...irCompositionSchema.required,\n          ...schema.required,\n        ];\n      } else {\n        irCompositionSchema.required = schema.required;\n      }\n    }\n\n    schemaItems.push(irCompositionSchema);\n\n    if (compositionSchema.$ref) {\n      const ref = context.resolveRef<SchemaObject>(compositionSchema.$ref);\n      // `$ref` should be passed from the root `parseSchema()` call\n      if (ref.discriminator && state.$ref) {\n        const values = discriminatorValues(state.$ref);\n        const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n          (value) => ({\n            const: value,\n            type: 'string',\n          }),\n        );\n        const irDiscriminatorSchema: IR.SchemaObject = {\n          properties: {\n            [ref.discriminator]:\n              valueSchemas.length > 1\n                ? {\n                    items: valueSchemas,\n                    logicalOperator: 'or',\n                  }\n                : valueSchemas[0]!,\n          },\n          type: 'object',\n        };\n        if (ref.required?.includes(ref.discriminator)) {\n          irDiscriminatorSchema.required = [ref.discriminator];\n        }\n        schemaItems.push(irDiscriminatorSchema);\n      }\n    }\n  }\n\n  if (schemaType === 'object') {\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      for (const requiredProperty of irObjectSchema.required ?? []) {\n        if (!irObjectSchema.properties[requiredProperty]) {\n          for (const compositionSchema of compositionSchemas) {\n            // TODO: parser - this could be probably resolved more accurately\n            const finalCompositionSchema = compositionSchema.$ref\n              ? context.resolveRef<SchemaObject>(compositionSchema.$ref)\n              : compositionSchema;\n\n            if (\n              getSchemaType({ schema: finalCompositionSchema }) === 'object'\n            ) {\n              const irCompositionSchema = parseOneType({\n                context,\n                schema: {\n                  ...finalCompositionSchema,\n                  type: 'object',\n                },\n                state,\n              });\n\n              if (irCompositionSchema.properties?.[requiredProperty]) {\n                irObjectSchema.properties[requiredProperty] =\n                  irCompositionSchema.properties[requiredProperty];\n                break;\n              }\n            }\n          }\n        }\n      }\n      schemaItems.push(irObjectSchema);\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    logicalOperator: 'and',\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schema['x-nullable']) {\n    // nest composition to avoid producing an intersection with null\n    const nestedItems: Array<IR.SchemaObject> = [\n      {\n        type: 'null',\n      },\n    ];\n\n    if (schemaItems.length) {\n      nestedItems.unshift(irSchema);\n    }\n\n    irSchema = {\n      items: nestedItems,\n      logicalOperator: 'or',\n    };\n\n    // TODO: parser - this is a hack to bring back up meta fields\n    // without it, some schemas were missing original deprecated\n    if (nestedItems[0]!.deprecated) {\n      irSchema.deprecated = nestedItems[0]!.deprecated;\n    }\n\n    // TODO: parser - this is a hack to bring back up meta fields\n    // without it, some schemas were missing original description\n    if (nestedItems[0]!.description) {\n      irSchema.description = nestedItems[0]!.description;\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseEnum = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'enum'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  irSchema.type = 'enum';\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n\n  for (const [index, enumValue] of schema.enum.entries()) {\n    const typeOfEnumValue = typeof enumValue;\n    let enumType: SchemaType<SchemaObject> | 'null' | undefined;\n\n    if (\n      typeOfEnumValue === 'string' ||\n      typeOfEnumValue === 'number' ||\n      typeOfEnumValue === 'boolean'\n    ) {\n      enumType = typeOfEnumValue;\n    } else if (typeOfEnumValue === 'object' && Array.isArray(enumValue)) {\n      enumType = 'array';\n    } else if (enumValue === null) {\n      // nullable must be true\n      if (schema['x-nullable']) {\n        enumType = 'null';\n      }\n    } else {\n      console.warn(\n        'üö®',\n        `unhandled \"${typeOfEnumValue}\" typeof value \"${enumValue}\" for enum`,\n        schema.enum,\n      );\n    }\n\n    if (!enumType) {\n      continue;\n    }\n\n    const irTypeSchema = parseOneType({\n      context,\n      schema: {\n        description: schema['x-enum-descriptions']?.[index],\n        title:\n          schema['x-enum-varnames']?.[index] ?? schema['x-enumNames']?.[index],\n        // cast enum to string temporarily\n        type: enumType === 'null' ? 'string' : enumType,\n      },\n      state,\n    });\n\n    irTypeSchema.const = enumValue;\n\n    // cast enum back\n    if (enumType === 'null') {\n      irTypeSchema.type = enumType;\n    }\n\n    if (irTypeSchema.type === 'array') {\n      irTypeSchema.type = 'tuple';\n    }\n\n    schemaItems.push(irTypeSchema);\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseRef = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, '$ref'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {};\n  // Inline non-component refs (e.g. #/paths/...) to avoid generating orphaned named types\n  const isComponentsRef = schema.$ref.startsWith('#/definitions/');\n  if (!isComponentsRef) {\n    if (!state.circularReferenceTracker.has(schema.$ref)) {\n      const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n      const originalRef = state.$ref;\n      state.$ref = schema.$ref;\n      const irSchema = schemaToIrSchema({\n        context,\n        schema: refSchema,\n        state,\n      });\n      state.$ref = originalRef;\n      return irSchema;\n    }\n    // Fallback to preserving the ref if circular\n  }\n\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  irSchema.$ref = decodeURI(schema.$ref);\n\n  // rewrite definitions refs as the internal schema follows OpenAPI 3.x syntax\n  // and stores all definitions as reusable schemas\n  irSchema.$ref = irSchema.$ref.replace(\n    /#\\/definitions\\/([^/]+)/g,\n    '#/components/schemas/$1',\n  );\n\n  if (!state.circularReferenceTracker.has(schema.$ref)) {\n    const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n    const originalRef = state.$ref;\n    state.$ref = schema.$ref;\n    schemaToIrSchema({\n      context,\n      schema: refSchema,\n      state,\n    });\n    state.$ref = originalRef;\n  }\n\n  return irSchema;\n};\n\nconst parseNullableType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  const typeIrSchema: IR.SchemaObject = {};\n\n  parseSchemaMeta({ irSchema: typeIrSchema, schema });\n\n  if (typeIrSchema.default === null) {\n    // clear to avoid duplicate default inside the non-null schema.\n    // this would produce incorrect validator output\n    delete typeIrSchema.default;\n  }\n\n  const schemaItems: Array<IR.SchemaObject> = [\n    parseOneType({\n      context,\n      irSchema: typeIrSchema,\n      schema,\n      state,\n    }),\n    {\n      type: 'null',\n    },\n  ];\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseType = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  const irSchema = initIrSchema({ schema });\n\n  parseSchemaMeta({ irSchema, schema });\n\n  const type = getSchemaType({ schema });\n\n  if (!type) {\n    return irSchema;\n  }\n\n  if (schema['x-nullable']) {\n    return parseNullableType({\n      context,\n      irSchema,\n      schema: {\n        ...schema,\n        type,\n      },\n      state,\n    });\n  }\n\n  return parseOneType({\n    context,\n    irSchema,\n    schema: {\n      ...schema,\n      type,\n    },\n    state,\n  });\n};\n\nconst parseOneType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n\n    parseSchemaMeta({ irSchema, schema });\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return parseArray({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'boolean':\n      return parseBoolean({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'integer':\n    case 'number':\n      return parseNumber({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'object':\n      return parseObject({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'string':\n      return parseString({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    default:\n      // gracefully handle invalid type\n      return parseUnknown({\n        context,\n        irSchema,\n        schema,\n      });\n  }\n};\n\nconst parseUnknown = ({\n  irSchema,\n  schema,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  irSchema.type = 'unknown';\n\n  parseSchemaMeta({ irSchema, schema });\n\n  return irSchema;\n};\n\nexport const schemaToIrSchema = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaObject;\n  state: SchemaState | undefined;\n}): IR.SchemaObject => {\n  if (!state) {\n    state = {\n      circularReferenceTracker: new Set(),\n    };\n  }\n\n  if (state.$ref) {\n    state.circularReferenceTracker.add(state.$ref);\n  }\n\n  if (schema.$ref) {\n    return parseRef({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, '$ref'>,\n      state,\n    });\n  }\n\n  if (schema.enum) {\n    return parseEnum({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'enum'>,\n      state,\n    });\n  }\n\n  if (schema.allOf) {\n    return parseAllOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'allOf'>,\n      state,\n    });\n  }\n\n  // infer object based on the presence of properties\n  if (schema.type || schema.properties) {\n    return parseType({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'type'>,\n      state,\n    });\n  }\n\n  return parseUnknown({ context, schema });\n};\n\nexport const parseSchema = ({\n  $ref,\n  context,\n  schema,\n}: {\n  $ref: string;\n  context: Context;\n  schema: SchemaObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.schemas) {\n    context.ir.components.schemas = {};\n  }\n\n  context.ir.components.schemas[refToName($ref)] = schemaToIrSchema({\n    context,\n    schema,\n    state: {\n      $ref,\n      circularReferenceTracker: new Set(),\n    },\n  });\n};\n","import type { Context } from '~/ir/context';\nimport { getPaginationKeywordsRegExp } from '~/ir/pagination';\nimport type { SchemaType } from '~/openApi/shared/types/schema';\n\nimport type { ParameterObject, ReferenceObject } from '../types/spec';\nimport type { SchemaObject } from '../types/spec';\nimport { getSchemaType } from './schema';\n\nconst isPaginationType = (\n  schemaType: SchemaType<SchemaObject> | undefined,\n): boolean =>\n  schemaType === 'boolean' ||\n  schemaType === 'integer' ||\n  schemaType === 'number' ||\n  schemaType === 'string';\n\n// We handle only simple values for now, up to 1 nested field\nexport const paginationField = ({\n  context,\n  name,\n  schema,\n}: {\n  context: Context;\n  name: string;\n  schema:\n    | ParameterObject\n    | SchemaObject\n    | ReferenceObject\n    | {\n        in: undefined;\n      };\n}): boolean | string => {\n  const paginationRegExp = getPaginationKeywordsRegExp(\n    context.config.parser.pagination,\n  );\n  if (paginationRegExp.test(name)) {\n    return true;\n  }\n\n  if ('$ref' in schema) {\n    const ref = context.resolveRef<ParameterObject | SchemaObject>(\n      schema.$ref ?? '',\n    );\n\n    if ('in' in ref && ref.in) {\n      const refSchema =\n        'schema' in ref\n          ? ref.schema\n          : {\n              ...ref,\n              in: undefined,\n            };\n\n      return paginationField({\n        context,\n        name,\n        schema: refSchema,\n      });\n    }\n\n    return paginationField({\n      context,\n      name,\n      schema: ref,\n    });\n  }\n\n  if ('in' in schema) {\n    if (!schema.in) {\n      return false;\n    }\n\n    const finalSchema =\n      'schema' in schema\n        ? schema.schema\n        : {\n            ...schema,\n            in: undefined,\n          };\n\n    return paginationField({\n      context,\n      name,\n      schema: finalSchema,\n    });\n  }\n\n  for (const name in schema.properties) {\n    const paginationRegExp = getPaginationKeywordsRegExp(\n      context.config.parser.pagination,\n    );\n\n    if (paginationRegExp.test(name)) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean' && !('$ref' in property)) {\n        const schemaType = getSchemaType({ schema: property });\n        // TODO: resolve deeper references\n\n        if (isPaginationType(schemaType)) {\n          return name;\n        }\n      }\n    }\n  }\n\n  for (const allOf of schema.allOf ?? []) {\n    const pagination = paginationField({\n      context,\n      name,\n      schema: allOf,\n    });\n    if (pagination) {\n      return pagination;\n    }\n  }\n\n  return false;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR, IRBodyObject } from '~/ir/types';\nimport type { State } from '~/openApi/shared/types/state';\nimport { operationToId } from '~/openApi/shared/utils/operation';\n\nimport type {\n  OperationObject,\n  ParameterObject,\n  PathItemObject,\n  ResponseObject,\n  SchemaObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { contentToSchema, mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { parseExtensions, schemaToIrSchema } from './schema';\n\ninterface Operation\n  extends Omit<OperationObject, 'parameters'>,\n    Pick<IR.OperationObject, 'parameters'> {\n  requestBody?: OperationObject['parameters'];\n}\n\nconst parseOperationJsDoc = ({\n  irOperation,\n  operation,\n}: {\n  irOperation: IR.OperationObject;\n  operation: Operation;\n}) => {\n  if (operation.deprecated !== undefined) {\n    irOperation.deprecated = operation.deprecated;\n  }\n\n  if (operation.description) {\n    irOperation.description = operation.description;\n  }\n\n  if (operation.summary) {\n    irOperation.summary = operation.summary;\n  }\n\n  if (operation.tags?.length) {\n    irOperation.tags = operation.tags;\n  }\n};\n\nconst initIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: Context;\n  operation: Operation;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation: IR.OperationObject = {\n    id: operationToId({\n      context,\n      id: operation.operationId,\n      method,\n      path,\n      state,\n    }),\n    method,\n    path,\n  };\n\n  if (operation.operationId) {\n    irOperation.operationId = operation.operationId;\n  }\n\n  parseOperationJsDoc({\n    irOperation,\n    operation,\n  });\n\n  parseExtensions({\n    source: operation,\n    target: irOperation,\n  });\n\n  return irOperation;\n};\n\nconst operationToIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: Context;\n  operation: Operation;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation = initIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    state,\n  });\n\n  if (operation.parameters) {\n    irOperation.parameters = operation.parameters;\n  }\n\n  let isRequestBodyRequired = false;\n  const requestBodyObject: IRBodyObject = {\n    mediaType: '',\n    schema: {\n      properties: {},\n      required: [],\n      type: 'object',\n    },\n  };\n  const requestBodyObjectRequired: Array<string> = [];\n\n  // Check if there are any body parameters (not formData) to determine default media type\n  const hasBodyParameter = operation.requestBody?.some((param) => {\n    const resolvedParam =\n      '$ref' in param ? context.resolveRef<ParameterObject>(param.$ref) : param;\n    return resolvedParam.in === 'body';\n  });\n\n  for (const requestBodyParameter of operation.requestBody ?? []) {\n    const requestBody =\n      '$ref' in requestBodyParameter\n        ? context.resolveRef<ParameterObject>(requestBodyParameter.$ref)\n        : requestBodyParameter;\n    const schema: SchemaObject =\n      requestBody.in === 'body'\n        ? requestBody.schema\n        : {\n            ...requestBody,\n            format: requestBody.type === 'file' ? 'binary' : requestBody.format,\n            required: undefined,\n            type: requestBody.type === 'file' ? 'string' : requestBody.type,\n          };\n\n    // Only default to JSON if we have body parameters and no consumes specified\n    // FormData parameters without consumes should not get a default media type\n    let mimeTypes = operation.consumes;\n    if (!mimeTypes && hasBodyParameter && requestBody.in === 'body') {\n      mimeTypes = ['application/json'];\n    }\n\n    const contents = mediaTypeObjects({\n      mimeTypes,\n      response: { schema },\n    });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      const pagination = paginationField({\n        context,\n        name: '',\n        schema:\n          content.schema && '$ref' in content.schema\n            ? {\n                allOf: [{ ...content.schema }],\n                description: requestBody.description,\n              }\n            : {\n                description: requestBody.description,\n                ...content.schema,\n              },\n      });\n\n      const irSchema = schemaToIrSchema({\n        context,\n        schema:\n          '$ref' in requestBody\n            ? {\n                allOf: [\n                  {\n                    ...requestBody,\n                    $ref: requestBody.$ref as string,\n                    required: [],\n                    type: 'string',\n                  },\n                ],\n                description: requestBody.description,\n              }\n            : content.schema && '$ref' in content.schema\n              ? {\n                  allOf: [{ ...content.schema }],\n                  description: requestBody.description,\n                }\n              : {\n                  description: requestBody.description,\n                  ...content.schema,\n                },\n        state: undefined,\n      });\n\n      requestBodyObject.mediaType = content.mediaType;\n\n      if (requestBody.in === 'body') {\n        requestBodyObject.schema = irSchema;\n      } else {\n        requestBodyObject.schema.properties![requestBody.name] = irSchema;\n\n        if (requestBody.required) {\n          requestBodyObjectRequired.push(requestBody.name);\n        }\n      }\n\n      if (pagination) {\n        requestBodyObject.pagination = pagination;\n      }\n\n      if (content.type) {\n        requestBodyObject.type = content.type;\n      }\n    }\n\n    if (requestBody.required) {\n      isRequestBodyRequired = true;\n    }\n  }\n\n  if (requestBodyObject.mediaType) {\n    if (requestBodyObjectRequired.length) {\n      requestBodyObject.schema.required = requestBodyObjectRequired;\n    }\n\n    irOperation.body = requestBodyObject;\n\n    if (isRequestBodyRequired) {\n      irOperation.body.required = isRequestBodyRequired;\n    }\n  }\n\n  for (const name in operation.responses) {\n    if (!irOperation.responses) {\n      irOperation.responses = {};\n    }\n\n    const response = operation.responses[name]!;\n    const responseObject =\n      '$ref' in response\n        ? context.resolveRef<ResponseObject>(response.$ref)\n        : response;\n    const contents = mediaTypeObjects({\n      // assume JSON by default\n      mimeTypes: operation.produces ? operation.produces : ['application/json'],\n      response: responseObject,\n    });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      irOperation.responses[name] = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema: {\n            description: responseObject.description,\n            ...contentToSchema({ content }),\n          },\n          state: undefined,\n        }),\n      };\n    } else {\n      irOperation.responses[name] = {\n        schema: {\n          description: responseObject.description,\n          // TODO: parser - cover all statues with empty response bodies\n          // 1xx, 204, 205, 304\n          type: name === '204' ? 'void' : 'unknown',\n        },\n      };\n    }\n  }\n\n  if (operation.security) {\n    const securitySchemeObjects: Map<string, IR.SecurityObject> = new Map();\n\n    for (const securityRequirementObject of operation.security) {\n      for (const name in securityRequirementObject) {\n        const securitySchemeObject = securitySchemesMap.get(name);\n\n        if (!securitySchemeObject) {\n          continue;\n        }\n\n        let irSecuritySchemeObject: IR.SecurityObject | undefined;\n\n        if (securitySchemeObject.type === 'apiKey') {\n          irSecuritySchemeObject = securitySchemeObject;\n        }\n\n        if (securitySchemeObject.type === 'basic') {\n          irSecuritySchemeObject = {\n            description: securitySchemeObject.description,\n            scheme: 'basic',\n            type: 'http',\n          };\n        }\n\n        if (securitySchemeObject.type === 'oauth2') {\n          irSecuritySchemeObject = {\n            description: securitySchemeObject.description,\n            flows: {},\n            type: 'oauth2',\n          };\n\n          switch (securitySchemeObject.flow) {\n            case 'accessCode':\n              irSecuritySchemeObject.flows.authorizationCode = {\n                authorizationUrl: securitySchemeObject.authorizationUrl!,\n                scopes: securitySchemeObject.scopes,\n                tokenUrl: securitySchemeObject.tokenUrl!,\n              };\n              break;\n            case 'application':\n              irSecuritySchemeObject.flows.clientCredentials = {\n                scopes: securitySchemeObject.scopes,\n                tokenUrl: securitySchemeObject.tokenUrl!,\n              };\n              break;\n            case 'implicit':\n              irSecuritySchemeObject.flows.implicit = {\n                authorizationUrl: securitySchemeObject.authorizationUrl!,\n                scopes: securitySchemeObject.scopes,\n              };\n              break;\n            case 'password':\n              irSecuritySchemeObject.flows.password = {\n                scopes: securitySchemeObject.scopes,\n                tokenUrl: securitySchemeObject.tokenUrl!,\n              };\n              break;\n          }\n        }\n\n        if (!irSecuritySchemeObject) {\n          continue;\n        }\n\n        securitySchemeObjects.set(name, irSecuritySchemeObject);\n      }\n    }\n\n    if (securitySchemeObjects.size) {\n      irOperation.security = Array.from(securitySchemeObjects.values());\n    }\n  }\n\n  // TODO: parser - handle servers\n  // qux: operation.servers\n\n  return irOperation;\n};\n\nexport const parsePathOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: {\n  context: Context;\n  method: Extract<\n    keyof PathItemObject,\n    'delete' | 'get' | 'head' | 'options' | 'patch' | 'post' | 'put' | 'trace'\n  >;\n  operation: Operation;\n  path: keyof IR.PathsObject;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (!context.ir.paths) {\n    context.ir.paths = {};\n  }\n\n  if (!context.ir.paths[path]) {\n    context.ir.paths[path] = {};\n  }\n\n  context.ir.paths[path][method] = operationToIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    securitySchemesMap,\n    state,\n  });\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\n\nimport type {\n  OperationObject,\n  ParameterObject,\n  ReferenceObject,\n  SchemaObject,\n} from '../types/spec';\nimport { paginationField } from './pagination';\nimport { parseExtensions, schemaToIrSchema } from './schema';\n\ntype Parameter = Exclude<ParameterObject, { in: 'body' }>;\n\n/**\n * Returns default parameter `explode` based on value of `collectionFormat`.\n */\nconst defaultExplode = (\n  collectionFormat: Parameter['collectionFormat'],\n): boolean => {\n  switch (collectionFormat) {\n    case 'multi':\n      return true;\n    case 'csv':\n    case 'pipes':\n    case 'ssv':\n    case 'tsv':\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns default parameter `style` based on value of `in`.\n */\nconst defaultStyle = (\n  _in: Parameter['in'],\n): Required<IR.ParameterObject>['style'] => {\n  switch (_in) {\n    case 'header':\n    case 'path':\n      return 'simple';\n    case 'query':\n    default:\n      return 'form';\n  }\n};\n\nexport const parametersArrayToObject = ({\n  context,\n  operation,\n  parameters,\n}: {\n  context: Context;\n  operation: OperationObject;\n  parameters?: ReadonlyArray<ParameterObject | ReferenceObject>;\n}): IR.ParametersObject | undefined => {\n  if (!parameters || !Object.keys(parameters).length) {\n    return;\n  }\n\n  const parametersObject: IR.ParametersObject = {};\n\n  for (const parameterOrReference of parameters) {\n    const parameter =\n      '$ref' in parameterOrReference\n        ? context.dereference<ParameterObject>(parameterOrReference)\n        : parameterOrReference;\n\n    // push request body parameters into a separate field\n    if (parameter.in === 'body' || parameter.in === 'formData') {\n      // @ts-expect-error\n      if (!operation.requestBody) {\n        // @ts-expect-error\n        operation.requestBody = [];\n      }\n\n      // @ts-expect-error\n      operation.requestBody.push(parameter);\n      continue;\n    }\n\n    if (!parametersObject[parameter.in]) {\n      parametersObject[parameter.in] = {};\n    }\n\n    // lowercase keys for case insensitive access\n    parametersObject[parameter.in]![parameter.name.toLocaleLowerCase()] =\n      parameterToIrParameter({\n        $ref: `#/todo/real/path/to/parameter/${parameter.name}`,\n        context,\n        parameter,\n      });\n  }\n\n  return parametersObject;\n};\n\nconst parameterToIrParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: Context;\n  parameter: Parameter;\n}): IR.ParameterObject => {\n  const schema = parameter;\n\n  const finalSchema: SchemaObject =\n    schema && '$ref' in schema\n      ? {\n          allOf: [\n            {\n              ...schema,\n              $ref: schema.$ref as string,\n              required: Array.isArray(schema.required) ? schema.required : [],\n              type: schema.type as SchemaObject['type'],\n            },\n          ],\n          description: parameter.description,\n        }\n      : {\n          description: parameter.description,\n          ...schema,\n          required: Array.isArray(schema.required) ? schema.required : [],\n          type: schema.type as SchemaObject['type'],\n        };\n\n  const pagination = paginationField({\n    context,\n    name: parameter.name,\n    schema: finalSchema,\n  });\n\n  const style = defaultStyle(parameter.in);\n  const explode = defaultExplode(parameter.collectionFormat);\n  const allowReserved = false;\n\n  const irParameter: IR.ParameterObject = {\n    allowReserved,\n    explode,\n    location: parameter.in as IR.ParameterObject['location'],\n    name: parameter.name,\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n    style,\n  };\n\n  if (parameter.description) {\n    irParameter.description = parameter.description;\n  }\n\n  if (pagination) {\n    irParameter.pagination = pagination;\n  }\n\n  if (parameter.required) {\n    irParameter.required = parameter.required;\n  }\n\n  parseExtensions({\n    source: parameter,\n    target: irParameter,\n  });\n\n  return irParameter;\n};\n","import type { Context } from '~/ir/context';\nimport { parseUrl } from '~/utils/url';\n\nexport const parseServers = ({ context }: { context: Context }) => {\n  let schemes: ReadonlyArray<string> = context.spec.schemes ?? [];\n  let host = context.spec.host ?? '';\n  const path = context.spec.basePath ?? '';\n\n  for (const input of context.config.input) {\n    if (typeof input.path === 'string') {\n      const url = parseUrl(input.path);\n\n      if (!schemes.length) {\n        if (url.protocol) {\n          schemes = [url.protocol] as typeof schemes;\n        }\n      }\n\n      if (!host) {\n        host = `${url.host}${url.port ? `:${url.port}` : ''}`;\n      }\n    }\n  }\n\n  if (!schemes.length) {\n    schemes = [''];\n  }\n\n  const servers = schemes\n    .map((scheme) => `${scheme ? `${scheme}://` : ''}${host}${path}`)\n    .filter(Boolean);\n\n  if (servers.length) {\n    context.ir.servers = servers.map((url) => ({\n      url,\n    }));\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type {\n  ValidatorIssue,\n  ValidatorResult,\n} from '~/openApi/shared/utils/validator';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV2_0_X, PathItemObject, PathsObject } from '../types/spec';\n\nexport const validateOpenApiSpec = (\n  spec: OpenApiV2_0_X,\n  logger: Logger,\n): ValidatorResult => {\n  const eventValidate = logger.timeEvent('validate');\n  const issues: Array<ValidatorIssue> = [];\n  const operationIds = new Map();\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        if (method === 'trace') {\n          continue;\n        }\n\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const operationKey = createOperationKey({ method, path });\n\n        if (operation.operationId) {\n          if (!operationIds.has(operation.operationId)) {\n            operationIds.set(operation.operationId, operationKey);\n          } else {\n            issues.push({\n              code: 'duplicate_key',\n              context: {\n                key: 'operationId',\n                value: operation.operationId,\n              },\n              message:\n                'Duplicate `operationId` found. Each `operationId` must be unique.',\n              path: ['paths', path, method, 'operationId'],\n              severity: 'error',\n            });\n          }\n        }\n      }\n    }\n  }\n\n  eventValidate.timeEnd();\n  return {\n    issues,\n    valid: !issues.some((issue) => issue.severity === 'error'),\n  };\n};\n","import type { Context } from '~/ir/context';\nimport { buildResourceMetadata } from '~/openApi/shared/graph/meta';\nimport { transformOpenApiSpec } from '~/openApi/shared/transforms';\nimport type { State } from '~/openApi/shared/types/state';\nimport {\n  createFilteredDependencies,\n  createFilters,\n  hasFilters,\n} from '~/openApi/shared/utils/filter';\nimport { buildGraph } from '~/openApi/shared/utils/graph';\nimport { mergeParametersObjects } from '~/openApi/shared/utils/parameter';\nimport { handleValidatorResult } from '~/openApi/shared/utils/validator';\n\nimport type {\n  OpenApiV2_0_X,\n  OperationObject,\n  PathItemObject,\n  PathsObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { filterSpec } from './filter';\nimport { parsePathOperation } from './operation';\nimport { parametersArrayToObject } from './parameter';\nimport { parseSchema } from './schema';\nimport { parseServers } from './server';\nimport { validateOpenApiSpec } from './validate';\n\ntype PathKeys<T extends keyof PathsObject = keyof PathsObject> =\n  keyof T extends infer K ? (K extends `/${string}` ? K : never) : never;\n\nexport const parseV2_0_X = (context: Context<OpenApiV2_0_X>) => {\n  if (context.config.parser.validate_EXPERIMENTAL) {\n    const result = validateOpenApiSpec(context.spec, context.logger);\n    handleValidatorResult({ context, result });\n  }\n\n  const shouldFilterSpec = hasFilters(context.config.parser.filters);\n  if (shouldFilterSpec) {\n    const filters = createFilters(\n      context.config.parser.filters,\n      context.spec,\n      context.logger,\n    );\n    const { graph } = buildGraph(context.spec, context.logger);\n    const { resourceMetadata } = buildResourceMetadata(graph, context.logger);\n    const sets = createFilteredDependencies({\n      filters,\n      logger: context.logger,\n      resourceMetadata,\n    });\n    filterSpec({\n      ...sets,\n      logger: context.logger,\n      preserveOrder: filters.preserveOrder,\n      spec: context.spec,\n    });\n  }\n\n  transformOpenApiSpec({ context });\n\n  const state: State = {\n    ids: new Map(),\n  };\n  const securitySchemesMap = new Map<string, SecuritySchemeObject>();\n\n  for (const name in context.spec.securityDefinitions) {\n    const securitySchemeObject = context.spec.securityDefinitions[name]!;\n    securitySchemesMap.set(name, securitySchemeObject);\n  }\n\n  if (context.spec.definitions) {\n    for (const name in context.spec.definitions) {\n      const $ref = `#/definitions/${name}`;\n      const schema = context.spec.definitions[name]!;\n\n      parseSchema({\n        $ref,\n        context,\n        schema,\n      });\n    }\n  }\n\n  parseServers({ context });\n\n  for (const path in context.spec.paths) {\n    if (path.startsWith('x-')) continue;\n    const pathItem = context.spec.paths[path as PathKeys]!;\n\n    const finalPathItem = pathItem.$ref\n      ? {\n          ...context.resolveRef<PathItemObject>(pathItem.$ref),\n          ...pathItem,\n        }\n      : pathItem;\n\n    const commonOperation: OperationObject = {\n      consumes: context.spec.consumes,\n      produces: context.spec.produces,\n      responses: {},\n      security: context.spec.security,\n    };\n    const operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method'\n    > = {\n      context,\n      operation: {\n        ...commonOperation,\n        parameters: parametersArrayToObject({\n          context,\n          operation: commonOperation,\n          parameters: finalPathItem.parameters,\n        }),\n      },\n      path: path as PathKeys,\n      securitySchemesMap,\n      state,\n    };\n\n    if (finalPathItem.delete) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.delete,\n          parameters: finalPathItem.delete.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'delete',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.delete,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.get) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.get,\n          parameters: finalPathItem.get.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'get',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.get,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.head) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.head,\n          parameters: finalPathItem.head.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'head',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.head,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.options) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.options,\n          parameters: finalPathItem.options.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'options',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.options,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.patch) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.patch,\n          parameters: finalPathItem.patch.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'patch',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.patch,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.post) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.post,\n          parameters: finalPathItem.post.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'post',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.post,\n          parameters,\n        },\n      });\n    }\n\n    if (finalPathItem.put) {\n      const parameters = mergeParametersObjects({\n        source: parametersArrayToObject({\n          context,\n          operation: finalPathItem.put,\n          parameters: finalPathItem.put.parameters,\n        }),\n        target: operationArgs.operation.parameters,\n      });\n      parsePathOperation({\n        ...operationArgs,\n        method: 'put',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.put,\n          parameters,\n        },\n      });\n    }\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { addNamespace, removeNamespace } from '~/openApi/shared/utils/filter';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV3_0_X, PathItemObject, PathsObject } from '../types/spec';\n\n/**\n * Replace source spec with filtered version.\n */\nexport const filterSpec = ({\n  logger,\n  operations,\n  parameters,\n  preserveOrder,\n  requestBodies,\n  responses,\n  schemas,\n  spec,\n}: {\n  logger: Logger;\n  operations: Set<string>;\n  parameters: Set<string>;\n  preserveOrder: boolean;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n  spec: OpenApiV3_0_X;\n}) => {\n  const eventFilterSpec = logger.timeEvent('filter-spec');\n  if (spec.components) {\n    if (spec.components.parameters) {\n      const filtered: typeof spec.components.parameters = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.parameters,\n        )) {\n          if (parameters.has(addNamespace('parameter', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of parameters) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.parameters[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.parameters = filtered;\n    }\n\n    if (spec.components.requestBodies) {\n      const filtered: typeof spec.components.requestBodies = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.requestBodies,\n        )) {\n          if (requestBodies.has(addNamespace('body', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of requestBodies) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.requestBodies[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.requestBodies = filtered;\n    }\n\n    if (spec.components.responses) {\n      const filtered: typeof spec.components.responses = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.responses,\n        )) {\n          if (responses.has(addNamespace('response', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of responses) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.responses[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.responses = filtered;\n    }\n\n    if (spec.components.schemas) {\n      const filtered: typeof spec.components.schemas = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(spec.components.schemas)) {\n          if (schemas.has(addNamespace('schema', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of schemas) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.schemas[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.schemas = filtered;\n    }\n  }\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const key = addNamespace(\n          'operation',\n          createOperationKey({ method, path }),\n        );\n        if (!operations.has(key)) {\n          delete pathItem[method];\n        }\n      }\n\n      // remove paths that have no operations left\n      if (!Object.keys(pathItem).length) {\n        delete spec.paths[path];\n      }\n    }\n  }\n  eventFilterSpec.timeEnd();\n};\n","import type { IRMediaType } from '~/ir/mediaType';\nimport { isMediaTypeFileLike, mediaTypeToIrMediaType } from '~/ir/mediaType';\n\nimport type {\n  MediaTypeObject,\n  ReferenceObject,\n  SchemaObject,\n} from '../types/spec';\n\ninterface Content {\n  mediaType: string;\n  schema: SchemaObject | ReferenceObject | undefined;\n  type: IRMediaType | undefined;\n}\n\nexport const contentToSchema = ({\n  content,\n}: {\n  content: Content;\n}): SchemaObject | undefined => {\n  const { mediaType, schema } = content;\n\n  if (schema && '$ref' in schema) {\n    return {\n      allOf: [{ ...schema }],\n    };\n  }\n\n  if (!schema) {\n    if (isMediaTypeFileLike({ mediaType })) {\n      return {\n        format: 'binary',\n        type: 'string',\n      };\n    }\n    return;\n  }\n\n  if (\n    schema.type === 'string' &&\n    !schema.format &&\n    isMediaTypeFileLike({ mediaType })\n  ) {\n    return {\n      ...schema,\n      format: 'binary',\n    };\n  }\n\n  return schema;\n};\n\nexport const mediaTypeObjects = ({\n  content,\n}: {\n  content: Record<string, MediaTypeObject> | undefined;\n}): ReadonlyArray<Content> => {\n  const objects: Array<Content> = [];\n\n  for (const mediaType in content) {\n    objects.push({\n      mediaType,\n      schema: content[mediaType]!.schema,\n      type: mediaTypeToIrMediaType({ mediaType }),\n    });\n  }\n\n  return objects;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { addItemsToSchema } from '~/ir/utils';\nimport type {\n  SchemaState,\n  SchemaType,\n  SchemaWithRequired,\n} from '~/openApi/shared/types/schema';\nimport { discriminatorValues } from '~/openApi/shared/utils/discriminator';\nimport { refToName } from '~/utils/ref';\n\nimport type { ReferenceObject, SchemaObject } from '../types/spec';\n\nexport const getSchemaType = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): SchemaType<SchemaObject> | undefined => {\n  if (schema.type) {\n    return schema.type;\n  }\n\n  // infer object based on the presence of properties\n  if (schema.properties) {\n    return 'object';\n  }\n\n  return;\n};\n\n/**\n * Recursively finds discriminators in a schema, including nested allOf compositions.\n * This is needed when a schema extends another schema via allOf, and that parent\n * schema is itself an allOf composition with discriminators in inline schemas.\n */\nconst findDiscriminatorsInSchema = ({\n  context,\n  discriminators = [],\n  schema,\n}: {\n  context: Context;\n  discriminators?: Array<{\n    discriminator: NonNullable<SchemaObject['discriminator']>;\n    oneOf?: SchemaObject['oneOf'];\n  }>;\n  schema: SchemaObject;\n}): Array<{\n  discriminator: NonNullable<SchemaObject['discriminator']>;\n  oneOf?: SchemaObject['oneOf'];\n}> => {\n  // Check if this schema has a discriminator\n  if (schema.discriminator) {\n    discriminators.push({\n      discriminator: schema.discriminator,\n      oneOf: schema.oneOf,\n    });\n  }\n\n  // If this schema is an allOf composition, recursively search in its components\n  if (schema.allOf) {\n    for (const compositionSchema of schema.allOf) {\n      let resolvedSchema: SchemaObject;\n      if ('$ref' in compositionSchema) {\n        resolvedSchema = context.resolveRef<SchemaObject>(\n          compositionSchema.$ref,\n        );\n      } else {\n        resolvedSchema = compositionSchema;\n      }\n\n      findDiscriminatorsInSchema({\n        context,\n        discriminators,\n        schema: resolvedSchema,\n      });\n    }\n  }\n\n  return discriminators;\n};\n\n/**\n * Gets the discriminator value for a schema.\n * Returns only the schema's own discriminator value, not child values.\n */\nconst getAllDiscriminatorValues = ({\n  discriminator,\n  schemaRef,\n}: {\n  discriminator: NonNullable<SchemaObject['discriminator']>;\n  schemaRef: string;\n}): Array<string> => {\n  const values: Array<string> = [];\n\n  // Check each entry in the discriminator mapping\n  for (const [value, mappedSchemaRef] of Object.entries(\n    discriminator.mapping || {},\n  )) {\n    if (mappedSchemaRef === schemaRef) {\n      // This is the current schema's own value\n      values.push(value);\n    }\n  }\n\n  return values;\n};\n\nconst parseSchemaJsDoc = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.deprecated !== undefined) {\n    irSchema.deprecated = schema.deprecated;\n  }\n\n  if (schema.example) {\n    irSchema.example = schema.example;\n  }\n\n  if (schema.description) {\n    irSchema.description = schema.description;\n  }\n\n  if (schema.title) {\n    irSchema.title = schema.title;\n  }\n};\n\nconst parseSchemaMeta = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.default !== undefined) {\n    irSchema.default = schema.default;\n  }\n\n  if (schema.exclusiveMaximum) {\n    if (schema.maximum !== undefined) {\n      irSchema.exclusiveMaximum = schema.maximum;\n    }\n  } else if (schema.maximum !== undefined) {\n    irSchema.maximum = schema.maximum;\n  }\n\n  if (schema.exclusiveMinimum) {\n    if (schema.minimum !== undefined) {\n      irSchema.exclusiveMinimum = schema.minimum;\n    }\n  } else if (schema.minimum !== undefined) {\n    irSchema.minimum = schema.minimum;\n  }\n\n  if (schema.format) {\n    irSchema.format = schema.format;\n  }\n\n  if (schema.maxItems !== undefined) {\n    irSchema.maxItems = schema.maxItems;\n  }\n\n  if (schema.maxLength !== undefined) {\n    irSchema.maxLength = schema.maxLength;\n  }\n\n  if (schema.minItems !== undefined) {\n    irSchema.minItems = schema.minItems;\n  }\n\n  if (schema.minLength !== undefined) {\n    irSchema.minLength = schema.minLength;\n  }\n\n  if (schema.pattern) {\n    irSchema.pattern = schema.pattern;\n  }\n\n  if (schema.readOnly) {\n    irSchema.accessScope = 'read';\n  } else if (schema.writeOnly) {\n    irSchema.accessScope = 'write';\n  }\n};\n\nconst parseArray = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (schema.maxItems && schema.maxItems === schema.minItems) {\n    irSchema.type = 'tuple';\n  } else {\n    irSchema.type = 'array';\n  }\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n\n  if (schema.items) {\n    const irItemsSchema = schemaToIrSchema({\n      context,\n      schema: schema.items,\n      state,\n    });\n\n    if (\n      !schemaItems.length &&\n      schema.maxItems &&\n      schema.maxItems === schema.minItems\n    ) {\n      schemaItems = Array(schema.maxItems).fill(irItemsSchema);\n    } else {\n      if ('$ref' in schema.items) {\n        schemaItems.push(irItemsSchema);\n      } else {\n        const ofArray =\n          schema.items.allOf || schema.items.anyOf || schema.items.oneOf;\n        if (ofArray && ofArray.length > 1 && !schema.items.nullable) {\n          // bring composition up to avoid incorrectly nested arrays\n          irSchema = {\n            ...irSchema,\n            ...irItemsSchema,\n          };\n        } else {\n          schemaItems.push(irItemsSchema);\n        }\n      }\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseBoolean = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'boolean';\n\n  return irSchema;\n};\n\nconst parseNumber = ({\n  irSchema = {},\n  schema,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = schema.type;\n\n  return irSchema;\n};\n\nconst parseObject = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'object';\n\n  const schemaProperties: Record<string, IR.SchemaObject> = {};\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    if (typeof property === 'boolean') {\n      // TODO: parser - handle boolean properties\n    } else {\n      schemaProperties[name] = schemaToIrSchema({\n        context,\n        schema: property,\n        state,\n      });\n    }\n  }\n\n  if (Object.keys(schemaProperties).length) {\n    irSchema.properties = schemaProperties;\n  }\n\n  if (schema.additionalProperties === undefined) {\n    if (!irSchema.properties) {\n      irSchema.additionalProperties = {\n        type: 'unknown',\n      };\n    }\n  } else if (typeof schema.additionalProperties === 'boolean') {\n    // Avoid [key: string]: never for empty objects with additionalProperties: false inside allOf\n    // This would override inherited properties from other schemas in the composition\n    const isEmptyObjectInAllOf =\n      state.inAllOf &&\n      schema.additionalProperties === false &&\n      (!schema.properties || !Object.keys(schema.properties).length);\n\n    if (!isEmptyObjectInAllOf) {\n      irSchema.additionalProperties = {\n        type: schema.additionalProperties ? 'unknown' : 'never',\n      };\n    }\n  } else {\n    const irAdditionalPropertiesSchema = schemaToIrSchema({\n      context,\n      schema: schema.additionalProperties,\n      state,\n    });\n    irSchema.additionalProperties = irAdditionalPropertiesSchema;\n  }\n\n  if (schema.required) {\n    irSchema.required = schema.required;\n  }\n\n  return irSchema;\n};\n\nconst parseString = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'string';\n\n  return irSchema;\n};\n\nexport const parseExtensions = ({\n  source,\n  target,\n}: {\n  source: object;\n  target: object;\n}) => {\n  for (const key in source) {\n    if (key.startsWith('x-')) {\n      (target as Record<string, unknown>)[key] = (\n        source as Record<string, unknown>\n      )[key];\n    }\n  }\n};\n\nconst initIrSchema = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {};\n\n  parseSchemaJsDoc({\n    irSchema,\n    schema,\n  });\n\n  parseExtensions({\n    source: schema,\n    target: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseAllOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'allOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaType = getSchemaType({ schema });\n\n  const compositionSchemas = schema.allOf;\n\n  // Collect discriminator information to add after all compositions are processed\n  type DiscriminatorInfo = {\n    discriminator: NonNullable<SchemaObject['discriminator']>;\n    isRequired: boolean;\n    values: ReadonlyArray<string>;\n  };\n  const discriminatorsToAdd: Array<DiscriminatorInfo> = [];\n  const addedDiscriminators = new Set<string>();\n\n  for (const compositionSchema of compositionSchemas) {\n    const originalInAllOf = state.inAllOf;\n    // Don't propagate inAllOf flag to $ref schemas to avoid issues with reusable components\n    if (!('$ref' in compositionSchema)) {\n      state.inAllOf = true;\n    }\n    const irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n    state.inAllOf = originalInAllOf;\n    if (state.inAllOf === undefined) {\n      delete state.inAllOf;\n    }\n\n    if (schema.required) {\n      if (irCompositionSchema.required) {\n        irCompositionSchema.required = [\n          ...irCompositionSchema.required,\n          ...schema.required,\n        ];\n      } else {\n        irCompositionSchema.required = schema.required;\n      }\n    }\n\n    schemaItems.push(irCompositionSchema);\n\n    if ('$ref' in compositionSchema) {\n      const ref = context.resolveRef<SchemaObject>(compositionSchema.$ref);\n      // `$ref` should be passed from the root `parseSchema()` call\n      if (state.$ref) {\n        // Find all discriminators in the referenced schema, including nested allOf compositions\n        const discriminators = findDiscriminatorsInSchema({\n          context,\n          schema: ref,\n        });\n\n        // Process each discriminator found\n        for (const { discriminator, oneOf } of discriminators) {\n          // Skip if we've already collected this discriminator property\n          if (addedDiscriminators.has(discriminator.propertyName)) {\n            continue;\n          }\n\n          const values = discriminatorValues(\n            state.$ref,\n            discriminator.mapping,\n            // If the ref has oneOf, we only use the schema name as the value\n            // only if current schema is part of the oneOf. Else it is extending\n            // the ref schema\n            oneOf\n              ? () => oneOf.some((o) => '$ref' in o && o.$ref === state.$ref)\n              : undefined,\n          );\n\n          if (values.length > 0) {\n            // Check if the discriminator property is required in any of the discriminator schemas\n            const isRequired = discriminators.some(\n              (d) =>\n                d.discriminator.propertyName === discriminator.propertyName &&\n                // Check in the ref's required array or in the allOf components\n                (ref.required?.includes(d.discriminator.propertyName) ||\n                  (ref.allOf &&\n                    ref.allOf.some((item) => {\n                      const resolvedItem =\n                        '$ref' in item\n                          ? context.resolveRef<SchemaObject>(item.$ref)\n                          : item;\n                      return resolvedItem.required?.includes(\n                        d.discriminator.propertyName,\n                      );\n                    }))),\n            );\n\n            discriminatorsToAdd.push({\n              discriminator,\n              isRequired,\n              values,\n            });\n            addedDiscriminators.add(discriminator.propertyName);\n          }\n        }\n      }\n    }\n  }\n\n  // Now add discriminators after all compositions have been processed\n  for (const { discriminator, isRequired, values } of discriminatorsToAdd) {\n    // Get all discriminator values including children for union types\n    const allValues = getAllDiscriminatorValues({\n      discriminator,\n      schemaRef: state.$ref!,\n    });\n\n    // Use allValues if we found children, otherwise use the original values\n    const finalValues = allValues.length > 0 ? allValues : values;\n\n    const valueSchemas: ReadonlyArray<IR.SchemaObject> = finalValues.map(\n      (value) => ({\n        const: value,\n        type: 'string',\n      }),\n    );\n\n    const discriminatorProperty: IR.SchemaObject =\n      valueSchemas.length > 1\n        ? {\n            items: valueSchemas,\n            logicalOperator: 'or',\n          }\n        : valueSchemas[0]!;\n\n    // Check if any $ref schemas in schemaItems have this discriminator property\n    // If yes, mark them to omit it to avoid conflicts\n    for (const item of schemaItems) {\n      if (item.$ref || item.symbolRef) {\n        // Check if the referenced schema has this property\n        const hasProperty = (() => {\n          if (!item.$ref) return false;\n          try {\n            const refSchema = context.resolveRef<SchemaObject>(item.$ref);\n            // Check if the discriminator property exists in the ref schema\n            return (\n              refSchema.properties?.[discriminator.propertyName] !==\n                undefined ||\n              (refSchema.allOf &&\n                refSchema.allOf.some((allOfItem) => {\n                  const resolved =\n                    '$ref' in allOfItem\n                      ? context.resolveRef<SchemaObject>(allOfItem.$ref)\n                      : allOfItem;\n                  return (\n                    resolved.properties?.[discriminator.propertyName] !==\n                    undefined\n                  );\n                }))\n            );\n          } catch {\n            return false;\n          }\n        })();\n\n        if (hasProperty) {\n          // Mark this ref to omit the discriminator property\n          if (!item.omit) {\n            item.omit = [discriminator.propertyName];\n          } else if (!item.omit.includes(discriminator.propertyName)) {\n            item.omit = [...item.omit, discriminator.propertyName];\n          }\n        }\n      }\n    }\n\n    // Find the inline schema (non-$ref) to merge the discriminator property into\n    // The inline schema should be the last non-$ref item in schemaItems\n    let inlineSchema: IR.SchemaObject | undefined;\n    for (let i = schemaItems.length - 1; i >= 0; i--) {\n      const item = schemaItems[i]!;\n      // Check if this is not a $ref schema by looking for properties or checking if it came from an inline schema\n      if (item.type === 'object' || item.properties) {\n        inlineSchema = item;\n        break;\n      }\n    }\n\n    // If we found an inline schema, add the discriminator property to it\n    if (inlineSchema) {\n      if (!inlineSchema.properties) {\n        inlineSchema.properties = {};\n      }\n      inlineSchema.properties[discriminator.propertyName] =\n        discriminatorProperty;\n\n      if (isRequired) {\n        if (!inlineSchema.required) {\n          inlineSchema.required = [];\n        }\n        if (!inlineSchema.required.includes(discriminator.propertyName)) {\n          inlineSchema.required = [\n            ...inlineSchema.required,\n            discriminator.propertyName,\n          ];\n        }\n      }\n    } else {\n      // Fallback: create a separate discriminator schema if no inline schema found\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [discriminator.propertyName]: discriminatorProperty,\n        },\n        type: 'object',\n      };\n\n      if (isRequired) {\n        irDiscriminatorSchema.required = [discriminator.propertyName];\n      }\n      schemaItems.push(irDiscriminatorSchema);\n    }\n  }\n\n  if (schemaType === 'object') {\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      for (const requiredProperty of irObjectSchema.required ?? []) {\n        if (!irObjectSchema.properties[requiredProperty]) {\n          for (const compositionSchema of compositionSchemas) {\n            // TODO: parser - this could be probably resolved more accurately\n            const finalCompositionSchema =\n              '$ref' in compositionSchema\n                ? context.resolveRef<SchemaObject>(compositionSchema.$ref)\n                : compositionSchema;\n\n            if (\n              getSchemaType({ schema: finalCompositionSchema }) === 'object'\n            ) {\n              const irCompositionSchema = parseOneType({\n                context,\n                schema: {\n                  ...finalCompositionSchema,\n                  type: 'object',\n                },\n                state,\n              });\n\n              if (irCompositionSchema.properties?.[requiredProperty]) {\n                irObjectSchema.properties[requiredProperty] =\n                  irCompositionSchema.properties[requiredProperty];\n                break;\n              }\n            }\n          }\n        }\n      }\n      schemaItems.push(irObjectSchema);\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    logicalOperator: 'and',\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schema.nullable) {\n    // nest composition to avoid producing an intersection with null\n    const nestedItems: Array<IR.SchemaObject> = [\n      {\n        type: 'null',\n      },\n    ];\n\n    if (schemaItems.length) {\n      nestedItems.unshift(irSchema);\n    }\n\n    irSchema = {\n      items: nestedItems,\n      logicalOperator: 'or',\n    };\n\n    // TODO: parser - this is a hack to bring back up meta fields\n    // without it, some schemas were missing original deprecated\n    if (nestedItems[0]!.deprecated) {\n      irSchema.deprecated = nestedItems[0]!.deprecated;\n    }\n\n    // TODO: parser - this is a hack to bring back up meta fields\n    // without it, some schemas were missing original description\n    if (nestedItems[0]!.description) {\n      irSchema.description = nestedItems[0]!.description;\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseAnyOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'anyOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaType = getSchemaType({ schema });\n\n  const compositionSchemas = schema.anyOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    let irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n\n    // `$ref` should be defined with discriminators\n    if (schema.discriminator && irCompositionSchema.$ref != null) {\n      const values = discriminatorValues(\n        irCompositionSchema.$ref,\n        schema.discriminator.mapping,\n      );\n      const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n        (value) => ({\n          const: value,\n          type: 'string',\n        }),\n      );\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [schema.discriminator.propertyName]:\n            valueSchemas.length > 1\n              ? {\n                  items: valueSchemas,\n                  logicalOperator: 'or',\n                }\n              : valueSchemas[0]!,\n        },\n        type: 'object',\n      };\n      irCompositionSchema = {\n        items: [irDiscriminatorSchema, irCompositionSchema],\n        logicalOperator: 'and',\n      };\n    }\n\n    schemaItems.push(irCompositionSchema);\n  }\n\n  if (schema.nullable) {\n    schemaItems.push({ type: 'null' });\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaType === 'object') {\n    // nest composition to avoid producing a union with object properties\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      irSchema = {\n        items: [irSchema, irObjectSchema],\n        logicalOperator: 'and',\n      };\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseEnum = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'enum'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  irSchema.type = 'enum';\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n\n  for (const [index, enumValue] of schema.enum.entries()) {\n    const typeOfEnumValue = typeof enumValue;\n    let enumType: SchemaType<SchemaObject> | 'null' | undefined;\n\n    if (\n      typeOfEnumValue === 'string' ||\n      typeOfEnumValue === 'number' ||\n      typeOfEnumValue === 'boolean'\n    ) {\n      enumType = typeOfEnumValue;\n    } else if (typeOfEnumValue === 'object' && Array.isArray(enumValue)) {\n      enumType = 'array';\n    } else if (enumValue === null) {\n      // nullable must be true\n      if (schema.nullable) {\n        enumType = 'null';\n      }\n    } else {\n      console.warn(\n        'üö®',\n        `unhandled \"${typeOfEnumValue}\" typeof value \"${enumValue}\" for enum`,\n        schema.enum,\n      );\n    }\n\n    if (!enumType) {\n      continue;\n    }\n\n    const irTypeSchema = parseOneType({\n      context,\n      schema: {\n        description: schema['x-enum-descriptions']?.[index],\n        title:\n          schema['x-enum-varnames']?.[index] ?? schema['x-enumNames']?.[index],\n        // cast enum to string temporarily\n        type: enumType === 'null' ? 'string' : enumType,\n      },\n      state,\n    });\n\n    irTypeSchema.const = enumValue;\n\n    // cast enum back\n    if (enumType === 'null') {\n      irTypeSchema.type = enumType;\n    }\n\n    if (irTypeSchema.type === 'array') {\n      irTypeSchema.type = 'tuple';\n    }\n\n    schemaItems.push(irTypeSchema);\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseOneOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'oneOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n  const schemaType = getSchemaType({ schema });\n\n  const compositionSchemas = schema.oneOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    let irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n\n    // `$ref` should be defined with discriminators\n    if (schema.discriminator && irCompositionSchema.$ref != null) {\n      const values = discriminatorValues(\n        irCompositionSchema.$ref,\n        schema.discriminator.mapping,\n      );\n      const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n        (value) => ({\n          const: value,\n          type: 'string',\n        }),\n      );\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [schema.discriminator.propertyName]:\n            valueSchemas.length > 1\n              ? {\n                  items: valueSchemas,\n                  logicalOperator: 'or',\n                }\n              : valueSchemas[0]!,\n        },\n        required: [schema.discriminator.propertyName],\n        type: 'object',\n      };\n      irCompositionSchema = {\n        items: [irDiscriminatorSchema, irCompositionSchema],\n        logicalOperator: 'and',\n      };\n    }\n\n    // since we know oneOf will be using \"or\" logical operator, if the parsed\n    // composition schema also has an \"or\" operator, we can bring it up\n    // to avoid unnecessary brackets\n    if (\n      irCompositionSchema.logicalOperator === 'or' &&\n      irCompositionSchema.type !== 'array' &&\n      irCompositionSchema.items\n    ) {\n      schemaItems = schemaItems.concat(irCompositionSchema.items);\n    } else {\n      schemaItems.push(irCompositionSchema);\n    }\n  }\n\n  if (schema.nullable) {\n    schemaItems.push({ type: 'null' });\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaType === 'object') {\n    // nest composition to avoid producing a union with object properties\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      irSchema = {\n        items: [irSchema, irObjectSchema],\n        logicalOperator: 'and',\n      };\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseRef = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: ReferenceObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  // Inline non-component refs (e.g. #/paths/...) to avoid generating orphaned named types\n  const isComponentsRef = schema.$ref.startsWith('#/components/');\n  if (!isComponentsRef) {\n    if (!state.circularReferenceTracker.has(schema.$ref)) {\n      const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n      const originalRef = state.$ref;\n      state.$ref = schema.$ref;\n      const irSchema = schemaToIrSchema({\n        context,\n        schema: refSchema,\n        state,\n      });\n      state.$ref = originalRef;\n      return irSchema;\n    }\n    // Fallback to preserving the ref if circular\n  }\n\n  const irSchema: IR.SchemaObject = {};\n\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  irSchema.$ref = decodeURI(schema.$ref);\n\n  if (!state.circularReferenceTracker.has(schema.$ref)) {\n    const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n    const originalRef = state.$ref;\n    state.$ref = schema.$ref;\n    schemaToIrSchema({\n      context,\n      schema: refSchema,\n      state,\n    });\n    state.$ref = originalRef;\n  }\n\n  return irSchema;\n};\n\nconst parseNullableType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  const typeIrSchema: IR.SchemaObject = {};\n\n  parseSchemaMeta({ irSchema: typeIrSchema, schema });\n\n  if (typeIrSchema.default === null) {\n    // clear to avoid duplicate default inside the non-null schema.\n    // this would produce incorrect validator output\n    delete typeIrSchema.default;\n  }\n\n  const schemaItems: Array<IR.SchemaObject> = [\n    parseOneType({\n      context,\n      irSchema: typeIrSchema,\n      schema,\n      state,\n    }),\n    {\n      type: 'null',\n    },\n  ];\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseType = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  const irSchema = initIrSchema({ schema });\n\n  parseSchemaMeta({ irSchema, schema });\n\n  const type = getSchemaType({ schema });\n\n  if (!type) {\n    return irSchema;\n  }\n\n  if (!schema.nullable) {\n    return parseOneType({\n      context,\n      irSchema,\n      schema: {\n        ...schema,\n        type,\n      },\n      state,\n    });\n  }\n\n  return parseNullableType({\n    context,\n    irSchema,\n    schema: {\n      ...schema,\n      type,\n    },\n    state,\n  });\n};\n\nconst parseOneType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n\n    parseSchemaMeta({ irSchema, schema });\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return parseArray({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'boolean':\n      return parseBoolean({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'integer':\n    case 'number':\n      return parseNumber({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'object':\n      return parseObject({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'string':\n      return parseString({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    default:\n      // gracefully handle invalid type\n      return parseUnknown({\n        context,\n        irSchema,\n        schema,\n      });\n  }\n};\n\nconst parseUnknown = ({\n  irSchema,\n  schema,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  irSchema.type = 'unknown';\n\n  parseSchemaMeta({ irSchema, schema });\n\n  return irSchema;\n};\n\nexport const schemaToIrSchema = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaObject | ReferenceObject;\n  state: SchemaState | undefined;\n}): IR.SchemaObject => {\n  if (!state) {\n    state = {\n      circularReferenceTracker: new Set(),\n    };\n  }\n\n  if (state.$ref) {\n    state.circularReferenceTracker.add(state.$ref);\n  }\n\n  if ('$ref' in schema) {\n    return parseRef({\n      context,\n      schema,\n      state,\n    });\n  }\n\n  if (schema.enum) {\n    return parseEnum({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'enum'>,\n      state,\n    });\n  }\n\n  if (schema.allOf) {\n    return parseAllOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'allOf'>,\n      state,\n    });\n  }\n\n  if (schema.anyOf) {\n    return parseAnyOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'anyOf'>,\n      state,\n    });\n  }\n\n  if (schema.oneOf) {\n    return parseOneOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'oneOf'>,\n      state,\n    });\n  }\n\n  // infer object based on the presence of properties\n  if (schema.type || schema.properties) {\n    return parseType({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'type'>,\n      state,\n    });\n  }\n\n  return parseUnknown({ context, schema });\n};\n\nexport const parseSchema = ({\n  $ref,\n  context,\n  schema,\n}: {\n  $ref: string;\n  context: Context;\n  schema: SchemaObject | ReferenceObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.schemas) {\n    context.ir.components.schemas = {};\n  }\n\n  context.ir.components.schemas[refToName($ref)] = schemaToIrSchema({\n    context,\n    schema,\n    state: {\n      $ref,\n      circularReferenceTracker: new Set(),\n    },\n  });\n};\n","import type { Context } from '~/ir/context';\nimport { getPaginationKeywordsRegExp } from '~/ir/pagination';\nimport type { SchemaType } from '~/openApi/shared/types/schema';\n\nimport type {\n  ParameterObject,\n  ReferenceObject,\n  RequestBodyObject,\n} from '../types/spec';\nimport type { SchemaObject } from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { getSchemaType } from './schema';\n\nconst isPaginationType = (\n  schemaType: SchemaType<SchemaObject> | undefined,\n): boolean =>\n  schemaType === 'boolean' ||\n  schemaType === 'integer' ||\n  schemaType === 'number' ||\n  schemaType === 'string';\n\n// We handle only simple values for now, up to 1 nested field\nexport const paginationField = ({\n  context,\n  name,\n  schema,\n}: {\n  context: Context;\n  name: string;\n  schema: SchemaObject | ReferenceObject;\n}): boolean | string => {\n  const paginationRegExp = getPaginationKeywordsRegExp(\n    context.config.parser.pagination,\n  );\n  if (paginationRegExp.test(name)) {\n    return true;\n  }\n\n  if ('$ref' in schema) {\n    const ref = context.resolveRef<\n      ParameterObject | RequestBodyObject | SchemaObject\n    >(schema.$ref);\n\n    if ('content' in ref || 'in' in ref) {\n      let refSchema: SchemaObject | ReferenceObject | undefined;\n\n      if ('in' in ref) {\n        refSchema = ref.schema;\n      }\n\n      if (!refSchema) {\n        // parameter or body\n        const contents = mediaTypeObjects({ content: ref.content });\n        // TODO: add support for multiple content types, for now prefer JSON\n        const content =\n          contents.find((content) => content.type === 'json') || contents[0];\n        if (content?.schema) {\n          refSchema = content.schema;\n        }\n      }\n\n      if (!refSchema) {\n        return false;\n      }\n\n      return paginationField({\n        context,\n        name,\n        schema: refSchema,\n      });\n    }\n\n    return paginationField({\n      context,\n      name,\n      schema: ref,\n    });\n  }\n\n  for (const name in schema.properties) {\n    const paginationRegExp = getPaginationKeywordsRegExp(\n      context.config.parser.pagination,\n    );\n\n    if (paginationRegExp.test(name)) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean' && !('$ref' in property)) {\n        const schemaType = getSchemaType({ schema: property });\n        // TODO: resolve deeper references\n\n        if (isPaginationType(schemaType)) {\n          return name;\n        }\n      }\n    }\n  }\n\n  for (const allOf of schema.allOf ?? []) {\n    const pagination = paginationField({\n      context,\n      name,\n      schema: allOf,\n    });\n    if (pagination) {\n      return pagination;\n    }\n  }\n\n  return false;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport type { State } from '~/openApi/shared/types/state';\nimport { operationToId } from '~/openApi/shared/utils/operation';\n\nimport type {\n  OperationObject,\n  PathItemObject,\n  ReferenceObject,\n  RequestBodyObject,\n  ResponseObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { contentToSchema, mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { parseExtensions, schemaToIrSchema } from './schema';\n\ninterface Operation\n  extends Omit<OperationObject, 'parameters'>,\n    Pick<IR.OperationObject, 'parameters'> {}\n\nconst parseOperationJsDoc = ({\n  irOperation,\n  operation,\n}: {\n  irOperation: IR.OperationObject;\n  operation: Operation;\n}) => {\n  if (operation.deprecated !== undefined) {\n    irOperation.deprecated = operation.deprecated;\n  }\n\n  if (operation.description) {\n    irOperation.description = operation.description;\n  }\n\n  if (operation.summary) {\n    irOperation.summary = operation.summary;\n  }\n\n  if (operation.tags?.length) {\n    irOperation.tags = operation.tags;\n  }\n};\n\nconst initIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: Context;\n  operation: Operation;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation: IR.OperationObject = {\n    id: operationToId({\n      context,\n      id: operation.operationId,\n      method,\n      path,\n      state,\n    }),\n    method,\n    path,\n  };\n\n  if (operation.operationId) {\n    irOperation.operationId = operation.operationId;\n  }\n\n  parseOperationJsDoc({\n    irOperation,\n    operation,\n  });\n\n  parseExtensions({\n    source: operation,\n    target: irOperation,\n  });\n\n  return irOperation;\n};\n\nconst operationToIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: Context;\n  operation: Operation;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation = initIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    state,\n  });\n\n  if (operation.parameters) {\n    irOperation.parameters = operation.parameters;\n  }\n\n  if (operation.requestBody) {\n    const requestBody =\n      '$ref' in operation.requestBody\n        ? context.resolveRef<RequestBodyObject>(operation.requestBody.$ref)\n        : operation.requestBody;\n    const contents = mediaTypeObjects({ content: requestBody.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      const pagination = paginationField({\n        context,\n        name: '',\n        schema:\n          content.schema && '$ref' in content.schema\n            ? {\n                allOf: [{ ...content.schema }],\n                description: requestBody.description,\n              }\n            : {\n                description: requestBody.description,\n                ...content.schema,\n              },\n      });\n\n      irOperation.body = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema:\n            '$ref' in operation.requestBody\n              ? {\n                  allOf: [{ ...operation.requestBody }],\n                  description: requestBody.description,\n                }\n              : content.schema && '$ref' in content.schema\n                ? {\n                    allOf: [{ ...content.schema }],\n                    description: requestBody.description,\n                  }\n                : {\n                    description: requestBody.description,\n                    ...content.schema,\n                  },\n          state: undefined,\n        }),\n      };\n\n      if (pagination) {\n        irOperation.body.pagination = pagination;\n      }\n\n      if (requestBody.required) {\n        irOperation.body.required = requestBody.required;\n      }\n\n      if (content.type) {\n        irOperation.body.type = content.type;\n      }\n    }\n  }\n\n  for (const name in operation.responses) {\n    if (name.startsWith('x-')) continue;\n\n    if (!irOperation.responses) {\n      irOperation.responses = {};\n    }\n\n    const response = operation.responses[name]! as\n      | ResponseObject\n      | ReferenceObject;\n    const responseObject =\n      '$ref' in response\n        ? context.resolveRef<ResponseObject>(response.$ref)\n        : response;\n    const contents = mediaTypeObjects({ content: responseObject.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      irOperation.responses[name] = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema: {\n            description: responseObject.description,\n            ...contentToSchema({ content }),\n          },\n          state: undefined,\n        }),\n      };\n    } else {\n      irOperation.responses[name] = {\n        schema: {\n          description: responseObject.description,\n          // TODO: parser - cover all statues with empty response bodies\n          // 1xx, 204, 205, 304\n          type: name === '204' ? 'void' : 'unknown',\n        },\n      };\n    }\n  }\n\n  if (operation.security) {\n    const securitySchemeObjects: Map<string, IR.SecurityObject> = new Map();\n\n    for (const securityRequirementObject of operation.security) {\n      for (const name in securityRequirementObject) {\n        const securitySchemeObject = securitySchemesMap.get(name);\n\n        if (!securitySchemeObject) {\n          continue;\n        }\n\n        securitySchemeObjects.set(name, securitySchemeObject);\n      }\n    }\n\n    if (securitySchemeObjects.size) {\n      irOperation.security = Array.from(securitySchemeObjects.values());\n    }\n  }\n\n  // TODO: parser - handle servers\n  // qux: operation.servers\n\n  return irOperation;\n};\n\nexport const parsePathOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: {\n  context: Context;\n  method: Extract<\n    keyof PathItemObject,\n    'delete' | 'get' | 'head' | 'options' | 'patch' | 'post' | 'put' | 'trace'\n  >;\n  operation: Operation;\n  path: keyof IR.PathsObject;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (!context.ir.paths) {\n    context.ir.paths = {};\n  }\n\n  if (!context.ir.paths[path]) {\n    context.ir.paths[path] = {};\n  }\n\n  if (operation.servers) {\n    context.ir.servers = [...(context.ir.servers ?? []), ...operation.servers];\n  }\n\n  context.ir.paths[path][method] = operationToIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    securitySchemesMap,\n    state,\n  });\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { refToName } from '~/utils/ref';\n\nimport type {\n  ParameterObject,\n  ReferenceObject,\n  SchemaObject,\n} from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { parseExtensions, schemaToIrSchema } from './schema';\n\n/**\n * Returns default parameter `allowReserved` based on value of `in`.\n */\nconst defaultAllowReserved = (\n  _in: ParameterObject['in'],\n): boolean | undefined => {\n  switch (_in) {\n    // this keyword only applies to parameters with an `in` value of `query`\n    case 'query':\n      return false;\n    default:\n      return;\n  }\n};\n\n/**\n * Returns default parameter `explode` based on value of `style`.\n */\nconst defaultExplode = (style: Required<ParameterObject>['style']): boolean => {\n  switch (style) {\n    // default value for `deepObject` is `false`, but that behavior is undefined\n    // so we use `true` to make this work with the `client-fetch` package\n    case 'deepObject':\n    case 'form':\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns default parameter `style` based on value of `in`.\n */\nconst defaultStyle = (\n  _in: ParameterObject['in'],\n): Required<IR.ParameterObject>['style'] => {\n  switch (_in) {\n    case 'header':\n    case 'path':\n      return 'simple';\n    case 'cookie':\n    case 'query':\n      return 'form';\n  }\n};\n\nexport const parametersArrayToObject = ({\n  context,\n  parameters,\n}: {\n  context: Context;\n  parameters?: ReadonlyArray<ParameterObject | ReferenceObject>;\n}): IR.ParametersObject | undefined => {\n  if (!parameters || !Object.keys(parameters).length) {\n    return;\n  }\n\n  const parametersObject: IR.ParametersObject = {};\n\n  for (const parameterOrReference of parameters) {\n    const parameter =\n      '$ref' in parameterOrReference\n        ? context.dereference<ParameterObject>(parameterOrReference)\n        : parameterOrReference;\n\n    if (!parametersObject[parameter.in]) {\n      parametersObject[parameter.in] = {};\n    }\n\n    // lowercase keys for case insensitive access\n    parametersObject[parameter.in]![parameter.name.toLocaleLowerCase()] =\n      parameterToIrParameter({\n        $ref: `#/todo/real/path/to/parameter/${parameter.name}`,\n        context,\n        parameter,\n      });\n  }\n\n  return parametersObject;\n};\n\nconst parameterToIrParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: Context;\n  parameter: ParameterObject;\n}): IR.ParameterObject => {\n  // TODO: parser - fix\n  let schema = parameter.schema;\n\n  if (!schema) {\n    const contents = mediaTypeObjects({ content: parameter.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n    if (content) {\n      schema = content.schema;\n    }\n  }\n\n  const finalSchema: SchemaObject =\n    schema && '$ref' in schema\n      ? {\n          allOf: [{ ...schema }],\n          deprecated: parameter.deprecated,\n          description: parameter.description,\n        }\n      : {\n          deprecated: parameter.deprecated,\n          description: parameter.description,\n          ...schema,\n        };\n\n  const pagination = paginationField({\n    context,\n    name: parameter.name,\n    schema: finalSchema,\n  });\n\n  const style = parameter.style || defaultStyle(parameter.in);\n  const explode =\n    parameter.explode !== undefined ? parameter.explode : defaultExplode(style);\n  const allowReserved =\n    parameter.allowReserved !== undefined\n      ? parameter.allowReserved\n      : defaultAllowReserved(parameter.in);\n\n  const irParameter: IR.ParameterObject = {\n    allowReserved,\n    explode,\n    location: parameter.in,\n    name: parameter.name,\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n    style,\n  };\n\n  if (parameter.deprecated) {\n    irParameter.deprecated = parameter.deprecated;\n  }\n\n  if (parameter.description) {\n    irParameter.description = parameter.description;\n  }\n\n  if (pagination) {\n    irParameter.pagination = pagination;\n  }\n\n  if (parameter.required) {\n    irParameter.required = parameter.required;\n  }\n\n  parseExtensions({\n    source: parameter,\n    target: irParameter,\n  });\n\n  return irParameter;\n};\n\nexport const parseParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: Context;\n  parameter: ParameterObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.parameters) {\n    context.ir.components.parameters = {};\n  }\n\n  context.ir.components.parameters[refToName($ref)] = parameterToIrParameter({\n    $ref,\n    context,\n    parameter,\n  });\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { refToName } from '~/utils/ref';\n\nimport type { RequestBodyObject, SchemaObject } from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { schemaToIrSchema } from './schema';\n\nconst requestBodyToIrRequestBody = ({\n  $ref,\n  context,\n  requestBody,\n}: {\n  $ref: string;\n  context: Context;\n  requestBody: RequestBodyObject;\n}): IR.RequestBodyObject => {\n  // TODO: parser - fix\n  const contents = mediaTypeObjects({ content: requestBody.content });\n  // TODO: add support for multiple content types, for now prefer JSON\n  const content =\n    contents.find((content) => content.type === 'json') || contents[0];\n  const schema = content ? content.schema : undefined;\n\n  const finalSchema: SchemaObject = {\n    description: requestBody.description,\n    ...schema,\n  };\n\n  const irRequestBody: IR.RequestBodyObject = {\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n  };\n\n  if (requestBody.description) {\n    irRequestBody.description = requestBody.description;\n  }\n\n  if (requestBody.required) {\n    irRequestBody.required = requestBody.required;\n  }\n\n  return irRequestBody;\n};\n\nexport const parseRequestBody = ({\n  $ref,\n  context,\n  requestBody,\n}: {\n  $ref: string;\n  context: Context;\n  requestBody: RequestBodyObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.requestBodies) {\n    context.ir.components.requestBodies = {};\n  }\n\n  context.ir.components.requestBodies[refToName($ref)] =\n    requestBodyToIrRequestBody({\n      $ref,\n      context,\n      requestBody,\n    });\n};\n","import type { Context } from '~/ir/context';\nimport { parseUrl } from '~/utils/url';\n\nexport const parseServers = ({ context }: { context: Context }) => {\n  if (context.spec.servers) {\n    context.ir.servers = context.spec.servers;\n    return;\n  }\n\n  for (const input of context.config.input) {\n    if (typeof input.path === 'string') {\n      const url = parseUrl(input.path);\n      context.ir.servers = [\n        {\n          url: `${url.protocol ? `${url.protocol}://` : ''}${url.host}${url.port ? `:${url.port}` : ''}`,\n        },\n      ];\n    }\n  }\n\n  if (!context.ir.servers) {\n    context.ir.servers = [\n      {\n        url: '/',\n      },\n    ];\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type {\n  ValidatorIssue,\n  ValidatorResult,\n} from '~/openApi/shared/utils/validator';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV3_0_X, PathItemObject, PathsObject } from '../types/spec';\n\nexport const validateOpenApiSpec = (\n  spec: OpenApiV3_0_X,\n  logger: Logger,\n): ValidatorResult => {\n  const eventValidate = logger.timeEvent('validate');\n  const issues: Array<ValidatorIssue> = [];\n  const operationIds = new Map();\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const operationKey = createOperationKey({ method, path });\n\n        if (operation.operationId) {\n          if (!operationIds.has(operation.operationId)) {\n            operationIds.set(operation.operationId, operationKey);\n          } else {\n            issues.push({\n              code: 'duplicate_key',\n              context: {\n                key: 'operationId',\n                value: operation.operationId,\n              },\n              message:\n                'Duplicate `operationId` found. Each `operationId` must be unique.',\n              path: ['paths', path, method, 'operationId'],\n              severity: 'error',\n            });\n          }\n        }\n      }\n    }\n  }\n\n  if (spec.servers) {\n    if (typeof spec.servers !== 'object' || !Array.isArray(spec.servers)) {\n      issues.push({\n        code: 'invalid_type',\n        message: '`servers` must be an array.',\n        path: [],\n        severity: 'error',\n      });\n    }\n\n    for (let index = 0; index < spec.servers.length; index++) {\n      const server = spec.servers[index];\n      if (!server || typeof server !== 'object') {\n        issues.push({\n          code: 'invalid_type',\n          context: {\n            actual: typeof server,\n            expected: 'object',\n          },\n          message: 'Each entry in `servers` must be an object.',\n          path: ['servers', index],\n          severity: 'error',\n        });\n      } else {\n        if (!server.url) {\n          issues.push({\n            code: 'missing_required_field',\n            context: {\n              field: 'url',\n            },\n            message: 'Missing required field `url` in server object.',\n            path: ['servers', index],\n            severity: 'error',\n          });\n        }\n      }\n    }\n  }\n\n  eventValidate.timeEnd();\n  return {\n    issues,\n    valid: !issues.some((issue) => issue.severity === 'error'),\n  };\n};\n","import type { Context } from '~/ir/context';\nimport { buildResourceMetadata } from '~/openApi/shared/graph/meta';\nimport { transformOpenApiSpec } from '~/openApi/shared/transforms';\nimport type { State } from '~/openApi/shared/types/state';\nimport {\n  createFilteredDependencies,\n  createFilters,\n  hasFilters,\n} from '~/openApi/shared/utils/filter';\nimport { buildGraph } from '~/openApi/shared/utils/graph';\nimport { mergeParametersObjects } from '~/openApi/shared/utils/parameter';\nimport { handleValidatorResult } from '~/openApi/shared/utils/validator';\n\nimport type {\n  OpenApiV3_0_X,\n  ParameterObject,\n  PathItemObject,\n  PathsObject,\n  RequestBodyObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { filterSpec } from './filter';\nimport { parsePathOperation } from './operation';\nimport { parametersArrayToObject, parseParameter } from './parameter';\nimport { parseRequestBody } from './requestBody';\nimport { parseSchema } from './schema';\nimport { parseServers } from './server';\nimport { validateOpenApiSpec } from './validate';\n\nexport const parseV3_0_X = (context: Context<OpenApiV3_0_X>) => {\n  if (context.config.parser.validate_EXPERIMENTAL) {\n    const result = validateOpenApiSpec(context.spec, context.logger);\n    handleValidatorResult({ context, result });\n  }\n\n  const shouldFilterSpec = hasFilters(context.config.parser.filters);\n  if (shouldFilterSpec) {\n    const filters = createFilters(\n      context.config.parser.filters,\n      context.spec,\n      context.logger,\n    );\n    const { graph } = buildGraph(context.spec, context.logger);\n    const { resourceMetadata } = buildResourceMetadata(graph, context.logger);\n    const sets = createFilteredDependencies({\n      filters,\n      logger: context.logger,\n      resourceMetadata,\n    });\n    filterSpec({\n      ...sets,\n      logger: context.logger,\n      preserveOrder: filters.preserveOrder,\n      spec: context.spec,\n    });\n  }\n\n  transformOpenApiSpec({ context });\n\n  const state: State = {\n    ids: new Map(),\n  };\n  const securitySchemesMap = new Map<string, SecuritySchemeObject>();\n\n  // TODO: parser - handle more component types, old parser handles only parameters and schemas\n  if (context.spec.components) {\n    for (const name in context.spec.components.securitySchemes) {\n      const securityOrReference =\n        context.spec.components.securitySchemes[name]!;\n      const securitySchemeObject =\n        '$ref' in securityOrReference\n          ? context.resolveRef<SecuritySchemeObject>(securityOrReference.$ref)\n          : securityOrReference;\n      securitySchemesMap.set(name, securitySchemeObject);\n    }\n\n    for (const name in context.spec.components.parameters) {\n      const $ref = `#/components/parameters/${name}`;\n      const parameterOrReference = context.spec.components.parameters[name]!;\n      const parameter =\n        '$ref' in parameterOrReference\n          ? context.resolveRef<ParameterObject>(parameterOrReference.$ref)\n          : parameterOrReference;\n\n      parseParameter({\n        $ref,\n        context,\n        parameter,\n      });\n    }\n\n    for (const name in context.spec.components.requestBodies) {\n      const $ref = `#/components/requestBodies/${name}`;\n      const requestBodyOrReference =\n        context.spec.components.requestBodies[name]!;\n      const requestBody =\n        '$ref' in requestBodyOrReference\n          ? context.resolveRef<RequestBodyObject>(requestBodyOrReference.$ref)\n          : requestBodyOrReference;\n\n      parseRequestBody({\n        $ref,\n        context,\n        requestBody,\n      });\n    }\n\n    for (const name in context.spec.components.schemas) {\n      const $ref = `#/components/schemas/${name}`;\n      const schema = context.spec.components.schemas[name]!;\n\n      parseSchema({\n        $ref,\n        context,\n        schema,\n      });\n    }\n  }\n\n  parseServers({ context });\n\n  for (const path in context.spec.paths) {\n    if (path.startsWith('x-')) continue;\n    const pathItem = context.spec.paths[\n      path as keyof PathsObject\n    ]! as PathItemObject;\n\n    const finalPathItem = pathItem.$ref\n      ? {\n          ...context.resolveRef<PathItemObject>(pathItem.$ref),\n          ...pathItem,\n        }\n      : pathItem;\n\n    const operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method' | 'operation'\n    > & {\n      operation: Omit<\n        Parameters<typeof parsePathOperation>[0]['operation'],\n        'responses'\n      >;\n    } = {\n      context,\n      operation: {\n        description: finalPathItem.description,\n        parameters: parametersArrayToObject({\n          context,\n          parameters: finalPathItem.parameters,\n        }),\n        security: context.spec.security,\n        servers: finalPathItem.servers,\n        summary: finalPathItem.summary,\n      },\n      path: path as `/${string}`,\n      securitySchemesMap,\n      state,\n    };\n\n    if (finalPathItem.delete) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'delete',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.delete,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.delete.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.get) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'get',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.get,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.get.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.head) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'head',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.head,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.head.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.options) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'options',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.options,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.options.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.patch) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'patch',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.patch,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.patch.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.post) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'post',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.post,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.post.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.put) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'put',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.put,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.put.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.trace) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'trace',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.trace,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.trace.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { addNamespace, removeNamespace } from '~/openApi/shared/utils/filter';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV3_1_X, PathItemObject, PathsObject } from '../types/spec';\n\n/**\n * Replace source spec with filtered version.\n */\nexport const filterSpec = ({\n  logger,\n  operations,\n  parameters,\n  preserveOrder,\n  requestBodies,\n  responses,\n  schemas,\n  spec,\n}: {\n  logger: Logger;\n  operations: Set<string>;\n  parameters: Set<string>;\n  preserveOrder: boolean;\n  requestBodies: Set<string>;\n  responses: Set<string>;\n  schemas: Set<string>;\n  spec: OpenApiV3_1_X;\n}) => {\n  const eventFilterSpec = logger.timeEvent('filter-spec');\n  if (spec.components) {\n    if (spec.components.parameters) {\n      const filtered: typeof spec.components.parameters = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.parameters,\n        )) {\n          if (parameters.has(addNamespace('parameter', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of parameters) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.parameters[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.parameters = filtered;\n    }\n\n    if (spec.components.requestBodies) {\n      const filtered: typeof spec.components.requestBodies = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.requestBodies,\n        )) {\n          if (requestBodies.has(addNamespace('body', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of requestBodies) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.requestBodies[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.requestBodies = filtered;\n    }\n\n    if (spec.components.responses) {\n      const filtered: typeof spec.components.responses = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(\n          spec.components.responses,\n        )) {\n          if (responses.has(addNamespace('response', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of responses) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.responses[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.responses = filtered;\n    }\n\n    if (spec.components.schemas) {\n      const filtered: typeof spec.components.schemas = {};\n\n      if (preserveOrder) {\n        for (const [name, source] of Object.entries(spec.components.schemas)) {\n          if (schemas.has(addNamespace('schema', name))) {\n            filtered[name] = source;\n          }\n        }\n      } else {\n        for (const key of schemas) {\n          const { name } = removeNamespace(key);\n          const source = spec.components.schemas[name];\n          if (source) {\n            filtered[name] = source;\n          }\n        }\n      }\n\n      spec.components.schemas = filtered;\n    }\n  }\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const key = addNamespace(\n          'operation',\n          createOperationKey({ method, path }),\n        );\n        if (!operations.has(key)) {\n          delete pathItem[method];\n        }\n      }\n\n      // remove paths that have no operations left\n      if (!Object.keys(pathItem).length) {\n        delete spec.paths[path];\n      }\n    }\n  }\n  eventFilterSpec.timeEnd();\n};\n","import type { IRMediaType } from '~/ir/mediaType';\nimport { isMediaTypeFileLike, mediaTypeToIrMediaType } from '~/ir/mediaType';\n\nimport type { MediaTypeObject, SchemaObject } from '../types/spec';\n\ninterface Content {\n  mediaType: string;\n  schema: SchemaObject | undefined;\n  type: IRMediaType | undefined;\n}\n\nexport const contentToSchema = ({\n  content,\n}: {\n  content: Content;\n}): SchemaObject | undefined => {\n  const { mediaType, schema } = content;\n\n  if (!schema) {\n    if (isMediaTypeFileLike({ mediaType })) {\n      return {\n        format: 'binary',\n        type: 'string',\n      };\n    }\n    return;\n  }\n\n  if (\n    schema.type === 'string' &&\n    !schema.format &&\n    isMediaTypeFileLike({ mediaType })\n  ) {\n    return {\n      ...schema,\n      format: 'binary',\n    };\n  }\n\n  return schema;\n};\n\nexport const mediaTypeObjects = ({\n  content,\n}: {\n  content: Record<string, MediaTypeObject> | undefined;\n}): ReadonlyArray<Content> => {\n  const objects: Array<Content> = [];\n\n  for (const mediaType in content) {\n    objects.push({\n      mediaType,\n      schema: content[mediaType]!.schema,\n      type: mediaTypeToIrMediaType({ mediaType }),\n    });\n  }\n\n  return objects;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { addItemsToSchema } from '~/ir/utils';\nimport type {\n  SchemaState,\n  SchemaType,\n  SchemaWithRequired,\n} from '~/openApi/shared/types/schema';\nimport { discriminatorValues } from '~/openApi/shared/utils/discriminator';\nimport { refToName } from '~/utils/ref';\n\nimport type { SchemaObject } from '../types/spec';\n\nexport const getSchemaTypes = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): ReadonlyArray<SchemaType<SchemaObject>> => {\n  if (typeof schema.type === 'string') {\n    return [schema.type];\n  }\n\n  if (schema.type) {\n    return schema.type;\n  }\n\n  // infer object based on the presence of properties\n  if (schema.properties) {\n    return ['object'];\n  }\n\n  return [];\n};\n\n/**\n * Recursively finds discriminators in a schema, including nested allOf compositions.\n * This is needed when a schema extends another schema via allOf, and that parent\n * schema is itself an allOf composition with discriminators in inline schemas.\n */\nconst findDiscriminatorsInSchema = ({\n  context,\n  discriminators = [],\n  schema,\n}: {\n  context: Context;\n  discriminators?: Array<{\n    discriminator: NonNullable<SchemaObject['discriminator']>;\n    oneOf?: SchemaObject['oneOf'];\n  }>;\n  schema: SchemaObject;\n}): Array<{\n  discriminator: NonNullable<SchemaObject['discriminator']>;\n  oneOf?: SchemaObject['oneOf'];\n}> => {\n  // Check if this schema has a discriminator\n  if (schema.discriminator) {\n    discriminators.push({\n      discriminator: schema.discriminator,\n      oneOf: schema.oneOf,\n    });\n  }\n\n  // If this schema is an allOf composition, recursively search in its components\n  if (schema.allOf) {\n    for (const compositionSchema of schema.allOf) {\n      let resolvedSchema: SchemaObject;\n      if (compositionSchema.$ref) {\n        resolvedSchema = context.resolveRef<SchemaObject>(\n          compositionSchema.$ref,\n        );\n      } else {\n        resolvedSchema = compositionSchema;\n      }\n\n      findDiscriminatorsInSchema({\n        context,\n        discriminators,\n        schema: resolvedSchema,\n      });\n    }\n  }\n\n  return discriminators;\n};\n\n/**\n * Gets the discriminator value for a schema.\n * Returns only the schema's own discriminator value, not child values.\n */\nconst getAllDiscriminatorValues = ({\n  discriminator,\n  schemaRef,\n}: {\n  discriminator: NonNullable<SchemaObject['discriminator']>;\n  schemaRef: string;\n}): Array<string> => {\n  const values: Array<string> = [];\n\n  // Check each entry in the discriminator mapping\n  for (const [value, mappedSchemaRef] of Object.entries(\n    discriminator.mapping || {},\n  )) {\n    if (mappedSchemaRef === schemaRef) {\n      // This is the current schema's own value\n      values.push(value);\n    }\n  }\n\n  return values;\n};\n\nconst parseSchemaJsDoc = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.deprecated !== undefined) {\n    irSchema.deprecated = schema.deprecated;\n  }\n\n  if (schema.example) {\n    irSchema.example = schema.example;\n  }\n\n  if (schema.description) {\n    irSchema.description = schema.description;\n  }\n\n  if (schema.title) {\n    irSchema.title = schema.title;\n  }\n};\n\nconst parseSchemaMeta = ({\n  irSchema,\n  schema,\n}: {\n  irSchema: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  if (schema.const !== undefined) {\n    irSchema.const = schema.const;\n\n    // try to infer schema type\n    if (!schema.type) {\n      if (schema.const === null) {\n        irSchema.type = 'null';\n      } else {\n        switch (typeof schema.const) {\n          case 'bigint':\n          case 'number':\n            irSchema.type = 'number';\n            break;\n          case 'boolean':\n            irSchema.type = 'boolean';\n            break;\n          case 'string':\n            irSchema.type = 'string';\n            break;\n        }\n      }\n    }\n  }\n\n  if (schema.default !== undefined) {\n    irSchema.default = schema.default;\n  }\n\n  if (schema.exclusiveMaximum !== undefined) {\n    irSchema.exclusiveMaximum = schema.exclusiveMaximum;\n  }\n\n  if (schema.exclusiveMinimum !== undefined) {\n    irSchema.exclusiveMinimum = schema.exclusiveMinimum;\n  }\n\n  if (schema.format) {\n    irSchema.format = schema.format;\n  }\n\n  if (schema.maximum !== undefined) {\n    irSchema.maximum = schema.maximum;\n  }\n\n  if (schema.maxItems !== undefined) {\n    irSchema.maxItems = schema.maxItems;\n  }\n\n  if (schema.maxLength !== undefined) {\n    irSchema.maxLength = schema.maxLength;\n  }\n\n  if (schema.minimum !== undefined) {\n    irSchema.minimum = schema.minimum;\n  }\n\n  if (schema.minItems !== undefined) {\n    irSchema.minItems = schema.minItems;\n  }\n\n  if (schema.minLength !== undefined) {\n    irSchema.minLength = schema.minLength;\n  }\n\n  if (schema.pattern) {\n    irSchema.pattern = schema.pattern;\n  }\n\n  if (schema.readOnly) {\n    irSchema.accessScope = 'read';\n  } else if (schema.writeOnly) {\n    irSchema.accessScope = 'write';\n  }\n};\n\nconst parseArray = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (\n    (schema.prefixItems && schema.prefixItems.length) ||\n    (schema.maxItems && schema.maxItems === schema.minItems) ||\n    schema.const !== undefined\n  ) {\n    irSchema.type = 'tuple';\n  } else {\n    irSchema.type = 'array';\n  }\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n\n  for (const item of schema.prefixItems ?? []) {\n    const irItemSchema = schemaToIrSchema({\n      context,\n      schema: item,\n      state,\n    });\n    schemaItems.push(irItemSchema);\n  }\n\n  if (schema.items) {\n    const irItemsSchema = schemaToIrSchema({\n      context,\n      schema: schema.items,\n      state,\n    });\n\n    if (\n      !schemaItems.length &&\n      schema.maxItems &&\n      schema.maxItems === schema.minItems\n    ) {\n      schemaItems = Array(schema.maxItems).fill(irItemsSchema);\n    } else {\n      const ofArray =\n        schema.items.allOf || schema.items.anyOf || schema.items.oneOf;\n      if (\n        ofArray &&\n        ofArray.length > 1 &&\n        !getSchemaTypes({ schema: schema.items }).includes('null')\n      ) {\n        // bring composition up to avoid incorrectly nested arrays\n        irSchema = {\n          ...irSchema,\n          ...irItemsSchema,\n        };\n      } else {\n        schemaItems.push(irItemsSchema);\n      }\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseBoolean = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  irSchema.type = 'boolean';\n\n  return irSchema;\n};\n\nconst parseNull = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}) => {\n  irSchema.type = 'null';\n\n  return irSchema;\n};\n\nconst parseNumber = ({\n  irSchema = {},\n  schema,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: Omit<SchemaObject, 'type'> & {\n    type: SchemaType<SchemaObject>;\n  };\n}): IR.SchemaObject => {\n  irSchema.type = schema.type;\n\n  return irSchema;\n};\n\nconst parseObject = ({\n  context,\n  irSchema = {},\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  irSchema.type = 'object';\n\n  const schemaProperties: Record<string, IR.SchemaObject> = {};\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    if (typeof property === 'boolean') {\n      // TODO: parser - handle boolean properties\n    } else {\n      const irPropertySchema = schemaToIrSchema({\n        context,\n        schema: property,\n        state,\n      });\n      schemaProperties[name] = irPropertySchema;\n    }\n  }\n\n  if (Object.keys(schemaProperties).length) {\n    irSchema.properties = schemaProperties;\n  }\n\n  if (schema.additionalProperties === undefined) {\n    if (!irSchema.properties) {\n      irSchema.additionalProperties = {\n        type: 'unknown',\n      };\n    }\n  } else if (typeof schema.additionalProperties === 'boolean') {\n    // Avoid [key: string]: never for empty objects with additionalProperties: false inside allOf\n    // This would override inherited properties from other schemas in the composition\n    const isEmptyObjectInAllOf =\n      state.inAllOf &&\n      schema.additionalProperties === false &&\n      (!schema.properties || !Object.keys(schema.properties).length) &&\n      (!schema.patternProperties ||\n        !Object.keys(schema.patternProperties).length);\n\n    if (!isEmptyObjectInAllOf) {\n      irSchema.additionalProperties = {\n        type: schema.additionalProperties ? 'unknown' : 'never',\n      };\n    }\n  } else {\n    const irAdditionalPropertiesSchema = schemaToIrSchema({\n      context,\n      schema: schema.additionalProperties,\n      state,\n    });\n    irSchema.additionalProperties = irAdditionalPropertiesSchema;\n  }\n\n  if (schema.patternProperties) {\n    const patternProperties: Record<string, IR.SchemaObject> = {};\n\n    for (const pattern in schema.patternProperties) {\n      const patternSchema = schema.patternProperties[pattern]!;\n      const irPatternSchema = schemaToIrSchema({\n        context,\n        schema: patternSchema,\n        state,\n      });\n      patternProperties[pattern] = irPatternSchema;\n    }\n\n    if (Object.keys(patternProperties).length) {\n      irSchema.patternProperties = patternProperties;\n    }\n  }\n\n  if (schema.propertyNames) {\n    irSchema.propertyNames = schemaToIrSchema({\n      context,\n      schema: schema.propertyNames,\n      state,\n    });\n  }\n\n  if (schema.required) {\n    irSchema.required = schema.required;\n  }\n\n  return irSchema;\n};\n\nconst parseString = ({\n  irSchema = {},\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  irSchema.type = 'string';\n\n  return irSchema;\n};\n\nexport const parseExtensions = ({\n  source,\n  target,\n}: {\n  source: object;\n  target: object;\n}) => {\n  for (const key in source) {\n    if (key.startsWith('x-')) {\n      (target as Record<string, unknown>)[key] = (\n        source as Record<string, unknown>\n      )[key];\n    }\n  }\n};\n\nconst initIrSchema = ({\n  schema,\n}: {\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {};\n\n  parseSchemaJsDoc({\n    irSchema,\n    schema,\n  });\n\n  parseExtensions({\n    source: schema,\n    target: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseAllOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'allOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n  parseSchemaMeta({ irSchema, schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaTypes = getSchemaTypes({ schema });\n\n  const compositionSchemas = schema.allOf;\n\n  // Collect discriminator information to add after all compositions are processed\n  type DiscriminatorInfo = {\n    discriminator: NonNullable<SchemaObject['discriminator']>;\n    isRequired: boolean;\n    values: ReadonlyArray<string>;\n  };\n  const discriminatorsToAdd: Array<DiscriminatorInfo> = [];\n  const addedDiscriminators = new Set<string>();\n\n  for (const compositionSchema of compositionSchemas) {\n    const originalInAllOf = state.inAllOf;\n    // Don't propagate inAllOf flag to $ref schemas to avoid issues with reusable components\n    if (!('$ref' in compositionSchema)) {\n      state.inAllOf = true;\n    }\n    const irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n    state.inAllOf = originalInAllOf;\n    if (state.inAllOf === undefined) {\n      delete state.inAllOf;\n    }\n\n    if (schema.required) {\n      if (irCompositionSchema.required) {\n        irCompositionSchema.required = [\n          ...irCompositionSchema.required,\n          ...schema.required,\n        ];\n      } else {\n        irCompositionSchema.required = schema.required;\n      }\n    }\n\n    schemaItems.push(irCompositionSchema);\n\n    if (compositionSchema.$ref) {\n      const ref = context.resolveRef<SchemaObject>(compositionSchema.$ref);\n      // `$ref` should be passed from the root `parseSchema()` call\n      if (state.$ref) {\n        // Find all discriminators in the referenced schema, including nested allOf compositions\n        const discriminators = findDiscriminatorsInSchema({\n          context,\n          schema: ref,\n        });\n\n        // Process each discriminator found\n        for (const { discriminator, oneOf } of discriminators) {\n          // Skip if we've already collected this discriminator property\n          if (addedDiscriminators.has(discriminator.propertyName)) {\n            continue;\n          }\n\n          const values = discriminatorValues(\n            state.$ref,\n            discriminator.mapping,\n            // If the ref has oneOf, we only use the schema name as the value\n            // only if current schema is part of the oneOf. Else it is extending\n            // the ref schema\n            oneOf\n              ? () => oneOf.some((o) => '$ref' in o && o.$ref === state.$ref)\n              : undefined,\n          );\n\n          if (values.length > 0) {\n            // Check if the discriminator property is required in any of the discriminator schemas\n            const isRequired = discriminators.some(\n              (d) =>\n                d.discriminator.propertyName === discriminator.propertyName &&\n                // Check in the ref's required array or in the allOf components\n                (ref.required?.includes(d.discriminator.propertyName) ||\n                  (ref.allOf &&\n                    ref.allOf.some((item) => {\n                      const resolvedItem = item.$ref\n                        ? context.resolveRef<SchemaObject>(item.$ref)\n                        : item;\n                      return resolvedItem.required?.includes(\n                        d.discriminator.propertyName,\n                      );\n                    }))),\n            );\n\n            discriminatorsToAdd.push({\n              discriminator,\n              isRequired,\n              values,\n            });\n            addedDiscriminators.add(discriminator.propertyName);\n          }\n        }\n      }\n    }\n  }\n\n  // Now add discriminators after all compositions have been processed\n  for (const { discriminator, isRequired, values } of discriminatorsToAdd) {\n    // Get all discriminator values including children for union types\n    const allValues = getAllDiscriminatorValues({\n      discriminator,\n      schemaRef: state.$ref!,\n    });\n\n    // Use allValues if we found children, otherwise use the original values\n    const finalValues = allValues.length > 0 ? allValues : values;\n\n    const valueSchemas: ReadonlyArray<IR.SchemaObject> = finalValues.map(\n      (value) => ({\n        const: value,\n        type: 'string',\n      }),\n    );\n\n    const discriminatorProperty: IR.SchemaObject =\n      valueSchemas.length > 1\n        ? {\n            items: valueSchemas,\n            logicalOperator: 'or',\n          }\n        : valueSchemas[0]!;\n\n    // Check if any $ref schemas in schemaItems have this discriminator property\n    // If yes, mark them to omit it to avoid conflicts\n    for (const item of schemaItems) {\n      if (item.$ref || item.symbolRef) {\n        // Check if the referenced schema has this property\n        const hasProperty = (() => {\n          if (!item.$ref) return false;\n          try {\n            const refSchema = context.resolveRef<SchemaObject>(item.$ref);\n            // Check if the discriminator property exists in the ref schema\n            return (\n              refSchema.properties?.[discriminator.propertyName] !==\n                undefined ||\n              (refSchema.allOf &&\n                refSchema.allOf.some((allOfItem) => {\n                  const resolved = allOfItem.$ref\n                    ? context.resolveRef<SchemaObject>(allOfItem.$ref)\n                    : allOfItem;\n                  return (\n                    resolved.properties?.[discriminator.propertyName] !==\n                    undefined\n                  );\n                }))\n            );\n          } catch {\n            return false;\n          }\n        })();\n\n        if (hasProperty) {\n          // Mark this ref to omit the discriminator property\n          if (!item.omit) {\n            item.omit = [discriminator.propertyName];\n          } else if (!item.omit.includes(discriminator.propertyName)) {\n            item.omit = [...item.omit, discriminator.propertyName];\n          }\n        }\n      }\n    }\n\n    // Find the inline schema (non-$ref) to merge the discriminator property into\n    // The inline schema should be the last non-$ref item in schemaItems\n    let inlineSchema: IR.SchemaObject | undefined;\n    for (let i = schemaItems.length - 1; i >= 0; i--) {\n      const item = schemaItems[i]!;\n      // Check if this is not a $ref schema by looking for properties or checking if it came from an inline schema\n      if (item.type === 'object' || item.properties) {\n        inlineSchema = item;\n        break;\n      }\n    }\n\n    // If we found an inline schema, add the discriminator property to it\n    if (inlineSchema) {\n      if (!inlineSchema.properties) {\n        inlineSchema.properties = {};\n      }\n      inlineSchema.properties[discriminator.propertyName] =\n        discriminatorProperty;\n\n      if (isRequired) {\n        if (!inlineSchema.required) {\n          inlineSchema.required = [];\n        }\n        if (!inlineSchema.required.includes(discriminator.propertyName)) {\n          inlineSchema.required = [\n            ...inlineSchema.required,\n            discriminator.propertyName,\n          ];\n        }\n      }\n    } else {\n      // Fallback: create a separate discriminator schema if no inline schema found\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [discriminator.propertyName]: discriminatorProperty,\n        },\n        type: 'object',\n      };\n\n      if (isRequired) {\n        irDiscriminatorSchema.required = [discriminator.propertyName];\n      }\n      schemaItems.push(irDiscriminatorSchema);\n    }\n  }\n\n  if (schemaTypes.includes('object')) {\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      for (const requiredProperty of irObjectSchema.required ?? []) {\n        if (!irObjectSchema.properties[requiredProperty]) {\n          for (const compositionSchema of compositionSchemas) {\n            // TODO: parser - this could be probably resolved more accurately\n            const finalCompositionSchema = compositionSchema.$ref\n              ? context.resolveRef<SchemaObject>(compositionSchema.$ref)\n              : compositionSchema;\n\n            if (\n              getSchemaTypes({ schema: finalCompositionSchema }).includes(\n                'object',\n              )\n            ) {\n              const irCompositionSchema = parseOneType({\n                context,\n                schema: {\n                  ...finalCompositionSchema,\n                  type: 'object',\n                },\n                state,\n              });\n\n              if (irCompositionSchema.properties?.[requiredProperty]) {\n                irObjectSchema.properties[requiredProperty] =\n                  irCompositionSchema.properties[requiredProperty];\n                break;\n              }\n            }\n          }\n        }\n      }\n      schemaItems.push(irObjectSchema);\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    logicalOperator: 'and',\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaTypes.includes('null')) {\n    // nest composition to avoid producing an intersection with null\n    const nestedItems: Array<IR.SchemaObject> = [\n      {\n        type: 'null',\n      },\n    ];\n\n    if (schemaItems.length) {\n      nestedItems.unshift(irSchema);\n    }\n\n    irSchema = {\n      items: nestedItems,\n      logicalOperator: 'or',\n    };\n  }\n\n  return irSchema;\n};\n\nconst parseAnyOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'anyOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n  parseSchemaMeta({ irSchema, schema });\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaTypes = getSchemaTypes({ schema });\n\n  const compositionSchemas = schema.anyOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    let irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n\n    // `$ref` should be defined with discriminators\n    if (schema.discriminator && irCompositionSchema.$ref != null) {\n      const values = discriminatorValues(\n        irCompositionSchema.$ref,\n        schema.discriminator.mapping,\n      );\n      const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n        (value) => ({\n          const: value,\n          type: 'string',\n        }),\n      );\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [schema.discriminator.propertyName]:\n            valueSchemas.length > 1\n              ? {\n                  items: valueSchemas,\n                  logicalOperator: 'or',\n                }\n              : valueSchemas[0]!,\n        },\n        type: 'object',\n      };\n      irCompositionSchema = {\n        items: [irDiscriminatorSchema, irCompositionSchema],\n        logicalOperator: 'and',\n      };\n    }\n\n    schemaItems.push(irCompositionSchema);\n  }\n\n  if (schemaTypes.includes('null')) {\n    schemaItems.push({ type: 'null' });\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaTypes.includes('object')) {\n    // nest composition to avoid producing a union with object properties\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      irSchema = {\n        items: [irSchema, irObjectSchema],\n        logicalOperator: 'and',\n      };\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseEnum = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'enum'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n\n  irSchema.type = 'enum';\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  const schemaTypes = getSchemaTypes({ schema });\n\n  for (const [index, enumValue] of schema.enum.entries()) {\n    const typeOfEnumValue = typeof enumValue;\n    let enumType: SchemaType<SchemaObject> | undefined;\n\n    if (\n      typeOfEnumValue === 'string' ||\n      typeOfEnumValue === 'number' ||\n      typeOfEnumValue === 'boolean'\n    ) {\n      enumType = typeOfEnumValue;\n    } else if (typeOfEnumValue === 'object' && Array.isArray(enumValue)) {\n      enumType = 'array';\n    } else if (enumValue === null) {\n      // type must contain null\n      if (schemaTypes.includes('null')) {\n        enumType = 'null';\n      }\n    } else {\n      console.warn(\n        'üö®',\n        `unhandled \"${typeOfEnumValue}\" typeof value \"${enumValue}\" for enum`,\n        schema.enum,\n      );\n    }\n\n    if (!enumType) {\n      continue;\n    }\n\n    const irTypeSchema = parseOneType({\n      context,\n      schema: {\n        const: enumValue,\n        description: schema['x-enum-descriptions']?.[index],\n        title:\n          schema['x-enum-varnames']?.[index] ?? schema['x-enumNames']?.[index],\n        type: enumType,\n      },\n      state,\n    });\n\n    schemaItems.push(irTypeSchema);\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseOneOf = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'oneOf'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  let irSchema = initIrSchema({ schema });\n  parseSchemaMeta({ irSchema, schema });\n\n  let schemaItems: Array<IR.SchemaObject> = [];\n  const schemaTypes = getSchemaTypes({ schema });\n\n  const compositionSchemas = schema.oneOf;\n\n  for (const compositionSchema of compositionSchemas) {\n    let irCompositionSchema = schemaToIrSchema({\n      context,\n      schema: compositionSchema,\n      state,\n    });\n\n    // `$ref` should be defined with discriminators\n    if (schema.discriminator && irCompositionSchema.$ref != null) {\n      const values = discriminatorValues(\n        irCompositionSchema.$ref,\n        schema.discriminator.mapping,\n      );\n      const valueSchemas: ReadonlyArray<IR.SchemaObject> = values.map(\n        (value) => ({\n          const: value,\n          type: 'string',\n        }),\n      );\n      const irDiscriminatorSchema: IR.SchemaObject = {\n        properties: {\n          [schema.discriminator.propertyName]:\n            valueSchemas.length > 1\n              ? {\n                  items: valueSchemas,\n                  logicalOperator: 'or',\n                }\n              : valueSchemas[0]!,\n        },\n        required: [schema.discriminator.propertyName],\n        type: 'object',\n      };\n      irCompositionSchema = {\n        items: [irDiscriminatorSchema, irCompositionSchema],\n        logicalOperator: 'and',\n      };\n    }\n\n    // since we know oneOf will be using \"or\" logical operator, if the parsed\n    // composition schema also has an \"or\" operator, we can bring it up\n    // to avoid unnecessary brackets\n    if (\n      irCompositionSchema.logicalOperator === 'or' &&\n      irCompositionSchema.type !== 'array' &&\n      irCompositionSchema.items\n    ) {\n      schemaItems = schemaItems.concat(irCompositionSchema.items);\n    } else {\n      schemaItems.push(irCompositionSchema);\n    }\n  }\n\n  if (schemaTypes.includes('null')) {\n    schemaItems.push({ type: 'null' });\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  if (schemaTypes.includes('object')) {\n    // nest composition to avoid producing a union with object properties\n    const irObjectSchema = parseOneType({\n      context,\n      schema: {\n        ...schema,\n        type: 'object',\n      },\n      state,\n    });\n\n    if (irObjectSchema.properties) {\n      irSchema = {\n        items: [irSchema, irObjectSchema],\n        logicalOperator: 'and',\n      };\n    }\n  }\n\n  return irSchema;\n};\n\nconst parseRef = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, '$ref'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  // Inline non-component refs (e.g. #/paths/...) to avoid generating orphaned named types\n  const isComponentsRef = schema.$ref.startsWith('#/components/');\n  if (!isComponentsRef) {\n    if (!state.circularReferenceTracker.has(schema.$ref)) {\n      const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n      const originalRef = state.$ref;\n      state.$ref = schema.$ref;\n      const irSchema = schemaToIrSchema({\n        context,\n        schema: refSchema,\n        state,\n      });\n      state.$ref = originalRef;\n      return irSchema;\n    }\n    // Fallback to preserving the ref if circular\n  }\n\n  let irSchema = initIrSchema({ schema });\n  parseSchemaMeta({ irSchema, schema });\n\n  const irRefSchema: IR.SchemaObject = {};\n\n  // refs using unicode characters become encoded, didn't investigate why\n  // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n  irRefSchema.$ref = decodeURI(schema.$ref);\n\n  if (!state.circularReferenceTracker.has(schema.$ref)) {\n    const refSchema = context.resolveRef<SchemaObject>(schema.$ref);\n    const originalRef = state.$ref;\n    state.$ref = schema.$ref;\n    schemaToIrSchema({\n      context,\n      schema: refSchema,\n      state,\n    });\n    state.$ref = originalRef;\n  }\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n  schemaItems.push(irRefSchema);\n\n  if (schema.type && typeof schema.type !== 'string') {\n    if (schema.type.includes('null')) {\n      schemaItems.push({ type: 'null' });\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    mutateSchemaOneItem: true,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseOneType = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: Omit<SchemaObject, 'type'> & {\n    type: SchemaType<SchemaObject>;\n  };\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n    parseSchemaMeta({ irSchema, schema });\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return parseArray({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'boolean':\n      return parseBoolean({\n        context,\n        irSchema,\n        schema,\n      });\n    case 'integer':\n    case 'number':\n      return parseNumber({\n        context,\n        irSchema,\n        schema,\n      });\n    case 'null':\n      return parseNull({\n        context,\n        irSchema,\n        schema,\n      });\n    case 'object':\n      return parseObject({\n        context,\n        irSchema,\n        schema,\n        state,\n      });\n    case 'string':\n      return parseString({\n        context,\n        irSchema,\n        schema,\n      });\n    default:\n      // gracefully handle invalid type\n      return parseUnknown({ context, irSchema, schema });\n  }\n};\n\nconst parseManyTypes = ({\n  context,\n  irSchema,\n  schema,\n  state,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: Omit<SchemaObject, 'type'> & {\n    type: ReadonlyArray<SchemaType<SchemaObject>>;\n  };\n  state: SchemaState;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  const typeIrSchema: IR.SchemaObject = {};\n\n  parseSchemaMeta({ irSchema: typeIrSchema, schema });\n\n  if (schema.type.includes('null') && typeIrSchema.default === null) {\n    // clear to avoid duplicate default inside the non-null schema.\n    // this would produce incorrect validator output\n    delete typeIrSchema.default;\n  }\n\n  const schemaItems: Array<IR.SchemaObject> = [];\n\n  for (const type of schema.type) {\n    if (type === 'null') {\n      schemaItems.push({ type: 'null' });\n    } else {\n      const irTypeSchema = parseOneType({\n        context,\n        irSchema: { ...typeIrSchema },\n        schema: {\n          ...schema,\n          type,\n        },\n        state,\n      });\n\n      schemaItems.push(irTypeSchema);\n    }\n  }\n\n  irSchema = addItemsToSchema({\n    items: schemaItems,\n    schema: irSchema,\n  });\n\n  return irSchema;\n};\n\nconst parseType = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaWithRequired<SchemaObject, 'type'>;\n  state: SchemaState;\n}): IR.SchemaObject => {\n  const irSchema = initIrSchema({ schema });\n\n  parseSchemaMeta({ irSchema, schema });\n\n  const schemaTypes = getSchemaTypes({ schema });\n\n  if (schemaTypes.length === 1) {\n    return parseOneType({\n      context,\n      irSchema,\n      schema: {\n        ...schema,\n        type: schemaTypes[0]!,\n      },\n      state,\n    });\n  }\n\n  return parseManyTypes({\n    context,\n    irSchema,\n    schema: {\n      ...schema,\n      type: schemaTypes,\n    },\n    state,\n  });\n};\n\nconst parseUnknown = ({\n  irSchema,\n  schema,\n}: {\n  context: Context;\n  irSchema?: IR.SchemaObject;\n  schema: SchemaObject;\n}): IR.SchemaObject => {\n  if (!irSchema) {\n    irSchema = initIrSchema({ schema });\n  }\n\n  irSchema.type = 'unknown';\n\n  parseSchemaMeta({ irSchema, schema });\n\n  return irSchema;\n};\n\nexport const schemaToIrSchema = ({\n  context,\n  schema,\n  state,\n}: {\n  context: Context;\n  schema: SchemaObject;\n  state: SchemaState | undefined;\n}): IR.SchemaObject => {\n  if (!state) {\n    state = {\n      circularReferenceTracker: new Set(),\n    };\n  }\n\n  if (state.$ref) {\n    state.circularReferenceTracker.add(state.$ref);\n  }\n\n  if (schema.$ref) {\n    return parseRef({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, '$ref'>,\n      state,\n    });\n  }\n\n  if (schema.enum) {\n    return parseEnum({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'enum'>,\n      state,\n    });\n  }\n\n  if (schema.allOf) {\n    return parseAllOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'allOf'>,\n      state,\n    });\n  }\n\n  if (schema.anyOf) {\n    return parseAnyOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'anyOf'>,\n      state,\n    });\n  }\n\n  if (schema.oneOf) {\n    return parseOneOf({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'oneOf'>,\n      state,\n    });\n  }\n\n  // infer object based on the presence of properties\n  if (schema.type || schema.properties) {\n    return parseType({\n      context,\n      schema: schema as SchemaWithRequired<SchemaObject, 'type'>,\n      state,\n    });\n  }\n\n  return parseUnknown({ context, schema });\n};\n\nexport const parseSchema = ({\n  $ref,\n  context,\n  schema,\n}: {\n  $ref: string;\n  context: Context;\n  schema: SchemaObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.schemas) {\n    context.ir.components.schemas = {};\n  }\n\n  context.ir.components.schemas[refToName($ref)] = schemaToIrSchema({\n    context,\n    schema,\n    state: {\n      $ref,\n      circularReferenceTracker: new Set(),\n    },\n  });\n};\n","import type { Context } from '~/ir/context';\nimport { getPaginationKeywordsRegExp } from '~/ir/pagination';\nimport type { SchemaType } from '~/openApi/shared/types/schema';\n\nimport type { ParameterObject, RequestBodyObject } from '../types/spec';\nimport type { SchemaObject } from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { getSchemaTypes } from './schema';\n\nconst isPaginationType = (\n  schemaTypes: ReadonlyArray<SchemaType<SchemaObject>>,\n): boolean =>\n  schemaTypes.includes('boolean') ||\n  schemaTypes.includes('integer') ||\n  schemaTypes.includes('number') ||\n  schemaTypes.includes('string');\n\n// We handle only simple values for now, up to 1 nested field\nexport const paginationField = ({\n  context,\n  name,\n  schema,\n}: {\n  context: Context;\n  name: string;\n  schema: SchemaObject;\n}): boolean | string => {\n  const paginationRegExp = getPaginationKeywordsRegExp(\n    context.config.parser.pagination,\n  );\n  if (paginationRegExp.test(name)) {\n    return true;\n  }\n\n  if (schema.$ref) {\n    const ref = context.resolveRef<\n      ParameterObject | RequestBodyObject | SchemaObject\n    >(schema.$ref);\n\n    if ('content' in ref || 'in' in ref) {\n      let refSchema: SchemaObject | undefined;\n\n      if ('in' in ref) {\n        refSchema = ref.schema;\n      }\n\n      if (!refSchema) {\n        // parameter or body\n        const contents = mediaTypeObjects({ content: ref.content });\n        // TODO: add support for multiple content types, for now prefer JSON\n        const content =\n          contents.find((content) => content.type === 'json') || contents[0];\n        if (content?.schema) {\n          refSchema = content.schema;\n        }\n      }\n\n      if (!refSchema) {\n        return false;\n      }\n\n      return paginationField({\n        context,\n        name,\n        schema: refSchema,\n      });\n    }\n\n    return paginationField({\n      context,\n      name,\n      schema: ref,\n    });\n  }\n\n  for (const name in schema.properties) {\n    const paginationRegExp = getPaginationKeywordsRegExp(\n      context.config.parser.pagination,\n    );\n\n    if (paginationRegExp.test(name)) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        // TODO: resolve deeper references\n        const schemaTypes = getSchemaTypes({ schema: property });\n\n        if (!schemaTypes.length) {\n          const compositionSchemas = property.anyOf ?? property.oneOf;\n          const nonNullCompositionSchemas = (compositionSchemas ?? []).filter(\n            (schema) => schema.type !== 'null',\n          );\n          if (nonNullCompositionSchemas.length === 1) {\n            const schemaTypes = getSchemaTypes({\n              schema: nonNullCompositionSchemas[0]!,\n            });\n            if (isPaginationType(schemaTypes)) {\n              return name;\n            }\n          }\n        }\n\n        if (isPaginationType(schemaTypes)) {\n          return name;\n        }\n      }\n    }\n  }\n\n  for (const allOf of schema.allOf ?? []) {\n    const pagination = paginationField({\n      context,\n      name,\n      schema: allOf,\n    });\n    if (pagination) {\n      return pagination;\n    }\n  }\n\n  return false;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport type { State } from '~/openApi/shared/types/state';\nimport type { httpMethods } from '~/openApi/shared/utils/operation';\nimport { operationToId } from '~/openApi/shared/utils/operation';\n\nimport type {\n  OperationObject,\n  ReferenceObject,\n  RequestBodyObject,\n  ResponseObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { contentToSchema, mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { parseExtensions, schemaToIrSchema } from './schema';\n\ninterface Operation\n  extends Omit<OperationObject, 'parameters'>,\n    Pick<IR.OperationObject, 'parameters'> {}\n\nconst parseOperationJsDoc = ({\n  irOperation,\n  operation,\n}: {\n  irOperation: IR.OperationObject;\n  operation: Operation;\n}) => {\n  if (operation.deprecated !== undefined) {\n    irOperation.deprecated = operation.deprecated;\n  }\n\n  if (operation.description) {\n    irOperation.description = operation.description;\n  }\n\n  if (operation.summary) {\n    irOperation.summary = operation.summary;\n  }\n\n  if (operation.tags?.length) {\n    irOperation.tags = operation.tags;\n  }\n};\n\nconst initIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: Context;\n  operation: Operation;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation: IR.OperationObject = {\n    id: operationToId({\n      context,\n      id: operation.operationId,\n      method,\n      path,\n      state,\n    }),\n    method,\n    path,\n  };\n\n  if (operation.operationId) {\n    irOperation.operationId = operation.operationId;\n  }\n\n  parseOperationJsDoc({\n    irOperation,\n    operation,\n  });\n\n  parseExtensions({\n    source: operation,\n    target: irOperation,\n  });\n\n  return irOperation;\n};\n\nconst operationToIrOperation = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: Pick<IR.OperationObject, 'method' | 'path'> & {\n  context: Context;\n  operation: Operation;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}): IR.OperationObject => {\n  const irOperation = initIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    state,\n  });\n\n  if (operation.parameters) {\n    irOperation.parameters = operation.parameters;\n  }\n\n  if (operation.requestBody) {\n    const requestBody =\n      '$ref' in operation.requestBody\n        ? context.resolveRef<RequestBodyObject>(operation.requestBody.$ref)\n        : operation.requestBody;\n    const contents = mediaTypeObjects({ content: requestBody.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      const pagination = paginationField({\n        context,\n        name: '',\n        schema: {\n          description: requestBody.description,\n          ...content.schema,\n        },\n      });\n\n      irOperation.body = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema: {\n            description: requestBody.description,\n            ...('$ref' in operation.requestBody\n              ? operation.requestBody\n              : content.schema),\n          },\n          state: undefined,\n        }),\n      };\n\n      if (pagination) {\n        irOperation.body.pagination = pagination;\n      }\n\n      if (requestBody.required) {\n        irOperation.body.required = requestBody.required;\n      }\n\n      if (content.type) {\n        irOperation.body.type = content.type;\n      }\n    }\n  }\n\n  for (const name in operation.responses) {\n    if (name.startsWith('x-')) continue;\n\n    if (!irOperation.responses) {\n      irOperation.responses = {};\n    }\n\n    const response = operation.responses[name]! as\n      | ResponseObject\n      | ReferenceObject;\n    const responseObject =\n      '$ref' in response\n        ? context.resolveRef<ResponseObject>(response.$ref)\n        : response;\n    const contents = mediaTypeObjects({ content: responseObject.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n\n    if (content) {\n      irOperation.responses[name] = {\n        mediaType: content.mediaType,\n        schema: schemaToIrSchema({\n          context,\n          schema: {\n            description: responseObject.description,\n            ...contentToSchema({ content }),\n          },\n          state: undefined,\n        }),\n      };\n    } else {\n      irOperation.responses[name] = {\n        schema: {\n          description: responseObject.description,\n          // TODO: parser - cover all statues with empty response bodies\n          // 1xx, 204, 205, 304\n          type: name === '204' ? 'void' : 'unknown',\n        },\n      };\n    }\n  }\n\n  if (operation.security) {\n    const securitySchemeObjects: Map<string, IR.SecurityObject> = new Map();\n\n    for (const securityRequirementObject of operation.security) {\n      for (const name in securityRequirementObject) {\n        const securitySchemeObject = securitySchemesMap.get(name);\n\n        if (!securitySchemeObject) {\n          continue;\n        }\n\n        securitySchemeObjects.set(name, securitySchemeObject);\n      }\n    }\n\n    if (securitySchemeObjects.size) {\n      irOperation.security = Array.from(securitySchemeObjects.values());\n    }\n  }\n\n  // TODO: parser - handle servers\n  // qux: operation.servers\n\n  return irOperation;\n};\n\nconst parseOperationObject = ({\n  context,\n  method,\n  operation,\n  path,\n  securitySchemesMap,\n  state,\n}: {\n  context: Context;\n  method: (typeof httpMethods)[number];\n  operation: Operation;\n  path: keyof IR.PathsObject;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (operation.servers) {\n    context.ir.servers = [...(context.ir.servers ?? []), ...operation.servers];\n  }\n\n  const parsed = operationToIrOperation({\n    context,\n    method,\n    operation,\n    path,\n    securitySchemesMap,\n    state,\n  });\n\n  return { parsed };\n};\n\nexport const parsePathOperation = ({\n  context,\n  method,\n  path,\n  ...options\n}: {\n  context: Context;\n  method: (typeof httpMethods)[number];\n  operation: Operation;\n  path: keyof IR.PathsObject;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (!context.ir.paths) {\n    context.ir.paths = {};\n  }\n\n  if (!context.ir.paths[path]) {\n    context.ir.paths[path] = {};\n  }\n\n  const { parsed } = parseOperationObject({\n    context,\n    method,\n    path,\n    ...options,\n  });\n\n  context.ir.paths[path][method] = parsed;\n};\n\nexport const parseWebhookOperation = ({\n  context,\n  key,\n  method,\n  ...options\n}: {\n  context: Context;\n  key: string;\n  method: (typeof httpMethods)[number];\n  operation: Operation;\n  securitySchemesMap: Map<string, SecuritySchemeObject>;\n  state: State;\n}) => {\n  if (!context.ir.webhooks) {\n    context.ir.webhooks = {};\n  }\n\n  if (!context.ir.webhooks[key]) {\n    context.ir.webhooks[key] = {};\n  }\n\n  const { parsed } = parseOperationObject({\n    context,\n    method,\n    path: key as `/${string}`,\n    ...options,\n  });\n\n  context.ir.webhooks[key][method] = parsed;\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { refToName } from '~/utils/ref';\n\nimport type {\n  ParameterObject,\n  ReferenceObject,\n  SchemaObject,\n} from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { paginationField } from './pagination';\nimport { parseExtensions, schemaToIrSchema } from './schema';\n\n/**\n * Returns default parameter `allowReserved` based on value of `in`.\n */\nconst defaultAllowReserved = (\n  _in: ParameterObject['in'],\n): boolean | undefined => {\n  switch (_in) {\n    // this keyword only applies to parameters with an `in` value of `query`\n    case 'query':\n      return false;\n    default:\n      return;\n  }\n};\n\n/**\n * Returns default parameter `explode` based on value of `style`.\n */\nconst defaultExplode = (style: Required<ParameterObject>['style']): boolean => {\n  switch (style) {\n    // default value for `deepObject` is `false`, but that behavior is undefined\n    // so we use `true` to make this work with the `client-fetch` package\n    case 'deepObject':\n    case 'form':\n      return true;\n    default:\n      return false;\n  }\n};\n\n/**\n * Returns default parameter `style` based on value of `in`.\n */\nconst defaultStyle = (\n  _in: ParameterObject['in'],\n): Required<ParameterObject>['style'] => {\n  switch (_in) {\n    case 'header':\n    case 'path':\n      return 'simple';\n    case 'cookie':\n    case 'query':\n      return 'form';\n  }\n};\n\nexport const parametersArrayToObject = ({\n  context,\n  parameters,\n}: {\n  context: Context;\n  parameters?: ReadonlyArray<ParameterObject | ReferenceObject>;\n}): IR.ParametersObject | undefined => {\n  if (!parameters || !Object.keys(parameters).length) {\n    return;\n  }\n\n  const parametersObject: IR.ParametersObject = {};\n\n  for (const parameterOrReference of parameters) {\n    const parameter =\n      '$ref' in parameterOrReference\n        ? context.dereference<ParameterObject>(parameterOrReference)\n        : parameterOrReference;\n\n    if (!parametersObject[parameter.in]) {\n      parametersObject[parameter.in] = {};\n    }\n\n    // lowercase keys for case insensitive access\n    parametersObject[parameter.in]![parameter.name.toLocaleLowerCase()] =\n      parameterToIrParameter({\n        $ref: `#/todo/real/path/to/parameter/${parameter.name}`,\n        context,\n        parameter,\n      });\n  }\n\n  return parametersObject;\n};\n\nconst parameterToIrParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: Context;\n  parameter: ParameterObject;\n}): IR.ParameterObject => {\n  // TODO: parser - fix\n  let schema = parameter.schema;\n\n  if (!schema) {\n    const contents = mediaTypeObjects({ content: parameter.content });\n    // TODO: add support for multiple content types, for now prefer JSON\n    const content =\n      contents.find((content) => content.type === 'json') || contents[0];\n    if (content) {\n      schema = content.schema;\n    }\n  }\n\n  const finalSchema: SchemaObject = {\n    deprecated: parameter.deprecated,\n    description: parameter.description,\n    ...schema,\n  };\n\n  const pagination = paginationField({\n    context,\n    name: parameter.name,\n    schema: finalSchema,\n  });\n\n  const style = parameter.style || defaultStyle(parameter.in);\n  const explode =\n    parameter.explode !== undefined ? parameter.explode : defaultExplode(style);\n  const allowReserved =\n    parameter.allowReserved !== undefined\n      ? parameter.allowReserved\n      : defaultAllowReserved(parameter.in);\n\n  const irParameter: IR.ParameterObject = {\n    allowReserved,\n    explode,\n    location: parameter.in,\n    name: parameter.name,\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n    style,\n  };\n\n  if (parameter.deprecated) {\n    irParameter.deprecated = parameter.deprecated;\n  }\n\n  if (parameter.description) {\n    irParameter.description = parameter.description;\n  }\n\n  if (pagination) {\n    irParameter.pagination = pagination;\n  }\n\n  if (parameter.required) {\n    irParameter.required = parameter.required;\n  }\n\n  parseExtensions({\n    source: parameter,\n    target: irParameter,\n  });\n\n  return irParameter;\n};\n\nexport const parseParameter = ({\n  $ref,\n  context,\n  parameter,\n}: {\n  $ref: string;\n  context: Context;\n  parameter: ParameterObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.parameters) {\n    context.ir.components.parameters = {};\n  }\n\n  context.ir.components.parameters[refToName($ref)] = parameterToIrParameter({\n    $ref,\n    context,\n    parameter,\n  });\n};\n","import type { Context } from '~/ir/context';\nimport type { IR } from '~/ir/types';\nimport { refToName } from '~/utils/ref';\n\nimport type { RequestBodyObject, SchemaObject } from '../types/spec';\nimport { mediaTypeObjects } from './mediaType';\nimport { schemaToIrSchema } from './schema';\n\nconst requestBodyToIrRequestBody = ({\n  $ref,\n  context,\n  requestBody,\n}: {\n  $ref: string;\n  context: Context;\n  requestBody: RequestBodyObject;\n}): IR.RequestBodyObject => {\n  // TODO: parser - fix\n  const contents = mediaTypeObjects({ content: requestBody.content });\n  // TODO: add support for multiple content types, for now prefer JSON\n  const content =\n    contents.find((content) => content.type === 'json') || contents[0];\n  const schema = content ? content.schema : undefined;\n\n  const finalSchema: SchemaObject = {\n    description: requestBody.description,\n    ...schema,\n  };\n\n  const irRequestBody: IR.RequestBodyObject = {\n    schema: schemaToIrSchema({\n      context,\n      schema: finalSchema,\n      state: {\n        $ref,\n        circularReferenceTracker: new Set(),\n      },\n    }),\n  };\n\n  if (requestBody.description) {\n    irRequestBody.description = requestBody.description;\n  }\n\n  if (requestBody.required) {\n    irRequestBody.required = requestBody.required;\n  }\n\n  return irRequestBody;\n};\n\nexport const parseRequestBody = ({\n  $ref,\n  context,\n  requestBody,\n}: {\n  $ref: string;\n  context: Context;\n  requestBody: RequestBodyObject;\n}) => {\n  if (!context.ir.components) {\n    context.ir.components = {};\n  }\n\n  if (!context.ir.components.requestBodies) {\n    context.ir.components.requestBodies = {};\n  }\n\n  context.ir.components.requestBodies[refToName($ref)] =\n    requestBodyToIrRequestBody({\n      $ref,\n      context,\n      requestBody,\n    });\n};\n","import type { Context } from '~/ir/context';\nimport { parseUrl } from '~/utils/url';\n\nexport const parseServers = ({ context }: { context: Context }) => {\n  if (context.spec.servers) {\n    context.ir.servers = context.spec.servers;\n    return;\n  }\n\n  for (const input of context.config.input) {\n    if (typeof input.path === 'string') {\n      const url = parseUrl(input.path);\n      context.ir.servers = [\n        {\n          url: `${url.protocol ? `${url.protocol}://` : ''}${url.host}${url.port ? `:${url.port}` : ''}`,\n        },\n      ];\n    }\n  }\n\n  if (!context.ir.servers) {\n    context.ir.servers = [\n      {\n        url: '/',\n      },\n    ];\n  }\n};\n","import { createOperationKey } from '~/ir/operation';\nimport { httpMethods } from '~/openApi/shared/utils/operation';\nimport type {\n  ValidatorIssue,\n  ValidatorResult,\n} from '~/openApi/shared/utils/validator';\nimport type { Logger } from '~/utils/logger';\n\nimport type { OpenApiV3_1_X, PathItemObject, PathsObject } from '../types/spec';\n\nexport const validateOpenApiSpec = (\n  spec: OpenApiV3_1_X,\n  logger: Logger,\n): ValidatorResult => {\n  const eventValidate = logger.timeEvent('validate');\n  const issues: Array<ValidatorIssue> = [];\n  const operationIds = new Map();\n\n  if (spec.paths) {\n    for (const entry of Object.entries(spec.paths)) {\n      const path = entry[0] as keyof PathsObject;\n      const pathItem = entry[1] as PathItemObject;\n      for (const method of httpMethods) {\n        const operation = pathItem[method];\n        if (!operation) {\n          continue;\n        }\n\n        const operationKey = createOperationKey({ method, path });\n\n        if (operation.operationId) {\n          if (!operationIds.has(operation.operationId)) {\n            operationIds.set(operation.operationId, operationKey);\n          } else {\n            issues.push({\n              code: 'duplicate_key',\n              context: {\n                key: 'operationId',\n                value: operation.operationId,\n              },\n              message:\n                'Duplicate `operationId` found. Each `operationId` must be unique.',\n              path: ['paths', path, method, 'operationId'],\n              severity: 'error',\n            });\n          }\n        }\n      }\n    }\n  }\n\n  if (spec.servers) {\n    if (typeof spec.servers !== 'object' || !Array.isArray(spec.servers)) {\n      issues.push({\n        code: 'invalid_type',\n        message: '`servers` must be an array.',\n        path: [],\n        severity: 'error',\n      });\n    }\n\n    for (let index = 0; index < spec.servers.length; index++) {\n      const server = spec.servers[index];\n      if (!server || typeof server !== 'object') {\n        issues.push({\n          code: 'invalid_type',\n          context: {\n            actual: typeof server,\n            expected: 'object',\n          },\n          message: 'Each entry in `servers` must be an object.',\n          path: ['servers', index],\n          severity: 'error',\n        });\n      } else {\n        if (!server.url) {\n          issues.push({\n            code: 'missing_required_field',\n            context: {\n              field: 'url',\n            },\n            message: 'Missing required field `url` in server object.',\n            path: ['servers', index],\n            severity: 'error',\n          });\n        }\n      }\n    }\n  }\n\n  eventValidate.timeEnd();\n  return {\n    issues,\n    valid: !issues.some((issue) => issue.severity === 'error'),\n  };\n};\n","import type { Context } from '~/ir/context';\nimport { mergeParametersObjects } from '~/openApi/shared/utils/parameter';\n\nimport type { OpenApiV3_1_X, PathItemObject } from '../types/spec';\nimport { parseWebhookOperation } from './operation';\nimport { parametersArrayToObject } from './parameter';\n\nexport const parseWebhooks = ({\n  context,\n  securitySchemesMap,\n}: Pick<Parameters<typeof parseWebhookOperation>[0], 'securitySchemesMap'> & {\n  context: Context<OpenApiV3_1_X>;\n}) => {\n  const state: Parameters<typeof parseWebhookOperation>[0]['state'] = {\n    ids: new Map(),\n  };\n\n  for (const key in context.spec.webhooks) {\n    const webhook = context.spec.webhooks[key]!;\n\n    const finalWebhook =\n      '$ref' in webhook\n        ? {\n            ...context.resolveRef<PathItemObject>(webhook.$ref!),\n            ...webhook,\n          }\n        : webhook;\n\n    const operationArgs: Omit<\n      Parameters<typeof parseWebhookOperation>[0],\n      'method'\n    > = {\n      context,\n      key,\n      operation: {\n        description: finalWebhook.description,\n        parameters: parametersArrayToObject({\n          context,\n          parameters: finalWebhook.parameters,\n        }),\n        security: context.spec.security,\n        servers: finalWebhook.servers,\n        summary: finalWebhook.summary,\n      },\n      securitySchemesMap,\n      state,\n    };\n\n    if (finalWebhook.delete) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'delete',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.delete,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.delete.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.get) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'get',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.get,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.get.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.head) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'head',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.head,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.head.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.options) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'options',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.options,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.options.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.patch) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'patch',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.patch,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.patch.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.post) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'post',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.post,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.post.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.put) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'put',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.put,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.put.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalWebhook.trace) {\n      parseWebhookOperation({\n        ...operationArgs,\n        method: 'trace',\n        operation: {\n          ...operationArgs.operation,\n          ...finalWebhook.trace,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalWebhook.trace.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n  }\n};\n","import type { Context } from '~/ir/context';\nimport { buildResourceMetadata } from '~/openApi/shared/graph/meta';\nimport { transformOpenApiSpec } from '~/openApi/shared/transforms';\nimport type { State } from '~/openApi/shared/types/state';\nimport {\n  createFilteredDependencies,\n  createFilters,\n  hasFilters,\n} from '~/openApi/shared/utils/filter';\nimport { buildGraph } from '~/openApi/shared/utils/graph';\nimport { mergeParametersObjects } from '~/openApi/shared/utils/parameter';\nimport { handleValidatorResult } from '~/openApi/shared/utils/validator';\n\nimport type {\n  OpenApiV3_1_X,\n  ParameterObject,\n  PathItemObject,\n  PathsObject,\n  RequestBodyObject,\n  SecuritySchemeObject,\n} from '../types/spec';\nimport { filterSpec } from './filter';\nimport { parsePathOperation } from './operation';\nimport { parametersArrayToObject, parseParameter } from './parameter';\nimport { parseRequestBody } from './requestBody';\nimport { parseSchema } from './schema';\nimport { parseServers } from './server';\nimport { validateOpenApiSpec } from './validate';\nimport { parseWebhooks } from './webhook';\n\nexport const parseV3_1_X = (context: Context<OpenApiV3_1_X>) => {\n  if (context.config.parser.validate_EXPERIMENTAL) {\n    const result = validateOpenApiSpec(context.spec, context.logger);\n    handleValidatorResult({ context, result });\n  }\n\n  const shouldFilterSpec = hasFilters(context.config.parser.filters);\n  if (shouldFilterSpec) {\n    const filters = createFilters(\n      context.config.parser.filters,\n      context.spec,\n      context.logger,\n    );\n    const { graph } = buildGraph(context.spec, context.logger);\n    const { resourceMetadata } = buildResourceMetadata(graph, context.logger);\n    const sets = createFilteredDependencies({\n      filters,\n      logger: context.logger,\n      resourceMetadata,\n    });\n    filterSpec({\n      ...sets,\n      logger: context.logger,\n      preserveOrder: filters.preserveOrder,\n      spec: context.spec,\n    });\n  }\n\n  transformOpenApiSpec({ context });\n\n  const state: State = {\n    ids: new Map(),\n  };\n  const securitySchemesMap = new Map<string, SecuritySchemeObject>();\n\n  // TODO: parser - handle more component types, old parser handles only parameters and schemas\n  if (context.spec.components) {\n    for (const name in context.spec.components.securitySchemes) {\n      const securityOrReference =\n        context.spec.components.securitySchemes[name]!;\n      const securitySchemeObject =\n        '$ref' in securityOrReference\n          ? context.resolveRef<SecuritySchemeObject>(securityOrReference.$ref)\n          : securityOrReference;\n      securitySchemesMap.set(name, securitySchemeObject);\n    }\n\n    for (const name in context.spec.components.parameters) {\n      const $ref = `#/components/parameters/${name}`;\n      const parameterOrReference = context.spec.components.parameters[name]!;\n      const parameter =\n        '$ref' in parameterOrReference\n          ? context.resolveRef<ParameterObject>(parameterOrReference.$ref)\n          : parameterOrReference;\n\n      parseParameter({\n        $ref,\n        context,\n        parameter,\n      });\n    }\n\n    for (const name in context.spec.components.requestBodies) {\n      const $ref = `#/components/requestBodies/${name}`;\n      const requestBodyOrReference =\n        context.spec.components.requestBodies[name]!;\n      const requestBody =\n        '$ref' in requestBodyOrReference\n          ? context.resolveRef<RequestBodyObject>(requestBodyOrReference.$ref)\n          : requestBodyOrReference;\n\n      parseRequestBody({\n        $ref,\n        context,\n        requestBody,\n      });\n    }\n\n    for (const name in context.spec.components.schemas) {\n      const $ref = `#/components/schemas/${name}`;\n      const schema = context.spec.components.schemas[name]!;\n\n      parseSchema({\n        $ref,\n        context,\n        schema,\n      });\n    }\n  }\n\n  parseServers({ context });\n\n  for (const path in context.spec.paths) {\n    if (path.startsWith('x-')) continue;\n    const pathItem = context.spec.paths[\n      path as keyof PathsObject\n    ]! as PathItemObject;\n\n    const finalPathItem = pathItem.$ref\n      ? {\n          ...context.resolveRef<PathItemObject>(pathItem.$ref),\n          ...pathItem,\n        }\n      : pathItem;\n\n    const operationArgs: Omit<\n      Parameters<typeof parsePathOperation>[0],\n      'method'\n    > = {\n      context,\n      operation: {\n        description: finalPathItem.description,\n        parameters: parametersArrayToObject({\n          context,\n          parameters: finalPathItem.parameters,\n        }),\n        security: context.spec.security,\n        servers: finalPathItem.servers,\n        summary: finalPathItem.summary,\n      },\n      path: path as `/${string}`,\n      securitySchemesMap,\n      state,\n    };\n\n    if (finalPathItem.delete) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'delete',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.delete,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.delete.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.get) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'get',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.get,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.get.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.head) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'head',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.head,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.head.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.options) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'options',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.options,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.options.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.patch) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'patch',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.patch,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.patch.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.post) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'post',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.post,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.post.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.put) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'put',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.put,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.put.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n\n    if (finalPathItem.trace) {\n      parsePathOperation({\n        ...operationArgs,\n        method: 'trace',\n        operation: {\n          ...operationArgs.operation,\n          ...finalPathItem.trace,\n          parameters: mergeParametersObjects({\n            source: parametersArrayToObject({\n              context,\n              parameters: finalPathItem.trace.parameters,\n            }),\n            target: operationArgs.operation.parameters,\n          }),\n        },\n      });\n    }\n  }\n\n  parseWebhooks({ context, securitySchemesMap });\n};\n","import { satisfies } from '~/config/utils/package';\nimport { Context } from '~/ir/context';\nimport { parseV2_0_X } from '~/openApi/2.0.x';\nimport { parseV3_0_X } from '~/openApi/3.0.x';\nimport { parseV3_1_X } from '~/openApi/3.1.x';\nimport type { OpenApi } from '~/openApi/types';\nimport type { Config } from '~/types/config';\nimport type { Logger } from '~/utils/logger';\n\n/**\n * @internal\n * Parse the resolved OpenAPI specification. This will populate and return\n * `context` with intermediate representation obtained from the parsed spec.\n */\nexport const parseOpenApiSpec = ({\n  config,\n  dependencies,\n  logger,\n  spec,\n}: {\n  config: Config;\n  dependencies: Record<string, string>;\n  logger: Logger;\n  spec: unknown;\n}): Context => {\n  const context = new Context({\n    config,\n    dependencies,\n    logger,\n    spec: spec as OpenApi.V2_0_X | OpenApi.V3_0_X | OpenApi.V3_1_X,\n  });\n\n  if ('swagger' in context.spec) {\n    parseV2_0_X(context as Context<OpenApi.V2_0_X>);\n    return context;\n  }\n\n  if (satisfies(context.spec.openapi, '>=3.0.0 <3.1.0')) {\n    parseV3_0_X(context as Context<OpenApi.V3_0_X>);\n    return context;\n  }\n\n  if (satisfies(context.spec.openapi, '>=3.1.0')) {\n    parseV3_1_X(context as Context<OpenApi.V3_1_X>);\n    return context;\n  }\n\n  throw new Error('Unsupported OpenAPI specification');\n};\n"],"mappings":"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"}