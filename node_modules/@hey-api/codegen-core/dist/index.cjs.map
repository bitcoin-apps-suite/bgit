{"version":3,"file":"index.cjs","names":["colors","cachedDebugGroups: Set<string> | undefined","path","defaultExtensions: Extensions","simpleNameConflictResolver: NameConflictResolver","underscoreNameConflictResolver: NameConflictResolver","defaultNameConflictResolvers: NameConflictResolvers","path","ref","kindRank: Record<SymbolKind, number>","names: NameScopes","file","path","ctx: RenderContext","exports","scope","Symbol","sets: Array<Set<SymbolId>>","Symbol","entries: Array<IndexEntry>","path","path","files: Array<IOutput>","path: Array<string>","cursor: StructureNode | undefined","path","path","cursor: StructureNode | null"],"sources":["../src/brands.ts","../src/log.ts","../src/files/file.ts","../src/guards.ts","../src/languages/extensions.ts","../src/planner/resolvers.ts","../src/languages/resolvers.ts","../src/files/registry.ts","../src/refs/refs.ts","../src/nodes/registry.ts","../src/project/namespace.ts","../src/planner/scope.ts","../src/planner/analyzer.ts","../src/planner/planner.ts","../src/symbols/symbol.ts","../src/symbols/registry.ts","../src/project/project.ts","../src/structure/node.ts","../src/structure/model.ts"],"sourcesContent":["export const fileBrand = 'heyapi.file';\nexport const nodeBrand = 'heyapi.node';\nexport const symbolBrand = 'heyapi.symbol';\n","import colors from 'ansi-colors';\n// @ts-expect-error\nimport colorSupport from 'color-support';\n\ncolors.enabled = colorSupport().hasBasic;\n\n/**\n * Accepts a value or a readonly array of values of type T.\n */\nexport type MaybeArray<T> = T | ReadonlyArray<T>;\n\n/**\n * Accepts a value or a function returning a value.\n */\nexport type MaybeFunc<T extends (...args: Array<any>) => any> =\n  | T\n  | ReturnType<T>;\n\nconst DEBUG_NAMESPACE = 'heyapi';\n\nconst NO_WARNINGS = /^(1|true|yes|on)$/i.test(\n  process.env.HEYAPI_DISABLE_WARNINGS ?? '',\n);\n\nconst DebugGroups = {\n  analyzer: colors.greenBright,\n  dsl: colors.cyanBright,\n  file: colors.yellowBright,\n  registry: colors.blueBright,\n  symbol: colors.magentaBright,\n} as const;\n\nconst WarnGroups = {\n  deprecated: colors.magentaBright,\n} as const;\n\nlet cachedDebugGroups: Set<string> | undefined;\nfunction getDebugGroups(): Set<string> {\n  if (cachedDebugGroups) return cachedDebugGroups;\n\n  const value = process.env.DEBUG;\n  cachedDebugGroups = new Set(\n    value ? value.split(',').map((x) => x.trim().toLowerCase()) : [],\n  );\n\n  return cachedDebugGroups;\n}\n\n/**\n * Tracks which deprecations have been shown to avoid spam.\n */\nconst shownDeprecations = new Set<string>();\n\nfunction debug(message: string, group: keyof typeof DebugGroups) {\n  const groups = getDebugGroups();\n  if (\n    !(\n      groups.has('*') ||\n      groups.has(`${DEBUG_NAMESPACE}:*`) ||\n      groups.has(`${DEBUG_NAMESPACE}:${group}`) ||\n      groups.has(group)\n    )\n  ) {\n    return;\n  }\n\n  const color = DebugGroups[group] ?? colors.whiteBright;\n  const prefix = color(`${DEBUG_NAMESPACE}:${group}`);\n\n  console.debug(`${prefix} ${message}`);\n}\n\nfunction warn(message: string, group: keyof typeof WarnGroups) {\n  if (NO_WARNINGS) return;\n\n  const color = WarnGroups[group] ?? colors.yellowBright;\n\n  console.warn(color(`${message}`));\n}\n\nfunction warnDeprecated({\n  context,\n  field,\n  replacement,\n}: {\n  context?: string;\n  field: string;\n  replacement?: MaybeFunc<(field: string) => MaybeArray<string>>;\n}) {\n  const key = context\n    ? `${context}:${field}:${JSON.stringify(replacement)}`\n    : `${field}:${JSON.stringify(replacement)}`;\n\n  if (shownDeprecations.has(key)) return;\n  shownDeprecations.add(key);\n\n  let message = `\\`${field}\\` is deprecated.`;\n\n  if (replacement) {\n    const reps =\n      typeof replacement === 'function' ? replacement(field) : replacement;\n    const repArray = reps instanceof Array ? reps : [reps];\n    const repString = repArray.map((r) => `\\`${r}\\``).join(' or ');\n    message += ` Use ${repString} instead.`;\n  }\n\n  const prefix = context ? `[${context}] ` : '';\n  warn(`${prefix}${message}`, 'deprecated');\n}\n\nexport const log = {\n  debug,\n  warn,\n  warnDeprecated,\n};\n","import path from 'node:path';\n\nimport type { ExportModule, ImportModule } from '../bindings';\nimport { fileBrand } from '../brands';\nimport type { Language } from '../languages/types';\nimport { log } from '../log';\nimport type { INode } from '../nodes/node';\nimport type { NameScopes } from '../planner/scope';\nimport type { IProject } from '../project/types';\nimport type { Renderer } from '../renderer';\nimport type { IFileIn } from './types';\n\nexport class File<Node extends INode = INode> {\n  /**\n   * Exports from this file.\n   */\n  private _exports: Array<ExportModule> = [];\n  /**\n   * File extension (e.g. `.ts`).\n   */\n  private _extension?: string;\n  /**\n   * Actual emitted file path, including extension and directories.\n   */\n  private _finalPath?: string;\n  /**\n   * Imports to this file.\n   */\n  private _imports: Array<ImportModule> = [];\n  /**\n   * Language of the file.\n   */\n  private _language?: Language;\n  /**\n   * Logical, extension-free path used for planning and routing.\n   */\n  private _logicalFilePath: string;\n  /**\n   * Base name of the file (without extension).\n   */\n  private _name?: string;\n  /**\n   * Syntax nodes contained in this file.\n   */\n  private _nodes: Array<Node> = [];\n  /**\n   * Renderer assigned to this file.\n   */\n  private _renderer?: Renderer;\n\n  /** Brand used for identifying files. */\n  readonly '~brand' = fileBrand;\n  /** All names defined in this file, including local scopes. */\n  allNames: NameScopes = new Map();\n  /** Whether this file is external to the project. */\n  external: boolean;\n  /** Unique identifier for the file. */\n  readonly id: number;\n  /** The project this file belongs to. */\n  readonly project: IProject;\n  /** Names declared at the top level of the file. */\n  topLevelNames: NameScopes = new Map();\n\n  constructor(input: IFileIn, id: number, project: IProject) {\n    this.external = input.external ?? false;\n    this.id = id;\n    if (input.language !== undefined) this._language = input.language;\n    this._logicalFilePath = input.logicalFilePath.split(path.sep).join('/');\n    if (input.name !== undefined) this._name = input.name;\n    this.project = project;\n  }\n\n  /**\n   * Exports from this file.\n   */\n  get exports(): ReadonlyArray<ExportModule> {\n    return [...this._exports];\n  }\n\n  /**\n   * Read-only accessor for the file extension.\n   */\n  get extension(): string | undefined {\n    if (this.external) return;\n    if (this._extension) return this._extension;\n    const language = this.language;\n    const extension = language ? this.project.extensions[language] : undefined;\n    if (extension && extension[0]) return extension[0];\n    return;\n  }\n\n  /**\n   * Read-only accessor for the final emitted path.\n   *\n   * If undefined, the file has not yet been assigned a final path\n   * or is external to the project and should not be emitted.\n   */\n  get finalPath(): string | undefined {\n    if (this._finalPath) return this._finalPath;\n    const dirs = this._logicalFilePath\n      ? this._logicalFilePath.split('/').slice(0, -1)\n      : [];\n    return [...dirs, `${this.name}${this.extension ?? ''}`].join('/');\n  }\n\n  /**\n   * Imports to this file.\n   */\n  get imports(): ReadonlyArray<ImportModule> {\n    return [...this._imports];\n  }\n\n  /**\n   * Language of the file; inferred from nodes or fallback if not set explicitly.\n   */\n  get language(): Language | undefined {\n    if (this._language) return this._language;\n    if (this._nodes[0]) return this._nodes[0].language;\n    return;\n  }\n\n  /**\n   * Logical, extension-free path used for planning and routing.\n   */\n  get logicalFilePath(): string {\n    return this._logicalFilePath;\n  }\n\n  /**\n   * Base name of the file (without extension).\n   *\n   * If no name was set explicitly, it is inferred from the logical file path.\n   */\n  get name(): string {\n    if (this._name) return this._name;\n    const name = this._logicalFilePath.split('/').pop();\n    if (name) return name;\n    const message = `File ${this.toString()} has no name`;\n    log.debug(message, 'file');\n    throw new Error(message);\n  }\n\n  /**\n   * Syntax nodes contained in this file.\n   */\n  get nodes(): ReadonlyArray<Node> {\n    return [...this._nodes];\n  }\n\n  /**\n   * Renderer assigned to this file.\n   */\n  get renderer(): Renderer | undefined {\n    return this._renderer;\n  }\n\n  /**\n   * Add an export group to the file.\n   */\n  addExport(group: ExportModule): void {\n    this._exports.push(group);\n  }\n\n  /**\n   * Add an import group to the file.\n   */\n  addImport(group: ImportModule): void {\n    this._imports.push(group);\n  }\n\n  /**\n   * Add a syntax node to the file.\n   */\n  addNode(node: Node): void {\n    this._nodes.push(node);\n    node.file = this;\n  }\n\n  /**\n   * Sets the file extension.\n   */\n  setExtension(extension: string): void {\n    this._extension = extension;\n  }\n\n  /**\n   * Sets the final emitted path of the file.\n   */\n  setFinalPath(path: string): void {\n    this._finalPath = path;\n  }\n\n  /**\n   * Sets the language of the file.\n   */\n  setLanguage(lang: Language): void {\n    this._language = lang;\n  }\n\n  /**\n   * Sets the name of the file.\n   */\n  setName(name: string): void {\n    this._name = name;\n  }\n\n  /**\n   * Sets the renderer assigned to this file.\n   */\n  setRenderer(renderer: Renderer): void {\n    this._renderer = renderer;\n  }\n\n  /**\n   * Returns a debug‑friendly string representation identifying the file.\n   */\n  toString(): string {\n    return `[File ${this._logicalFilePath}#${this.id}]`;\n  }\n}\n","import { nodeBrand, symbolBrand } from './brands';\nimport type { INode } from './nodes/node';\nimport type { Ref } from './refs/types';\nimport type { Symbol } from './symbols/symbol';\n\nexport function isBrand(value: unknown, brand: string): value is INode {\n  if (!value || typeof value !== 'object') return false;\n  return (value as any)['~brand'] === brand;\n}\n\nexport function isNode(value: unknown): value is INode {\n  if (!value || typeof value !== 'object') return false;\n  return isBrand(value, nodeBrand);\n}\n\nexport function isNodeRef(value: Ref<unknown>): value is Ref<INode> {\n  return isBrand(value['~ref'], nodeBrand);\n}\n\nexport function isSymbol(value: unknown): value is Symbol {\n  return isBrand(value, symbolBrand);\n}\n\nexport function isSymbolRef(value: Ref<unknown>): value is Ref<Symbol> {\n  return isBrand(value['~ref'], symbolBrand);\n}\n","import type { Extensions } from './types';\n\nexport const defaultExtensions: Extensions = {\n  c: ['.c'],\n  'c#': ['.cs'],\n  'c++': ['.cpp', '.hpp'],\n  css: ['.css'],\n  dart: ['.dart'],\n  go: ['.go'],\n  haskell: ['.hs'],\n  html: ['.html'],\n  java: ['.java'],\n  javascript: ['.js', '.jsx'],\n  json: ['.json'],\n  kotlin: ['.kt'],\n  lua: ['.lua'],\n  markdown: ['.md'],\n  matlab: ['.m'],\n  perl: ['.pl'],\n  php: ['.php'],\n  python: ['.py'],\n  r: ['.r'],\n  ruby: ['.rb'],\n  rust: ['.rs'],\n  scala: ['.scala'],\n  shell: ['.sh'],\n  sql: ['.sql'],\n  swift: ['.swift'],\n  typescript: ['.ts', '.tsx'],\n  yaml: ['.yaml', '.yml'],\n};\n","import type { NameConflictResolver } from './types';\n\nexport const simpleNameConflictResolver: NameConflictResolver = ({\n  attempt,\n  baseName,\n}) => (attempt === 0 ? baseName : `${baseName}${attempt + 1}`);\n\nexport const underscoreNameConflictResolver: NameConflictResolver = ({\n  attempt,\n  baseName,\n}) => (attempt === 0 ? baseName : `${baseName}_${attempt + 1}`);\n","import { underscoreNameConflictResolver } from '../planner/resolvers';\nimport type { NameConflictResolvers } from './types';\n\nexport const defaultNameConflictResolvers: NameConflictResolvers = {\n  php: underscoreNameConflictResolver,\n  python: underscoreNameConflictResolver,\n  ruby: underscoreNameConflictResolver,\n};\n","import path from 'node:path';\n\nimport type { IProject } from '../project/types';\nimport { File } from './file';\nimport type { FileKeyArgs, IFileIn, IFileRegistry } from './types';\n\ntype FileId = number;\ntype FileKey = string;\n\nexport class FileRegistry implements IFileRegistry {\n  private _id: FileId = 0;\n  private _values: Map<FileKey, File> = new Map();\n  private readonly project: IProject;\n\n  constructor(project: IProject) {\n    this.project = project;\n  }\n\n  get(args: FileKeyArgs): File | undefined {\n    return this._values.get(this.createFileKey(args));\n  }\n\n  isRegistered(args: FileKeyArgs): boolean {\n    return this._values.has(this.createFileKey(args));\n  }\n\n  get nextId(): FileId {\n    return this._id++;\n  }\n\n  register(file: IFileIn): File {\n    const key = this.createFileKey(file);\n\n    let result = this._values.get(key);\n    if (result) {\n      if (file.name) {\n        result.setName(file.name);\n      }\n    } else {\n      result = new File(file, this.nextId, this.project);\n    }\n\n    this._values.set(key, result);\n\n    return result;\n  }\n\n  *registered(): IterableIterator<File> {\n    for (const file of this._values.values()) {\n      yield file;\n    }\n  }\n\n  private createFileKey(args: FileKeyArgs): string {\n    const logicalPath = args.logicalFilePath.split(path.sep).join('/');\n    return `${args.external ? 'ext:' : ''}${logicalPath}${args.language ? `:${args.language}` : ''}`;\n  }\n}\n","import type { FromRef, FromRefs, Ref, Refs } from './types';\n\n/**\n * Wraps a single value in a Ref object.\n *\n * If the value is already a Ref, returns it as-is (idempotent).\n *\n * @example\n * ```ts\n * const r = ref(123); // { '~ref': 123 }\n * console.log(r['~ref']); // 123\n *\n * const r2 = ref(r); // { '~ref': 123 } (not double-wrapped)\n * ```\n */\nexport const ref = <T>(value: T): Ref<T> => {\n  if (isRef(value)) {\n    return value as Ref<T>;\n  }\n  return { '~ref': value } as Ref<T>;\n};\n\n/**\n * Converts a plain object to an object of Refs (deep, per property).\n *\n * @example\n * ```ts\n * const obj = { a: 1, b: \"x\" };\n * const refs = refs(obj); // { a: { '~ref': 1 }, b: { '~ref': \"x\" } }\n * ```\n */\nexport const refs = <T extends Record<string, unknown>>(obj: T): Refs<T> => {\n  const result = {} as Refs<T>;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = ref(obj[key]);\n    }\n  }\n  return result;\n};\n\n/**\n * Unwraps a single Ref object to its value.\n *\n * @example\n * ```ts\n * const r = { '~ref': 42 };\n * const n = fromRef(r); // 42\n * console.log(n); // 42\n * ```\n */\nexport const fromRef = <T extends Ref<unknown> | undefined>(\n  ref: T,\n): FromRef<T> => ref?.['~ref'] as FromRef<T>;\n\n/**\n * Converts an object of Refs back to a plain object (unwraps all refs).\n *\n * @example\n * ```ts\n * const refs = { a: { '~ref': 1 }, b: { '~ref': \"x\" } };\n * const plain = fromRefs(refs); // { a: 1, b: \"x\" }\n * ```\n */\nexport const fromRefs = <T extends Refs<Record<string, unknown>>>(\n  obj: T,\n): FromRefs<T> => {\n  const result = {} as FromRefs<T>;\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      result[key] = fromRef(obj[key]!) as (typeof result)[typeof key];\n    }\n  }\n  return result;\n};\n\n/**\n * Checks whether a value is a Ref object.\n *\n * @param value Value to check\n * @returns True if the value is a Ref object.\n */\nexport const isRef = <T>(value: unknown): value is Ref<T> =>\n  typeof value === 'object' && value !== null && '~ref' in value;\n","import { fromRef, ref } from '../refs/refs';\nimport type { Ref } from '../refs/types';\nimport type { INode } from './node';\nimport type { INodeRegistry } from './types';\n\nexport class NodeRegistry implements INodeRegistry {\n  private list: Array<Ref<INode | null>> = [];\n\n  add(node: INode | null): number {\n    const index = this.list.push(ref(node));\n    return index - 1;\n  }\n\n  *all(): Iterable<INode> {\n    for (const r of this.list) {\n      const node = fromRef(r);\n      if (node) yield node;\n    }\n  }\n\n  remove(index: number): void {\n    this.list[index] = ref(null);\n  }\n\n  update(index: number, node: INode | null): void {\n    this.list[index] = ref(node);\n  }\n}\n","import type { SymbolKind } from '../symbols/types';\n\nconst kindRank: Record<SymbolKind, number> = {\n  class: 3,\n  enum: 4,\n  function: 5,\n  interface: 1,\n  namespace: 0,\n  type: 2,\n  var: 6,\n};\n\n/**\n * Returns true if two declarations of given kinds\n * are allowed to share the same identifier in TypeScript.\n */\nexport function canShareName(a: SymbolKind, b: SymbolKind): boolean {\n  // sort based on TypeScript merge precedence so `a` is always the weaker merge candidate\n  // ensures that asymmetric merges like `type + var` are correctly handled\n  if (kindRank[a] > kindRank[b]) {\n    [a, b] = [b, a];\n  }\n\n  switch (a) {\n    case 'interface':\n      return b === 'class' || b === 'interface';\n    case 'namespace':\n      return (\n        b === 'class' || b === 'enum' || b === 'function' || b === 'namespace'\n      );\n    case 'type':\n      // type can only merge with value-only declarations\n      return b === 'function' || b === 'var';\n    default:\n      return false;\n  }\n}\n","import type { Ref } from '../refs/types';\nimport type { Symbol } from '../symbols/symbol';\nimport type { SymbolKind } from '../symbols/types';\n\nexport type NameScopes = Map<string, Set<SymbolKind>>;\n\nexport type Scope = {\n  /** Child scopes. */\n  children: Array<Scope>;\n  /** Resolved names in this scope. */\n  localNames: NameScopes;\n  /** Parent scope, if any. */\n  parent?: Scope;\n  /** Symbols registered in this scope. */\n  symbols: Array<Ref<Symbol>>;\n};\n\nexport type AssignOptions = {\n  /** The primary scope in which to assign a symbol's final name. */\n  scope: Scope;\n  /** Additional scopes to update as side effects when assigning a symbol's final name. */\n  scopesToUpdate: ReadonlyArray<Scope>;\n};\n\nexport const createScope = (\n  args: {\n    localNames?: NameScopes;\n    parent?: Scope;\n  } = {},\n): Scope => ({\n  children: [],\n  localNames: args.localNames || new Map(),\n  parent: args.parent,\n  symbols: [],\n});\n","import { isNodeRef, isSymbolRef } from '../guards';\nimport type { INode, NodeRelationship } from '../nodes/node';\nimport { fromRef, isRef, ref } from '../refs/refs';\nimport type { Ref } from '../refs/types';\nimport type { Symbol } from '../symbols/symbol';\nimport type { NameScopes, Scope } from './scope';\nimport { createScope } from './scope';\nimport type { IAnalysisContext, Input } from './types';\n\nexport class AnalysisContext implements IAnalysisContext {\n  /**\n   * Stack of parent nodes during analysis.\n   *\n   * The top of the stack is the current semantic container.\n   */\n  private _parentStack: Array<INode> = [];\n\n  scope: Scope;\n  scopes: Scope = createScope();\n  symbol?: Symbol;\n\n  constructor(node: INode) {\n    this._parentStack.push(node);\n    this.scope = this.scopes;\n    this.symbol = node.symbol;\n  }\n\n  /**\n   * Get the current semantic parent (top of stack).\n   */\n  get currentParent(): INode | undefined {\n    return this._parentStack[this._parentStack.length - 1];\n  }\n\n  /**\n   * Register a child node under the current parent.\n   */\n  addChild(child: INode, relationship: NodeRelationship = 'container'): void {\n    const parent = this.currentParent;\n    if (!parent) return;\n\n    if (!parent.structuralChildren) {\n      parent.structuralChildren = new Map();\n    }\n    parent.structuralChildren.set(child, relationship);\n\n    if (!child.structuralParents) {\n      child.structuralParents = new Map();\n    }\n    child.structuralParents.set(parent, relationship);\n  }\n\n  addDependency(symbol: Ref<Symbol>): void {\n    if (this.symbol !== fromRef(symbol)) {\n      this.scope.symbols.push(symbol);\n    }\n  }\n\n  analyze(input: Input): void {\n    const value = isRef(input) ? input : ref(input);\n    if (isSymbolRef(value)) {\n      const symbol = fromRef(value);\n      // avoid adding self as child\n      if (symbol.node && this.currentParent !== symbol.node) {\n        this.addChild(symbol.node, 'reference');\n      }\n      this.addDependency(value);\n    } else if (isNodeRef(value)) {\n      const node = fromRef(value);\n      this.addChild(node, 'container');\n      this.pushParent(node);\n      node.analyze(this);\n      this.popParent();\n    }\n  }\n\n  localNames(scope: Scope): NameScopes {\n    const names: NameScopes = new Map();\n    for (const [name, kinds] of scope.localNames) {\n      names.set(name, new Set(kinds));\n    }\n    if (scope.parent) {\n      const parentNames = this.localNames(scope.parent);\n      for (const [name, kinds] of parentNames) {\n        if (!names.has(name)) {\n          names.set(name, kinds);\n        } else {\n          const existingKinds = names.get(name)!;\n          for (const kind of kinds) {\n            existingKinds.add(kind);\n          }\n        }\n      }\n    }\n    return names;\n  }\n\n  /**\n   * Pop the current semantic parent.\n   * Call this when exiting a container node.\n   */\n  popParent(): void {\n    this._parentStack.pop();\n  }\n\n  popScope(): void {\n    this.scope = this.scope.parent ?? this.scope;\n  }\n\n  /**\n   * Push a node as the current semantic parent.\n   */\n  pushParent(node: INode): void {\n    this._parentStack.push(node);\n  }\n\n  pushScope(): void {\n    const scope = createScope({ parent: this.scope });\n    this.scope.children.push(scope);\n    this.scope = scope;\n  }\n\n  walkScopes(\n    callback: (symbol: Ref<Symbol>, scope: Scope) => void,\n    scope: Scope = this.scopes,\n  ): void {\n    this.scope = scope;\n    for (const symbol of scope.symbols) {\n      callback(symbol, scope);\n    }\n    for (const child of scope.children) {\n      scope = child;\n      this.walkScopes(callback, scope);\n    }\n    this.scope = this.scopes;\n  }\n}\n\nexport class Analyzer {\n  private nodeCache = new WeakMap<INode, AnalysisContext>();\n\n  analyzeNode(node: INode): AnalysisContext {\n    const cached = this.nodeCache.get(node);\n    if (cached) return cached;\n\n    node.root = true;\n    const ctx = new AnalysisContext(node);\n    node.analyze(ctx);\n\n    this.nodeCache.set(node, ctx);\n    return ctx;\n  }\n\n  analyze(\n    nodes: Iterable<INode>,\n    callback?: (ctx: AnalysisContext, node: INode) => void,\n  ): void {\n    for (const node of nodes) {\n      const ctx = this.analyzeNode(node);\n      callback?.(ctx, node);\n    }\n  }\n}\n","import path from 'node:path';\n\nimport type { ExportModule, ImportModule } from '../bindings';\nimport type { IProjectRenderMeta } from '../extensions';\nimport type { File } from '../files/file';\nimport type { INode } from '../nodes/node';\nimport { canShareName } from '../project/namespace';\nimport type { IProject } from '../project/types';\nimport { fromRef } from '../refs/refs';\nimport type { RenderContext } from '../renderer';\nimport type { Symbol } from '../symbols/symbol';\nimport type { SymbolKind } from '../symbols/types';\nimport type { AnalysisContext } from './analyzer';\nimport { Analyzer } from './analyzer';\nimport type { AssignOptions, Scope } from './scope';\nimport { createScope } from './scope';\n\nconst isTypeOnlyKind = (kind: SymbolKind) =>\n  kind === 'type' || kind === 'interface';\n\nexport class Planner {\n  private readonly analyzer = new Analyzer();\n  private readonly cacheResolvedNames = new Set<number>();\n  private readonly project: IProject;\n\n  constructor(project: IProject) {\n    this.project = project;\n  }\n\n  /**\n   * Executes the planning phase for the project.\n   */\n  plan(meta?: IProjectRenderMeta) {\n    this.cacheResolvedNames.clear();\n    this.allocateFiles();\n    this.assignLocalNames();\n    this.resolveFilePaths(meta);\n    this.planExports();\n    this.planImports();\n  }\n\n  /**\n   * Creates and assigns a file to every node, re-export,\n   * and external dependency.\n   */\n  private allocateFiles(): void {\n    this.analyzer.analyze(this.project.nodes.all(), (ctx, node) => {\n      const symbol = node.symbol;\n      if (!symbol) return;\n\n      const file = this.project.files.register({\n        external: false,\n        language: node.language,\n        logicalFilePath:\n          symbol.getFilePath?.(symbol) || this.project.defaultFileName,\n      });\n      file.addNode(node);\n      symbol.setFile(file);\n      for (const exportFrom of symbol.exportFrom) {\n        this.project.files.register({\n          external: false,\n          language: file.language,\n          logicalFilePath: exportFrom,\n        });\n      }\n      ctx.walkScopes((dependency) => {\n        const dep = fromRef(dependency);\n        if (dep.external && dep.isCanonical && !dep.file) {\n          const file = this.project.files.register({\n            external: true,\n            language: dep.node?.language,\n            logicalFilePath: dep.external,\n          });\n          dep.setFile(file);\n        }\n      });\n    });\n  }\n\n  /**\n   * Assigns final names to all symbols.\n   *\n   * First assigns top-level (file-scoped) symbol names, then local symbols.\n   */\n  private assignLocalNames(): void {\n    this.analyzer.analyze(this.project.nodes.all(), (ctx, node) => {\n      const symbol = node.symbol;\n      if (!symbol) return;\n      this.assignTopLevelName({ ctx, node, symbol });\n    });\n\n    this.analyzer.analyze(this.project.nodes.all(), (ctx, node) => {\n      const file = node.file;\n      if (!file) return;\n      ctx.walkScopes((dependency) => {\n        const dep = fromRef(dependency);\n        // top-level or external symbol\n        if (dep.file) return;\n        // TODO: pass node\n        this.assignLocalName({\n          ctx,\n          file,\n          scopesToUpdate: [createScope({ localNames: file.allNames })],\n          symbol: dep,\n        });\n      });\n    });\n  }\n\n  /**\n   * Resolves and sets final file paths for all non-external files. Attaches renderers.\n   *\n   * Uses the project's fileName function if provided, otherwise uses the file's current name.\n   *\n   * Resolves final paths relative to the project's root directory.\n   */\n  private resolveFilePaths(meta?: IProjectRenderMeta): void {\n    for (const file of this.project.files.registered()) {\n      if (file.external) {\n        file.setFinalPath(file.logicalFilePath);\n        continue;\n      }\n      const finalName = this.project.fileName?.(file.name) || file.name;\n      file.setName(finalName);\n      const finalPath = file.finalPath;\n      if (finalPath) {\n        file.setFinalPath(path.resolve(this.project.root, finalPath));\n      }\n      const ctx: RenderContext = { file, meta, project: this.project };\n      const renderer = this.project.renderers.find((r) => r.supports(ctx));\n      if (renderer) file.setRenderer(renderer);\n    }\n  }\n\n  /**\n   * Plans exports by analyzing all exported symbols.\n   *\n   * Registers re-export targets as files and creates new exported symbols for them.\n   *\n   * Assigns names to re-exported symbols and collects re-export metadata,\n   * distinguishing type-only exports based on symbol kinds.\n   */\n  private planExports(): void {\n    const seenByFile = new Map<\n      File,\n      Map<string, { kinds: Set<SymbolKind>; symbol: Symbol }>\n    >();\n    const sourceFile = new Map<number, File>();\n\n    this.analyzer.analyze(this.project.nodes.all(), (ctx, node) => {\n      if (!node.exported) return;\n\n      const symbol = node.symbol;\n      if (!symbol) return;\n\n      const file = node.file;\n      if (!file) return;\n\n      for (const exportFrom of symbol.exportFrom) {\n        const target = this.project.files.register({\n          external: false,\n          language: node.language,\n          logicalFilePath: exportFrom,\n        });\n        if (target.id === file.id) continue;\n\n        let fileMap = seenByFile.get(target);\n        if (!fileMap) {\n          fileMap = new Map();\n          seenByFile.set(target, fileMap);\n        }\n\n        const exp = this.project.symbols.register({\n          exported: true,\n          external: symbol.external,\n          importKind: symbol.importKind,\n          kind: symbol.kind,\n          name: symbol.finalName,\n        });\n        exp.setFile(target);\n        sourceFile.set(exp.id, file);\n        // TODO: pass node\n        this.assignTopLevelName({ ctx, symbol: exp });\n\n        let entry = fileMap.get(exp.finalName);\n        if (!entry) {\n          entry = { kinds: new Set(), symbol: exp };\n          fileMap.set(exp.finalName, entry);\n        }\n        entry.kinds.add(exp.kind);\n      }\n    });\n\n    for (const [file, fileMap] of seenByFile) {\n      const exports = new Map<File, ExportModule>();\n      for (const [, entry] of fileMap) {\n        const source = sourceFile.get(entry.symbol.id)!;\n        let exp = exports.get(source);\n        if (!exp) {\n          exp = {\n            canExportAll: true,\n            exports: [],\n            from: source,\n            isTypeOnly: true,\n          };\n        }\n        const isTypeOnly = [...entry.kinds].every((kind) =>\n          isTypeOnlyKind(kind),\n        );\n        const exportedName = entry.symbol.finalName;\n        exp.exports.push({\n          exportedName,\n          isTypeOnly,\n          kind: entry.symbol.importKind,\n          sourceName: entry.symbol.name,\n        });\n        if (entry.symbol.name !== entry.symbol.finalName) {\n          exp.canExportAll = false;\n        }\n        if (!isTypeOnly) {\n          exp.isTypeOnly = false;\n        }\n        exports.set(source, exp);\n      }\n      for (const [, exp] of exports) {\n        file.addExport(exp);\n      }\n    }\n  }\n\n  /**\n   * Plans imports by analyzing symbol dependencies across files.\n   *\n   * For external dependencies, assigns top-level names.\n   *\n   * Creates or reuses import symbols for dependencies from other files,\n   * assigning names and updating import metadata including type-only flags.\n   */\n  private planImports(): void {\n    const seenByFile = new Map<\n      File,\n      Map<\n        string,\n        {\n          dep: Symbol;\n          kinds: Set<SymbolKind>;\n          symbol: Symbol;\n        }\n      >\n    >();\n\n    this.analyzer.analyze(this.project.nodes.all(), (ctx) => {\n      const symbol = ctx.symbol;\n      if (!symbol) return;\n\n      const file = symbol.file;\n      if (!file) return;\n\n      let fileMap = seenByFile.get(file);\n      if (!fileMap) {\n        fileMap = new Map();\n        seenByFile.set(file, fileMap);\n      }\n\n      ctx.walkScopes((dependency) => {\n        const dep = fromRef(dependency);\n        if (!dep.file || dep.file.id === file.id) return;\n\n        if (dep.external) {\n          // TODO: pass node\n          this.assignTopLevelName({ ctx, symbol: dep });\n        }\n\n        const fromFileId = dep.file.id;\n        const importedName = dep.finalName;\n        const isTypeOnly = isTypeOnlyKind(dep.kind);\n        const kind = dep.importKind;\n        const key = `${fromFileId}|${importedName}|${kind}|${isTypeOnly}`;\n\n        let entry = fileMap.get(key);\n        if (!entry) {\n          const imp = this.project.symbols.register({\n            exported: dep.exported,\n            external: dep.external,\n            importKind: dep.importKind,\n            kind: dep.kind,\n            name: dep.finalName,\n          });\n          imp.setFile(file);\n          // TODO: pass node\n          this.assignTopLevelName({\n            ctx,\n            scope: createScope({ localNames: imp.file!.allNames }),\n            symbol: imp,\n          });\n          entry = {\n            dep,\n            kinds: new Set(),\n            symbol: imp,\n          };\n          fileMap.set(key, entry);\n          entry.kinds.add(imp.kind);\n        }\n\n        dependency['~ref'] = entry.symbol;\n      });\n    });\n\n    for (const [file, fileMap] of seenByFile) {\n      const imports = new Map<File, ImportModule>();\n      for (const [, entry] of fileMap) {\n        const source = entry.dep.file!;\n        let imp = imports.get(source);\n        if (!imp) {\n          imp = {\n            from: source,\n            imports: [],\n            isTypeOnly: true,\n            kind: 'named',\n          };\n        }\n        const isTypeOnly = [...entry.kinds].every((kind) =>\n          isTypeOnlyKind(kind),\n        );\n        if (entry.symbol.importKind === 'namespace') {\n          imp.imports = [];\n          imp.kind = 'namespace';\n          imp.localName = entry.symbol.finalName;\n        } else if (entry.symbol.importKind === 'default') {\n          imp.kind = 'default';\n          imp.localName = entry.symbol.finalName;\n        } else {\n          imp.imports.push({\n            isTypeOnly,\n            localName: entry.symbol.finalName,\n            sourceName: entry.dep.finalName,\n          });\n        }\n        if (!isTypeOnly) {\n          imp.isTypeOnly = false;\n        }\n        imports.set(source, imp);\n      }\n      for (const [, imp] of imports) {\n        file.addImport(imp);\n      }\n    }\n  }\n\n  /**\n   * Assigns the final name to a top-level (file-scoped) symbol.\n   *\n   * Uses the symbol's file top-level names as the default scope,\n   * and updates all relevant name scopes including the file's allNames and local scopes.\n   *\n   * Supports optional overrides for the naming scope and scopes to update.\n   */\n  private assignTopLevelName(\n    args: Partial<AssignOptions> & {\n      ctx: AnalysisContext;\n      debug?: boolean;\n      node?: INode;\n      symbol: Symbol;\n    },\n  ): void {\n    if (!args.symbol.file) return;\n    this.assignSymbolName({\n      ...args,\n      file: args.symbol.file,\n      scope:\n        args?.scope ??\n        createScope({ localNames: args.symbol.file.topLevelNames }),\n      scopesToUpdate: [\n        createScope({ localNames: args.symbol.file.allNames }),\n        args.ctx.scopes,\n        ...(args?.scopesToUpdate ?? []),\n      ],\n    });\n  }\n\n  /**\n   * Assigns the final name to a non-top-level (local) symbol.\n   *\n   * Uses the provided scope or derives it from the current analysis context's local names.\n   *\n   * Updates all provided name scopes accordingly.\n   */\n  private assignLocalName(\n    args: Pick<Partial<AssignOptions>, 'scope'> &\n      Pick<AssignOptions, 'scopesToUpdate'> & {\n        ctx: AnalysisContext;\n        debug?: boolean;\n        /** The file the symbol belongs to. */\n        file: File;\n        node?: INode;\n        symbol: Symbol;\n      },\n  ): void {\n    this.assignSymbolName({\n      ...args,\n      scope: args.scope ?? args.ctx.scope,\n    });\n  }\n\n  /**\n   * Assigns the final name to a symbol within the provided name scope.\n   *\n   * Resolves name conflicts until a unique name is found.\n   *\n   * Updates all specified name scopes with the assigned final name.\n   */\n  private assignSymbolName(\n    args: AssignOptions & {\n      ctx: AnalysisContext;\n      debug?: boolean;\n      /** The file the symbol belongs to. */\n      file: File;\n      node?: INode;\n      symbol: Symbol;\n    },\n  ): void {\n    const { ctx, file, node, scope, scopesToUpdate, symbol } = args;\n    if (this.cacheResolvedNames.has(symbol.id)) return;\n\n    const baseName = symbol.name;\n    let finalName =\n      node?.nameSanitizer?.(baseName) ??\n      symbol.node?.nameSanitizer?.(baseName) ??\n      baseName;\n    let attempt = 1;\n\n    const localNames = ctx.localNames(scope);\n    while (true) {\n      const kinds = [...(localNames.get(finalName) ?? [])];\n\n      const ok = kinds.every((kind) => canShareName(symbol.kind, kind));\n      if (ok) break;\n\n      const language = node?.language || symbol.node?.language || file.language;\n      const resolver =\n        (language ? this.project.nameConflictResolvers[language] : undefined) ??\n        this.project.defaultNameConflictResolver;\n      const resolvedName = resolver({ attempt, baseName });\n      if (!resolvedName) {\n        throw new Error(`Unresolvable name conflict: ${symbol.toString()}`);\n      }\n\n      finalName =\n        node?.nameSanitizer?.(resolvedName) ??\n        symbol.node?.nameSanitizer?.(resolvedName) ??\n        resolvedName;\n      attempt = attempt + 1;\n    }\n\n    symbol.setFinalName(finalName);\n    this.cacheResolvedNames.add(symbol.id);\n    const updateScopes = [scope, ...scopesToUpdate];\n    for (const scope of updateScopes) {\n      this.updateScope(symbol, scope);\n    }\n  }\n\n  /**\n   * Updates the provided name scope with the symbol's final name and kind.\n   *\n   * Ensures the name scope tracks all kinds associated with a given name.\n   */\n  private updateScope(symbol: Symbol, scope: Scope): void {\n    const name = symbol.finalName;\n    const cache = scope.localNames.get(name) ?? new Set();\n    cache.add(symbol.kind);\n    scope.localNames.set(name, cache);\n  }\n}\n","import { symbolBrand } from '../brands';\nimport type { ISymbolMeta } from '../extensions';\nimport type { File } from '../files/file';\nimport { log } from '../log';\nimport type { INode } from '../nodes/node';\nimport type { BindingKind, ISymbolIn, SymbolKind } from './types';\n\nexport class Symbol<Node extends INode = INode> {\n  /**\n   * Canonical symbol this stub resolves to, if any.\n   *\n   * Stubs created during DSL construction may later be associated\n   * with a fully registered symbol. Once set, all property lookups\n   * should defer to the canonical symbol.\n   */\n  private _canonical?: Symbol;\n  /**\n   * True if this symbol is exported from its defining file.\n   *\n   * @default false\n   */\n  private _exported: boolean;\n  /**\n   * Names of files (without extension) from which this symbol is re-exported.\n   *\n   * @default []\n   */\n  private _exportFrom: ReadonlyArray<string>;\n  /**\n   * External module name if this symbol is imported from a module not managed\n   * by the project (e.g. \"zod\", \"lodash\").\n   *\n   * @default undefined\n   */\n  private _external?: string;\n  /**\n   * The file this symbol is ultimately emitted into.\n   *\n   * Only top-level symbols have an assigned file.\n   */\n  private _file?: File;\n  /**\n   * The alias-resolved, conflict-free emitted name.\n   */\n  private _finalName?: string;\n  /**\n   * Custom strategy to determine file output path.\n   *\n   * @returns The file path to output the symbol to, or undefined to fallback to default behavior.\n   */\n  private _getFilePath?: (symbol: Symbol) => string | undefined;\n  /**\n   * How this symbol should be imported (namespace/default/named).\n   *\n   * @default 'named'\n   */\n  private _importKind: BindingKind;\n  /**\n   * Kind of symbol (class, type, alias, etc.).\n   *\n   * @default 'var'\n   */\n  private _kind: SymbolKind;\n  /**\n   * Arbitrary user metadata.\n   *\n   * @default undefined\n   */\n  private _meta?: ISymbolMeta;\n  /**\n   * Intended user-facing name before conflict resolution.\n   *\n   * @example \"UserModel\"\n   */\n  private _name: string;\n  /**\n   * Node that defines this symbol.\n   */\n  private _node?: Node;\n\n  /** Brand used for identifying symbols. */\n  readonly '~brand' = symbolBrand;\n  /** Globally unique, stable symbol ID. */\n  readonly id: number;\n\n  constructor(input: ISymbolIn, id: number) {\n    this._exported = input.exported ?? false;\n    this._exportFrom = input.exportFrom ?? [];\n    this._external = input.external;\n    this._getFilePath = input.getFilePath;\n    this.id = id;\n    this._importKind = input.importKind ?? 'named';\n    this._kind = input.kind ?? 'var';\n    this._meta = input.meta;\n    this._name = input.name;\n  }\n\n  /**\n   * Returns the canonical symbol for this instance.\n   *\n   * If this symbol was created as a stub, this getter returns\n   * the fully registered canonical symbol. Otherwise, it returns\n   * the symbol itself.\n   */\n  get canonical(): Symbol {\n    return this._canonical ?? this;\n  }\n\n  /**\n   * Indicates whether this symbol is exported from its defining file.\n   */\n  get exported(): boolean {\n    return this.canonical._exported;\n  }\n\n  /**\n   * Names of files (without extension) that re-export this symbol.\n   */\n  get exportFrom(): ReadonlyArray<string> {\n    return this.canonical._exportFrom;\n  }\n\n  /**\n   * External module from which this symbol originates, if any.\n   */\n  get external(): string | undefined {\n    return this.canonical._external;\n  }\n\n  /**\n   * Read‑only accessor for the assigned output file.\n   *\n   * Only top-level symbols have an assigned file.\n   */\n  get file(): File | undefined {\n    return this.canonical._file;\n  }\n\n  /**\n   * Read‑only accessor for the resolved final emitted name.\n   */\n  get finalName(): string {\n    if (!this.canonical._finalName) {\n      const message = `Symbol finalName has not been resolved yet for ${this.canonical.toString()}`;\n      log.debug(message, 'symbol');\n      throw new Error(message);\n    }\n    return this.canonical._finalName;\n  }\n\n  /**\n   * Custom file path resolver, if provided.\n   */\n  get getFilePath(): ((symbol: Symbol) => string | undefined) | undefined {\n    return this.canonical._getFilePath;\n  }\n\n  /**\n   * How this symbol should be imported (named/default/namespace).\n   */\n  get importKind(): BindingKind {\n    return this.canonical._importKind;\n  }\n\n  /**\n   * Indicates whether this is a canonical symbol (not a stub).\n   */\n  get isCanonical(): boolean {\n    return !this._canonical || this._canonical === this;\n  }\n\n  /**\n   * The symbol's kind (class, type, alias, variable, etc.).\n   */\n  get kind(): SymbolKind {\n    return this.canonical._kind;\n  }\n\n  /**\n   * Arbitrary user‑provided metadata associated with this symbol.\n   */\n  get meta(): ISymbolMeta | undefined {\n    return this.canonical._meta;\n  }\n\n  /**\n   * User-intended name before aliasing or conflict resolution.\n   */\n  get name(): string {\n    return this.canonical._name;\n  }\n\n  /**\n   * Read‑only accessor for the defining node.\n   */\n  get node(): Node | undefined {\n    return this.canonical._node as Node | undefined;\n  }\n\n  /**\n   * Marks this symbol as a stub and assigns its canonical symbol.\n   *\n   * After calling this, all semantic queries (name, kind, file,\n   * meta, etc.) should reflect the canonical symbol's values.\n   *\n   * @param symbol — The canonical symbol this stub should resolve to.\n   */\n  setCanonical(symbol: Symbol): void {\n    this._canonical = symbol;\n  }\n\n  /**\n   * Marks the symbol as exported from its file.\n   *\n   * @param exported — Whether the symbol is exported.\n   */\n  setExported(exported: boolean): void {\n    this.assertCanonical();\n    this._exported = exported;\n  }\n\n  /**\n   * Records file names that re‑export this symbol.\n   *\n   * @param list — Source files re‑exporting this symbol.\n   */\n  setExportFrom(list: ReadonlyArray<string>): void {\n    this.assertCanonical();\n    this._exportFrom = list;\n  }\n\n  /**\n   * Assigns the output file this symbol will be emitted into.\n   *\n   * This may only be set once.\n   */\n  setFile(file: File): void {\n    this.assertCanonical();\n    if (this._file && this._file !== file) {\n      const message = `Symbol ${this.canonical.toString()} is already assigned to a different file.`;\n      log.debug(message, 'symbol');\n      throw new Error(message);\n    }\n    this._file = file;\n  }\n\n  /**\n   * Assigns the conflict‑resolved final local name for this symbol.\n   *\n   * This may only be set once.\n   */\n  setFinalName(name: string): void {\n    this.assertCanonical();\n    if (this._finalName && this._finalName !== name) {\n      const message = `Symbol finalName has already been resolved for ${this.canonical.toString()}.`;\n      log.debug(message, 'symbol');\n      throw new Error(message);\n    }\n    this._finalName = name;\n  }\n\n  /**\n   * Sets how this symbol should be imported.\n   *\n   * @param kind — The import strategy (named/default/namespace).\n   */\n  setImportKind(kind: BindingKind): void {\n    this.assertCanonical();\n    this._importKind = kind;\n  }\n\n  /**\n   * Sets the symbol's kind (class, type, alias, variable, etc.).\n   *\n   * @param kind — The new symbol kind.\n   */\n  setKind(kind: SymbolKind): void {\n    this.assertCanonical();\n    this._kind = kind;\n  }\n\n  /**\n   * Updates the intended user‑facing name for this symbol.\n   *\n   * @param name — The new name.\n   */\n  setName(name: string): void {\n    this.assertCanonical();\n    this._name = name;\n  }\n\n  /**\n   * Binds the node that defines this symbol.\n   *\n   * This may only be set once.\n   */\n  setNode(node: Node): void {\n    this.assertCanonical();\n    if (this._node && this._node !== node) {\n      const message = `Symbol ${this.canonical.toString()} is already bound to a different node.`;\n      log.debug(message, 'symbol');\n      // TODO: symbol <> node relationship needs to be refactor to 1:many\n      // disabled in the meantime or it would throw\n      // throw new Error(message);\n    }\n    this._node = node;\n    node.symbol = this;\n  }\n\n  /**\n   * Returns a debug‑friendly string representation identifying the symbol.\n   */\n  toString(): string {\n    const canonical = this.canonical;\n    if (canonical._finalName && canonical._finalName !== canonical._name) {\n      return `[Symbol ${canonical._name} → ${canonical._finalName}#${canonical.id}]`;\n    }\n    return `[Symbol ${canonical._name}#${canonical.id}]`;\n  }\n\n  /**\n   * Ensures this symbol is canonical before allowing mutation.\n   *\n   * A symbol that has been marked as a stub (i.e., its `_canonical` points\n   * to a different symbol) may not be mutated. This guard throws an error\n   * if any setter attempts to modify a stub, preventing accidental writes\n   * to non‑canonical instances.\n   *\n   * @throws {Error} If the symbol is a stub and is being mutated.\n   */\n  private assertCanonical(): void {\n    if (this._canonical && this._canonical !== this) {\n      const message = `Illegal mutation of stub symbol ${this.toString()} → canonical: ${this._canonical.toString()}`;\n      log.debug(message, 'symbol');\n      throw new Error(message);\n    }\n  }\n}\n","import type { ISymbolMeta } from '../extensions';\nimport { Symbol } from './symbol';\nimport type { ISymbolIdentifier, ISymbolIn, ISymbolRegistry } from './types';\n\ntype IndexEntry = [string, unknown];\ntype IndexKeySpace = ReadonlyArray<IndexEntry>;\ntype QueryCacheKey = string;\ntype SymbolId = number;\n\nexport class SymbolRegistry implements ISymbolRegistry {\n  private _id: SymbolId = 0;\n  private _indices: Map<IndexEntry[0], Map<IndexEntry[1], Set<SymbolId>>> =\n    new Map();\n  private _queryCache: Map<QueryCacheKey, ReadonlyArray<SymbolId>> = new Map();\n  private _queryCacheDependencies: Map<QueryCacheKey, Set<QueryCacheKey>> =\n    new Map();\n  private _registered: Set<SymbolId> = new Set();\n  private _stubs: Set<SymbolId> = new Set();\n  private _stubCache: Map<QueryCacheKey, SymbolId> = new Map();\n  private _values: Map<SymbolId, Symbol> = new Map();\n\n  get(identifier: ISymbolIdentifier): Symbol | undefined {\n    return typeof identifier === 'number'\n      ? this._values.get(identifier)\n      : this.query(identifier)[0];\n  }\n\n  isRegistered(identifier: ISymbolIdentifier): boolean {\n    const symbol = this.get(identifier);\n    return symbol ? this._registered.has(symbol.id) : false;\n  }\n\n  get nextId(): SymbolId {\n    return this._id++;\n  }\n\n  query(filter: ISymbolMeta): ReadonlyArray<Symbol> {\n    const cacheKey = this.buildCacheKey(filter);\n    const cachedIds = this._queryCache.get(cacheKey);\n    if (cachedIds) {\n      return cachedIds.map((symbolId) => this._values.get(symbolId)!);\n    }\n    const sets: Array<Set<SymbolId>> = [];\n    const indexKeySpace = this.buildIndexKeySpace(filter);\n    const cacheDependencies = new Set<QueryCacheKey>();\n    let missed = false;\n    for (const indexEntry of indexKeySpace) {\n      cacheDependencies.add(this.serializeIndexEntry(indexEntry));\n      const values = this._indices.get(indexEntry[0]);\n      if (!values) {\n        missed = true;\n        break;\n      }\n      const set = values.get(indexEntry[1]);\n      if (!set) {\n        missed = true;\n        break;\n      }\n      sets.push(set);\n    }\n    if (missed || !sets.length) {\n      this._queryCacheDependencies.set(cacheKey, cacheDependencies);\n      this._queryCache.set(cacheKey, []);\n      return [];\n    }\n    let result = new Set(sets[0]);\n    for (const set of sets.slice(1)) {\n      result = new Set([...result].filter((symbolId) => set.has(symbolId)));\n    }\n    const resultIds = [...result];\n    this._queryCacheDependencies.set(cacheKey, cacheDependencies);\n    this._queryCache.set(cacheKey, resultIds);\n    return resultIds.map((symbolId) => this._values.get(symbolId)!);\n  }\n\n  reference(meta: ISymbolMeta): Symbol {\n    const [registered] = this.query(meta);\n    if (registered) return registered;\n\n    const cacheKey = this.buildCacheKey(meta);\n    const cachedId = this._stubCache.get(cacheKey);\n    if (cachedId !== undefined) return this._values.get(cachedId)!;\n\n    const stub = new Symbol({ meta, name: '' }, this.nextId);\n\n    this._values.set(stub.id, stub);\n    this._stubs.add(stub.id);\n    this._stubCache.set(cacheKey, stub.id);\n    return stub;\n  }\n\n  register(symbol: ISymbolIn): Symbol {\n    const result = new Symbol(symbol, this.nextId);\n\n    this._values.set(result.id, result);\n    this._registered.add(result.id);\n\n    if (result.meta) {\n      const indexKeySpace = this.buildIndexKeySpace(result.meta);\n      this.indexSymbol(result.id, indexKeySpace);\n      this.invalidateCache(indexKeySpace);\n      this.replaceStubs(result, indexKeySpace);\n    }\n\n    return result;\n  }\n\n  *registered(): IterableIterator<Symbol> {\n    for (const id of this._registered.values()) {\n      yield this._values.get(id)!;\n    }\n  }\n\n  private buildCacheKey(filter: ISymbolMeta): QueryCacheKey {\n    const indexKeySpace = this.buildIndexKeySpace(filter);\n    return indexKeySpace\n      .map((indexEntry) => this.serializeIndexEntry(indexEntry))\n      .sort() // ensure order-insensitivity\n      .join('|');\n  }\n\n  private buildIndexKeySpace(meta: ISymbolMeta, prefix = ''): IndexKeySpace {\n    const entries: Array<IndexEntry> = [];\n    for (const [key, value] of Object.entries(meta)) {\n      const path = prefix ? `${prefix}.${key}` : key;\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\n        entries.push(...this.buildIndexKeySpace(value as ISymbolMeta, path));\n      } else {\n        entries.push([path, value]);\n      }\n    }\n    return entries;\n  }\n\n  private indexSymbol(symbolId: SymbolId, indexKeySpace: IndexKeySpace): void {\n    for (const [key, value] of indexKeySpace) {\n      if (!this._indices.has(key)) this._indices.set(key, new Map());\n      const values = this._indices.get(key)!;\n      const set = values.get(value) ?? new Set();\n      set.add(symbolId);\n      values.set(value, set);\n    }\n  }\n\n  private invalidateCache(indexKeySpace: IndexKeySpace): void {\n    const changed = indexKeySpace.map((indexEntry) =>\n      this.serializeIndexEntry(indexEntry),\n    );\n    for (const [\n      cacheKey,\n      cacheDependencies,\n    ] of this._queryCacheDependencies.entries()) {\n      for (const key of changed) {\n        if (cacheDependencies.has(key)) {\n          this._queryCacheDependencies.delete(cacheKey);\n          this._queryCache.delete(cacheKey);\n          break;\n        }\n      }\n    }\n  }\n\n  private isSubset(sub: IndexKeySpace, sup: IndexKeySpace): boolean {\n    const supMap = new Map(sup);\n    for (const [key, value] of sub) {\n      if (!supMap.has(key) || supMap.get(key) !== value) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private replaceStubs(symbol: Symbol, indexKeySpace: IndexKeySpace): void {\n    for (const stubId of this._stubs.values()) {\n      const stub = this._values.get(stubId);\n      if (\n        stub?.meta &&\n        this.isSubset(this.buildIndexKeySpace(stub.meta), indexKeySpace)\n      ) {\n        const cacheKey = this.buildCacheKey(stub.meta);\n        this._stubCache.delete(cacheKey);\n        this._stubs.delete(stubId);\n        stub.setCanonical(symbol);\n      }\n    }\n  }\n\n  private serializeIndexEntry(indexEntry: IndexEntry): string {\n    return `${indexEntry[0]}:${JSON.stringify(indexEntry[1])}`;\n  }\n}\n","import path from 'node:path';\n\nimport type { IProjectRenderMeta } from '../extensions';\nimport { FileRegistry } from '../files/registry';\nimport { defaultExtensions } from '../languages/extensions';\nimport { defaultNameConflictResolvers } from '../languages/resolvers';\nimport type { Extensions, NameConflictResolvers } from '../languages/types';\nimport { NodeRegistry } from '../nodes/registry';\nimport type { IOutput } from '../output';\nimport { Planner } from '../planner/planner';\nimport { simpleNameConflictResolver } from '../planner/resolvers';\nimport type { NameConflictResolver } from '../planner/types';\nimport type { Renderer } from '../renderer';\nimport { SymbolRegistry } from '../symbols/registry';\nimport type { IProject } from './types';\n\nexport class Project implements IProject {\n  readonly files: FileRegistry;\n  readonly nodes = new NodeRegistry();\n  readonly symbols = new SymbolRegistry();\n\n  readonly defaultFileName: string;\n  readonly defaultNameConflictResolver: NameConflictResolver;\n  readonly extensions: Extensions;\n  readonly fileName?: (name: string) => string;\n  readonly nameConflictResolvers: NameConflictResolvers;\n  readonly renderers: ReadonlyArray<Renderer>;\n  readonly root: string;\n\n  constructor(\n    args: Pick<\n      Partial<IProject>,\n      | 'defaultFileName'\n      | 'defaultNameConflictResolver'\n      | 'extensions'\n      | 'fileName'\n      | 'nameConflictResolvers'\n      | 'renderers'\n    > &\n      Pick<IProject, 'root'>,\n  ) {\n    const fileName = args.fileName;\n    this.defaultFileName = args.defaultFileName ?? 'main';\n    this.defaultNameConflictResolver =\n      args.defaultNameConflictResolver ?? simpleNameConflictResolver;\n    this.extensions = {\n      ...defaultExtensions,\n      ...args.extensions,\n    };\n    this.fileName = typeof fileName === 'string' ? () => fileName : fileName;\n    this.files = new FileRegistry(this);\n    this.nameConflictResolvers = {\n      ...defaultNameConflictResolvers,\n      ...args.nameConflictResolvers,\n    };\n    this.renderers = args.renderers ?? [];\n    this.root = path.resolve(args.root).replace(/[/\\\\]+$/, '');\n  }\n\n  render(meta?: IProjectRenderMeta): ReadonlyArray<IOutput> {\n    new Planner(this).plan(meta);\n    const files: Array<IOutput> = [];\n    for (const file of this.files.registered()) {\n      if (!file.external && file.finalPath && file.renderer) {\n        const content = file.renderer.render({ file, meta, project: this });\n        files.push({ content, path: file.finalPath });\n      }\n    }\n    return files;\n  }\n}\n","import type { StructureItem, StructureShell } from './types';\n\nexport class StructureNode {\n  /** Nested nodes within this node. */\n  children: Map<string, StructureNode> = new Map();\n  /** Items contained in this node. */\n  items: Array<StructureItem> = [];\n  /** The name of this node (e.g., \"Users\", \"Accounts\"). */\n  name: string;\n  /** Parent node in the hierarchy. Undefined if this is the root node. */\n  parent?: StructureNode;\n  /** Shell claimed for this node. */\n  shell?: StructureShell;\n  /** Source of the claimed shell. */\n  shellSource?: symbol;\n  /** True if this is a virtual root. */\n  virtual: boolean;\n\n  constructor(\n    name: string,\n    parent?: StructureNode,\n    options?: {\n      virtual?: boolean;\n    },\n  ) {\n    this.name = name;\n    this.parent = parent;\n    this.virtual = options?.virtual ?? false;\n  }\n\n  get isRoot(): boolean {\n    return !this.parent;\n  }\n\n  /**\n   * Gets or creates a child node.\n   *\n   * If the child doesn't exist, it's created automatically.\n   *\n   * @param name - The name of the child node\n   * @returns The child node instance\n   */\n  child(name: string): StructureNode {\n    if (!this.children.has(name)) {\n      this.children.set(name, new StructureNode(name, this));\n    }\n    return this.children.get(name)!;\n  }\n\n  /**\n   * Gets the full path of this node in the hierarchy.\n   *\n   * @returns An array of node names from the root to this node\n   */\n  getPath(): ReadonlyArray<string> {\n    const path: Array<string> = [];\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let cursor: StructureNode | undefined = this;\n    while (cursor) {\n      path.unshift(cursor.name);\n      cursor = cursor.parent;\n    }\n    return path;\n  }\n\n  /**\n   * Yields items from a specific source with typed data.\n   *\n   * @param source - The source symbol to filter by\n   * @returns Generator of items from that source\n   */\n  *itemsFrom<T = unknown>(\n    source: symbol,\n  ): Generator<StructureItem & { data: T }> {\n    for (const item of this.items) {\n      if (item.source === source) {\n        yield item as StructureItem & { data: T };\n      }\n    }\n  }\n\n  /**\n   * Walk all nodes in the structure (depth-first, post-order).\n   *\n   * @returns Generator of all structure nodes\n   */\n  *walk(): Generator<StructureNode> {\n    for (const node of this.children.values()) {\n      yield* node.walk();\n    }\n    yield this;\n  }\n}\n","import { StructureNode } from './node';\nimport type { StructureInsert } from './types';\n\nexport class StructureModel {\n  /** Root nodes mapped by their names. */\n  private _roots: Map<string, StructureNode> = new Map();\n  /** Node for data without a specific root. */\n  private _virtualRoot?: StructureNode;\n\n  /**\n   * Get all root nodes.\n   */\n  get roots(): ReadonlyArray<StructureNode> {\n    const roots = Array.from(this._roots.values());\n    if (this._virtualRoot) roots.unshift(this._virtualRoot);\n    return roots;\n  }\n\n  /**\n   * Insert data into the structure.\n   */\n  insert(args: StructureInsert): void {\n    const { data, locations, source } = args;\n    for (const location of locations) {\n      const { path, shell } = location;\n      const fullPath = path.filter((s): s is string => Boolean(s));\n      const segments = fullPath.slice(0, -1);\n      const name = fullPath[fullPath.length - 1];\n\n      if (!name) {\n        throw new Error('Cannot insert data without path.');\n      }\n\n      let cursor: StructureNode | null = null;\n\n      for (const segment of segments) {\n        if (!cursor) {\n          cursor = this.root(segment);\n        } else {\n          cursor = cursor.child(segment);\n        }\n\n        if (shell && !cursor.shell) {\n          cursor.shell = shell;\n          cursor.shellSource = source;\n        }\n      }\n\n      if (!cursor) {\n        cursor = this.root(null);\n      }\n\n      cursor.items.push({ data, location: fullPath, source });\n    }\n  }\n\n  /**\n   * Gets or creates a root by name.\n   *\n   * If the root doesn't exist, it's created automatically.\n   *\n   * @param name - The name of the root\n   * @returns The root instance\n   */\n  root(name: string | null): StructureNode {\n    if (!name) {\n      return (this._virtualRoot ??= new StructureNode('', undefined, {\n        virtual: true,\n      }));\n    }\n    if (!this._roots.has(name)) {\n      this._roots.set(name, new StructureNode(name));\n    }\n    return this._roots.get(name)!;\n  }\n\n  /**\n   * Walk all nodes in the structure (depth-first, post-order).\n   *\n   * @returns Generator of all structure nodes\n   */\n  *walk(): Generator<StructureNode> {\n    if (this._virtualRoot) {\n      yield* this._virtualRoot.walk();\n    }\n    for (const root of this._roots.values()) {\n      yield* root.walk();\n    }\n  }\n}\n"],"mappings":"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"}